{"ts":1375554937509,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"<?php\r\n\r\n/*\r\n$Id: nusoap.php,v 1.114 2007/11/06 15:17:46 snichol Exp $\r\n\r\nNuSOAP - Web Services Toolkit for PHP\r\n\r\nCopyright (c) 2002 NuSphere Corporation\r\n\r\nThis library is free software; you can redistribute it and/or\r\nmodify it under the terms of the GNU Lesser General Public\r\nLicense as published by the Free Software Foundation; either\r\nversion 2.1 of the License, or (at your option) any later version.\r\n\r\nThis library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\nLesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public\r\nLicense along with this library; if not, write to the Free Software\r\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\r\n\r\nThe NuSOAP project home is:\r\nhttp://sourceforge.net/projects/nusoap/\r\n\r\nThe primary support for NuSOAP is the mailing list:\r\nnusoap-general@lists.sourceforge.net\r\n\r\nIf you have any questions or comments, please email:\r\n\r\nDietrich Ayala\r\ndietrich@ganx4.com\r\nhttp://dietrich.ganx4.com/nusoap\r\n\r\nNuSphere Corporation\r\nhttp://www.nusphere.com\r\n\r\n*/\r\n\r\n/*\r\n *\tSome of the standards implmented in whole or part by NuSOAP:\r\n *\r\n *\tSOAP 1.1 (http://www.w3.org/TR/2000/NOTE-SOAP-20000508/)\r\n *\tWSDL 1.1 (http://www.w3.org/TR/2001/NOTE-wsdl-20010315)\r\n *\tSOAP Messages With Attachments (http://www.w3.org/TR/SOAP-attachments)\r\n *\tXML 1.0 (http://www.w3.org/TR/2006/REC-xml-20060816/)\r\n *\tNamespaces in XML 1.0 (http://www.w3.org/TR/2006/REC-xml-names-20060816/)\r\n *\tXML Schema 1.0 (http://www.w3.org/TR/xmlschema-0/)\r\n *\tRFC 2045 Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\r\n *\tRFC 2068 Hypertext Transfer Protocol -- HTTP/1.1\r\n *\tRFC 2617 HTTP Authentication: Basic and Digest Access Authentication\r\n */\r\n\r\n/* load classes\r\n\r\n// necessary classes\r\nrequire_once('class.soapclient.php');\r\nrequire_once('class.soap_val.php');\r\nrequire_once('class.soap_parser.php');\r\nrequire_once('class.soap_fault.php');\r\n\r\n// transport classes\r\nrequire_once('class.soap_transport_http.php');\r\n\r\n// optional add-on classes\r\nrequire_once('class.xmlschema.php');\r\nrequire_once('class.wsdl.php');\r\n\r\n// server class\r\nrequire_once('class.soap_server.php');*/\r\n\r\n// class variable emulation\r\n// cf. http://www.webkreator.com/php/techniques/php-static-class-variables.html\r\n$GLOBALS['_transient']['static']['nusoap_base']->globalDebugLevel = 9;\r\n\r\n/**\r\n*\r\n* nusoap_base\r\n*\r\n* @author   Dietrich Ayala <dietrich@ganx4.com>\r\n* @author   Scott Nichol <snichol@users.sourceforge.net>\r\n* @version  $Id: nusoap.php,v 1.114 2007/11/06 15:17:46 snichol Exp $\r\n* @access   public\r\n*/\r\nclass nusoap_base {\r\n\t/**\r\n\t * Identification for HTTP headers.\r\n\t *\r\n\t * @var string\r\n\t * @access private\r\n\t */\r\n\tvar $title = 'NuSOAP';\r\n\t/**\r\n\t * Version for HTTP headers.\r\n\t *\r\n\t * @var string\r\n\t * @access private\r\n\t */\r\n\tvar $version = '0.7.3';\r\n\t/**\r\n\t * CVS revision for HTTP headers.\r\n\t *\r\n\t * @var string\r\n\t * @access private\r\n\t */\r\n\tvar $revision = '$Revision: 1.114 $';\r\n    /**\r\n     * Current error string (manipulated by getError/setError)\r\n\t *\r\n\t * @var string\r\n\t * @access private\r\n\t */\r\n\tvar $error_str = '';\r\n    /**\r\n     * Current debug string (manipulated by debug/appendDebug/clearDebug/getDebug/getDebugAsXMLComment)\r\n\t *\r\n\t * @var string\r\n\t * @access private\r\n\t */\r\n    var $debug_str = '';\r\n    /**\r\n\t * toggles automatic encoding of special characters as entities\r\n\t * (should always be true, I think)\r\n\t *\r\n\t * @var boolean\r\n\t * @access private\r\n\t */\r\n\tvar $charencoding = true;\r\n\t/**\r\n\t * the debug level for this instance\r\n\t *\r\n\t * @var\tinteger\r\n\t * @access private\r\n\t */\r\n\tvar $debugLevel;\r\n\r\n    /**\r\n\t* set schema version\r\n\t*\r\n\t* @var      string\r\n\t* @access   public\r\n\t*/\r\n\tvar $XMLSchemaVersion = 'http://www.w3.org/2001/XMLSchema';\r\n\t\r\n    /**\r\n\t* charset encoding for outgoing messages\r\n\t*\r\n\t* @var      string\r\n\t* @access   public\r\n\t*/\r\n    var $soap_defencoding = 'ISO-8859-1';\r\n\t//var $soap_defencoding = 'UTF-8';\r\n\r\n\t/**\r\n\t* namespaces in an array of prefix => uri\r\n\t*\r\n\t* this is \"seeded\" by a set of constants, but it may be altered by code\r\n\t*\r\n\t* @var      array\r\n\t* @access   public\r\n\t*/\r\n\tvar $namespaces = array(\r\n\t\t'SOAP-ENV' => 'http://schemas.xmlsoap.org/soap/envelope/',\r\n\t\t'xsd' => 'http://www.w3.org/2001/XMLSchema',\r\n\t\t'xsi' => 'http://www.w3.org/2001/XMLSchema-instance',\r\n\t\t'SOAP-ENC' => 'http://schemas.xmlsoap.org/soap/encoding/'\r\n\t\t);\r\n\r\n\t/**\r\n\t* namespaces used in the current context, e.g. during serialization\r\n\t*\r\n\t* @var      array\r\n\t* @access   private\r\n\t*/\r\n\tvar $usedNamespaces = array();\r\n\r\n\t/**\r\n\t* XML Schema types in an array of uri => (array of xml type => php type)\r\n\t* is this legacy yet?\r\n\t* no, this is used by the nusoap_xmlschema class to verify type => namespace mappings.\r\n\t* @var      array\r\n\t* @access   public\r\n\t*/\r\n\tvar $typemap = array(\r\n\t'http://www.w3.org/2001/XMLSchema' => array(\r\n\t\t'string'=>'string','boolean'=>'boolean','float'=>'double','double'=>'double','decimal'=>'double',\r\n\t\t'duration'=>'','dateTime'=>'string','time'=>'string','date'=>'string','gYearMonth'=>'',\r\n\t\t'gYear'=>'','gMonthDay'=>'','gDay'=>'','gMonth'=>'','hexBinary'=>'string','base64Binary'=>'string',\r\n\t\t// abstract \"any\" types\r\n\t\t'anyType'=>'string','anySimpleType'=>'string',\r\n\t\t// derived datatypes\r\n\t\t'normalizedString'=>'string','token'=>'string','language'=>'','NMTOKEN'=>'','NMTOKENS'=>'','Name'=>'','NCName'=>'','ID'=>'',\r\n\t\t'IDREF'=>'','IDREFS'=>'','ENTITY'=>'','ENTITIES'=>'','integer'=>'integer','nonPositiveInteger'=>'integer',\r\n\t\t'negativeInteger'=>'integer','long'=>'integer','int'=>'integer','short'=>'integer','byte'=>'integer','nonNegativeInteger'=>'integer',\r\n\t\t'unsignedLong'=>'','unsignedInt'=>'','unsignedShort'=>'','unsignedByte'=>'','positiveInteger'=>''),\r\n\t'http://www.w3.org/2000/10/XMLSchema' => array(\r\n\t\t'i4'=>'','int'=>'integer','boolean'=>'boolean','string'=>'string','double'=>'double',\r\n\t\t'float'=>'double','dateTime'=>'string',\r\n\t\t'timeInstant'=>'string','base64Binary'=>'string','base64'=>'string','ur-type'=>'array'),\r\n\t'http://www.w3.org/1999/XMLSchema' => array(\r\n\t\t'i4'=>'','int'=>'integer','boolean'=>'boolean','string'=>'string','double'=>'double',\r\n\t\t'float'=>'double','dateTime'=>'string',\r\n\t\t'timeInstant'=>'string','base64Binary'=>'string','base64'=>'string','ur-type'=>'array'),\r\n\t'http://soapinterop.org/xsd' => array('SOAPStruct'=>'struct'),\r\n\t'http://schemas.xmlsoap.org/soap/encoding/' => array('base64'=>'string','array'=>'array','Array'=>'array'),\r\n    'http://xml.apache.org/xml-soap' => array('Map')\r\n\t);\r\n\r\n\t/**\r\n\t* XML entities to convert\r\n\t*\r\n\t* @var      array\r\n\t* @access   public\r\n\t* @deprecated\r\n\t* @see\texpandEntities\r\n\t*/\r\n\tvar $xmlEntities = array('quot' => '\"','amp' => '&',\r\n\t\t'lt' => '<','gt' => '>','apos' => \"'\");\r\n\r\n\t/**\r\n\t* constructor\r\n\t*\r\n\t* @access\tpublic\r\n\t*/\r\n\tfunction nusoap_base() {\r\n\t\t$this->debugLevel = $GLOBALS['_transient']['static']['nusoap_base']->globalDebugLevel;\r\n\t}\r\n\r\n\t/**\r\n\t* gets the global debug level, which applies to future instances\r\n\t*\r\n\t* @return\tinteger\tDebug level 0-9, where 0 turns off\r\n\t* @access\tpublic\r\n\t*/\r\n\tfunction getGlobalDebugLevel() {\r\n\t\treturn $GLOBALS['_transient']['static']['nusoap_base']->globalDebugLevel;\r\n\t}\r\n\r\n\t/**\r\n\t* sets the global debug level, which applies to future instances\r\n\t*\r\n\t* @param\tint\t$level\tDebug level 0-9, where 0 turns off\r\n\t* @access\tpublic\r\n\t*/\r\n\tfunction setGlobalDebugLevel($level) {\r\n\t\t$GLOBALS['_transient']['static']['nusoap_base']->globalDebugLevel = $level;\r\n\t}\r\n\r\n\t/**\r\n\t* gets the debug level for this instance\r\n\t*\r\n\t* @return\tint\tDebug level 0-9, where 0 turns off\r\n\t* @access\tpublic\r\n\t*/\r\n\tfunction getDebugLevel() {\r\n\t\treturn $this->debugLevel;\r\n\t}\r\n\r\n\t/**\r\n\t* sets the debug level for this instance\r\n\t*\r\n\t* @param\tint\t$level\tDebug level 0-9, where 0 turns off\r\n\t* @access\tpublic\r\n\t*/\r\n\tfunction setDebugLevel($level) {\r\n\t\t$this->debugLevel = $level;\r\n\t}\r\n\r\n\t/**\r\n\t* adds debug data to the instance debug string with formatting\r\n\t*\r\n\t* @param    string $string debug data\r\n\t* @access   private\r\n\t*/\r\n\tfunction debug($string){\r\n\t\tif ($this->debugLevel > 0) {\r\n\t\t\t$this->appendDebug($this->getmicrotime().' '.get_class($this).\": $string\\n\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* adds debug data to the instance debug string without formatting\r\n\t*\r\n\t* @param    string $string debug data\r\n\t* @access   public\r\n\t*/\r\n\tfunction appendDebug($string){\r\n\t\tif ($this->debugLevel > 0) {\r\n\t\t\t// it would be nice to use a memory stream here to use\r\n\t\t\t// memory more efficiently\r\n\t\t\t$this->debug_str .= $string;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* clears the current debug data for this instance\r\n\t*\r\n\t* @access   public\r\n\t*/\r\n\tfunction clearDebug() {\r\n\t\t// it would be nice to use a memory stream here to use\r\n\t\t// memory more efficiently\r\n\t\t$this->debug_str = '';\r\n\t}\r\n\r\n\t/**\r\n\t* gets the current debug data for this instance\r\n\t*\r\n\t* @return   debug data\r\n\t* @access   public\r\n\t*/\r\n\tfunction &getDebug() {\r\n\t\t// it would be nice to use a memory stream here to use\r\n\t\t// memory more efficiently\r\n\t\treturn $this->debug_str;\r\n\t}\r\n\r\n\t/**\r\n\t* gets the current debug data for this instance as an XML comment\r\n\t* this may change the contents of the debug data\r\n\t*\r\n\t* @return   debug data as an XML comment\r\n\t* @access   public\r\n\t*/\r\n\tfunction &getDebugAsXMLComment() {\r\n\t\t// it would be nice to use a memory stream here to use\r\n\t\t// memory more efficiently\r\n\t\twhile (strpos($this->debug_str, '--')) {\r\n\t\t\t$this->debug_str = str_replace('--', '- -', $this->debug_str);\r\n\t\t}\r\n\t\t$ret = \"<!--\\n\" . $this->debug_str . \"\\n-->\";\r\n    \treturn $ret;\r\n\t}\r\n\r\n\t/**\r\n\t* expands entities, e.g. changes '<' to '&lt;'.\r\n\t*\r\n\t* @param\tstring\t$val\tThe string in which to expand entities.\r\n\t* @access\tprivate\r\n\t*/\r\n\tfunction expandEntities($val) {\r\n\t\tif ($this->charencoding) {\r\n\t    \t$val = str_replace('&', '&amp;', $val);\r\n\t    \t$val = str_replace(\"'\", '&apos;', $val);\r\n\t    \t$val = str_replace('\"', '&quot;', $val);\r\n\t    \t$val = str_replace('<', '&lt;', $val);\r\n\t    \t$val = str_replace('>', '&gt;', $val);\r\n\t    }\r\n\t    return $val;\r\n\t}\r\n\r\n\t/**\r\n\t* returns error string if present\r\n\t*\r\n\t* @return   mixed error string or false\r\n\t* @access   public\r\n\t*/\r\n\tfunction getError(){\r\n\t\tif($this->error_str != ''){\r\n\t\t\treturn $this->error_str;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t* sets error string\r\n\t*\r\n\t* @return   boolean $string error string\r\n\t* @access   private\r\n\t*/\r\n\tfunction setError($str){\r\n\t\t$this->error_str = $str;\r\n\t}\r\n\r\n\t/**\r\n\t* detect if array is a simple array or a struct (associative array)\r\n\t*\r\n\t* @param\tmixed\t$val\tThe PHP array\r\n\t* @return\tstring\t(arraySimple|arrayStruct)\r\n\t* @access\tprivate\r\n\t*/\r\n\tfunction isArraySimpleOrStruct($val) {\r\n        $keyList = array_keys($val);\r\n\t\tforeach ($keyList as $keyListValue) {\r\n\t\t\tif (!is_int($keyListValue)) {\r\n\t\t\t\treturn 'arrayStruct';\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn 'arraySimple';\r\n\t}\r\n\r\n\t/**\r\n\t* serializes PHP values in accordance w/ section 5. Type information is\r\n\t* not serialized if $use == 'literal'.\r\n\t*\r\n\t* @param\tmixed\t$val\tThe value to serialize\r\n\t* @param\tstring\t$name\tThe name (local part) of the XML element\r\n\t* @param\tstring\t$type\tThe XML schema type (local part) for the element\r\n\t* @param\tstring\t$name_ns\tThe namespace for the name of the XML element\r\n\t* @param\tstring\t$type_ns\tThe namespace for the type of the element\r\n\t* @param\tarray\t$attributes\tThe attributes to serialize as name=>value pairs\r\n\t* @param\tstring\t$use\tThe WSDL \"use\" (encoded|literal)\r\n\t* @param\tboolean\t$soapval\tWhether this is called from soapval.\r\n\t* @return\tstring\tThe serialized element, possibly with child elements\r\n    * @access\tpublic\r\n\t*/\r\n\tfunction serialize_val($val,$name=false,$type=false,$name_ns=false,$type_ns=false,$attributes=false,$use='encoded',$soapval=false) {\r\n\t\t$this->debug(\"in serialize_val: name=$name, type=$type, name_ns=$name_ns, type_ns=$type_ns, use=$use, soapval=$soapval\");\r\n\t\t$this->appendDebug('value=' . $this->varDump($val));\r\n\t\t$this->appendDebug('attributes=' . $this->varDump($attributes));\r\n\t\t\r\n    \tif (is_object($val) && get_class($val) == 'soapval' && (! $soapval)) {\r\n    \t\t$this->debug(\"serialize_val: serialize soapval\");\r\n        \t$xml = $val->serialize($use);\r\n\t\t\t$this->appendDebug($val->getDebug());\r\n\t\t\t$val->clearDebug();\r\n\t\t\t$this->debug(\"serialize_val of soapval returning $xml\");\r\n\t\t\treturn $xml;\r\n        }\r\n\t\t// force valid name if necessary\r\n\t\tif (is_numeric($name)) {\r\n\t\t\t$name = '__numeric_' . $name;\r\n\t\t} elseif (! $name) {\r\n\t\t\t$name = 'noname';\r\n\t\t}\r\n\t\t// if name has ns, add ns prefix to name\r\n\t\t$xmlns = '';\r\n        if($name_ns){\r\n\t\t\t$prefix = 'nu'.rand(1000,9999);\r\n\t\t\t$name = $prefix.':'.$name;\r\n\t\t\t$xmlns .= \" xmlns:$prefix=\\\"$name_ns\\\"\";\r\n\t\t}\r\n\t\t// if type is prefixed, create type prefix\r\n\t\tif($type_ns != '' && $type_ns == $this->namespaces['xsd']){\r\n\t\t\t// need to fix this. shouldn't default to xsd if no ns specified\r\n\t\t    // w/o checking against typemap\r\n\t\t\t$type_prefix = 'xsd';\r\n\t\t} elseif($type_ns){\r\n\t\t\t$type_prefix = 'ns'.rand(1000,9999);\r\n\t\t\t$xmlns .= \" xmlns:$type_prefix=\\\"$type_ns\\\"\";\r\n\t\t}\r\n\t\t// serialize attributes if present\r\n\t\t$atts = '';\r\n\t\tif($attributes){\r\n\t\t\tforeach($attributes as $k => $v){\r\n\t\t\t\t$atts .= \" $k=\\\"\".$this->expandEntities($v).'\"';\r\n\t\t\t}\r\n\t\t}\r\n\t\t// serialize null value\r\n\t\tif (is_null($val)) {\r\n    \t\t$this->debug(\"serialize_val: serialize null\");\r\n\t\t\tif ($use == 'literal') {\r\n\t\t\t\t// TODO: depends on minOccurs\r\n\t\t\t\t$xml = \"<$name$xmlns$atts/>\";\r\n\t\t\t\t$this->debug(\"serialize_val returning $xml\");\r\n\t        \treturn $xml;\r\n        \t} else {\r\n\t\t\t\tif (isset($type) && isset($type_prefix)) {\r\n\t\t\t\t\t$type_str = \" xsi:type=\\\"$type_prefix:$type\\\"\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$type_str = '';\r\n\t\t\t\t}\r\n\t\t\t\t$xml = \"<$name$xmlns$type_str$atts xsi:nil=\\\"true\\\"/>\";\r\n\t\t\t\t$this->debug(\"serialize_val returning $xml\");\r\n\t        \treturn $xml;\r\n        \t}\r\n\t\t}\r\n        // serialize if an xsd built-in primitive type\r\n        if($type != '' && isset($this->typemap[$this->XMLSchemaVersion][$type])){\r\n    \t\t$this->debug(\"serialize_val: serialize xsd built-in primitive type\");\r\n        \tif (is_bool($val)) {\r\n        \t\tif ($type == 'boolean') {\r\n\t        \t\t$val = $val ? 'true' : 'false';\r\n\t        \t} elseif (! $val) {\r\n\t        \t\t$val = 0;\r\n\t        \t}\r\n\t\t\t} else if (is_string($val)) {\r\n\t\t\t\t$val = $this->expandEntities($val);\r\n\t\t\t}\r\n\t\t\tif ($use == 'literal') {\r\n\t\t\t\t$xml = \"<$name$xmlns$atts>$val</$name>\";\r\n\t\t\t\t$this->debug(\"serialize_val returning $xml\");\r\n\t        \treturn $xml;\r\n        \t} else {\r\n\t\t\t\t$xml = \"<$name$xmlns xsi:type=\\\"xsd:$type\\\"$atts>$val</$name>\";\r\n\t\t\t\t$this->debug(\"serialize_val returning $xml\");\r\n\t        \treturn $xml;\r\n        \t}\r\n        }\r\n\t\t// detect type and serialize\r\n\t\t$xml = '';\r\n\t\tswitch(true) {\r\n\t\t\tcase (is_bool($val) || $type == 'boolean'):\r\n\t\t   \t\t$this->debug(\"serialize_val: serialize boolean\");\r\n        \t\tif ($type == 'boolean') {\r\n\t        \t\t$val = $val ? 'true' : 'false';\r\n\t        \t} elseif (! $val) {\r\n\t        \t\t$val = 0;\r\n\t        \t}\r\n\t\t\t\tif ($use == 'literal') {\r\n\t\t\t\t\t$xml .= \"<$name$xmlns$atts>$val</$name>\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$xml .= \"<$name$xmlns xsi:type=\\\"xsd:boolean\\\"$atts>$val</$name>\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase (is_int($val) || is_long($val) || $type == 'int'):\r\n\t\t   \t\t$this->debug(\"serialize_val: serialize int\");\r\n\t\t\t\tif ($use == 'literal') {\r\n\t\t\t\t\t$xml .= \"<$name$xmlns$atts>$val</$name>\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$xml .= \"<$name$xmlns xsi:type=\\\"xsd:int\\\"$atts>$val</$name>\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase (is_float($val)|| is_double($val) || $type == 'float'):\r\n\t\t   \t\t$this->debug(\"serialize_val: serialize float\");\r\n\t\t\t\tif ($use == 'literal') {\r\n\t\t\t\t\t$xml .= \"<$name$xmlns$atts>$val</$name>\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$xml .= \"<$name$xmlns xsi:type=\\\"xsd:float\\\"$atts>$val</$name>\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase (is_string($val) || $type == 'string'):\r\n\t\t   \t\t$this->debug(\"serialize_val: serialize string\");\r\n\t\t\t\t$val = $this->expandEntities($val);\r\n\t\t\t\tif ($use == 'literal') {\r\n\t\t\t\t\t$xml .= \"<$name$xmlns$atts>$val</$name>\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$xml .= \"<$name$xmlns xsi:type=\\\"xsd:string\\\"$atts>$val</$name>\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase is_object($val):\r\n\t\t   \t\t$this->debug(\"serialize_val: serialize object\");\r\n\t\t    \tif (get_class($val) == 'soapval') {\r\n\t\t    \t\t$this->debug(\"serialize_val: serialize soapval object\");\r\n\t\t        \t$pXml = $val->serialize($use);\r\n\t\t\t\t\t$this->appendDebug($val->getDebug());\r\n\t\t\t\t\t$val->clearDebug();\r\n\t\t        } else {\r\n\t\t\t\t\tif (! $name) {\r\n\t\t\t\t\t\t$name = get_class($val);\r\n\t\t\t\t\t\t$this->debug(\"In serialize_val, used class name $name as element name\");\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$this->debug(\"In serialize_val, do not override name $name for element name for class \" . get_class($val));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tforeach(get_object_vars($val) as $k => $v){\r\n\t\t\t\t\t\t$pXml = isset($pXml) ? $pXml.$this->serialize_val($v,$k,false,false,false,false,$use) : $this->serialize_val($v,$k,false,false,false,false,$use);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(isset($type) && isset($type_prefix)){\r\n\t\t\t\t\t$type_str = \" xsi:type=\\\"$type_prefix:$type\\\"\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$type_str = '';\r\n\t\t\t\t}\r\n\t\t\t\tif ($use == 'literal') {\r\n\t\t\t\t\t$xml .= \"<$name$xmlns$atts>$pXml</$name>\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$xml .= \"<$name$xmlns$type_str$atts>$pXml</$name>\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tbreak;\r\n\t\t\tcase (is_array($val) || $type):\r\n\t\t\t\t// detect if struct or array\r\n\t\t\t\t$valueType = $this->isArraySimpleOrStruct($val);\r\n                if($valueType=='arraySimple' || ereg('^ArrayOf',$type)){\r\n\t\t\t   \t\t$this->debug(\"serialize_val: serialize array\");\r\n\t\t\t\t\t$i = 0;\r\n\t\t\t\t\tif(is_array($val) && count($val)> 0){\r\n\t\t\t\t\t\tforeach($val as $v){\r\n\t                    \tif(is_object($v) && get_class($v) ==  'soapval'){\r\n\t\t\t\t\t\t\t\t$tt_ns = $v->type_ns;\r\n\t\t\t\t\t\t\t\t$tt = $v->type;\r\n\t\t\t\t\t\t\t} elseif (is_array($v)) {\r\n\t\t\t\t\t\t\t\t$tt = $this->isArraySimpleOrStruct($v);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t$tt = gettype($v);\r\n\t                        }\r\n\t\t\t\t\t\t\t$array_types[$tt] = 1;\r\n\t\t\t\t\t\t\t// TODO: for literal, the name should be $name\r\n\t\t\t\t\t\t\t$xml .= $this->serialize_val($v,'item',false,false,false,false,$use);\r\n\t\t\t\t\t\t\t++$i;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(count($array_types) > 1){\r\n\t\t\t\t\t\t\t$array_typename = 'xsd:anyType';\r\n\t\t\t\t\t\t} elseif(isset($tt) && isset($this->typemap[$this->XMLSchemaVersion][$tt])) {\r\n\t\t\t\t\t\t\tif ($tt == 'integer') {\r\n\t\t\t\t\t\t\t\t$tt = 'int';\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t$array_typename = 'xsd:'.$tt;\r\n\t\t\t\t\t\t} elseif(isset($tt) && $tt == 'arraySimple'){\r\n\t\t\t\t\t\t\t$array_typename = 'SOAP-ENC:Array';\r\n\t\t\t\t\t\t} elseif(isset($tt) && $tt == 'arrayStruct'){\r\n\t\t\t\t\t\t\t$array_typename = 'unnamed_struct_use_soapval';\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// if type is prefixed, create type prefix\r\n\t\t\t\t\t\t\tif ($tt_ns != '' && $tt_ns == $this->namespaces['xsd']){\r\n\t\t\t\t\t\t\t\t $array_typename = 'xsd:' . $tt;\r\n\t\t\t\t\t\t\t} elseif ($tt_ns) {\r\n\t\t\t\t\t\t\t\t$tt_prefix = 'ns' . rand(1000, 9999);\r\n\t\t\t\t\t\t\t\t$array_typename = \"$tt_prefix:$tt\";\r\n\t\t\t\t\t\t\t\t$xmlns .= \" xmlns:$tt_prefix=\\\"$tt_ns\\\"\";\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t$array_typename = $tt;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t$array_type = $i;\r\n\t\t\t\t\t\tif ($use == 'literal') {\r\n\t\t\t\t\t\t\t$type_str = '';\r\n\t\t\t\t\t\t} else if (isset($type) && isset($type_prefix)) {\r\n\t\t\t\t\t\t\t$type_str = \" xsi:type=\\\"$type_prefix:$type\\\"\";\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t$type_str = \" xsi:type=\\\"SOAP-ENC:Array\\\" SOAP-ENC:arrayType=\\\"\".$array_typename.\"[$array_type]\\\"\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t// empty array\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif ($use == 'literal') {\r\n\t\t\t\t\t\t\t$type_str = '';\r\n\t\t\t\t\t\t} else if (isset($type) && isset($type_prefix)) {\r\n\t\t\t\t\t\t\t$type_str = \" xsi:type=\\\"$type_prefix:$type\\\"\";\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t$type_str = \" xsi:type=\\\"SOAP-ENC:Array\\\" SOAP-ENC:arrayType=\\\"xsd:anyType[0]\\\"\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// TODO: for array in literal, there is no wrapper here\r\n\t\t\t\t\t$xml = \"<$name$xmlns$type_str$atts>\".$xml.\"</$name>\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// got a struct\r\n\t\t\t   \t\t$this->debug(\"serialize_val: serialize struct\");\r\n\t\t\t\t\tif(isset($type) && isset($type_prefix)){\r\n\t\t\t\t\t\t$type_str = \" xsi:type=\\\"$type_prefix:$type\\\"\";\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$type_str = '';\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ($use == 'literal') {\r\n\t\t\t\t\t\t$xml .= \"<$name$xmlns$atts>\";\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$xml .= \"<$name$xmlns$type_str$atts>\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tforeach($val as $k => $v){\r\n\t\t\t\t\t\t// Apache Map\r\n\t\t\t\t\t\tif ($type == 'Map' && $type_ns == 'http://xml.apache.org/xml-soap') {\r\n\t\t\t\t\t\t\t$xml .= '<item>';\r\n\t\t\t\t\t\t\t$xml .= $this->serialize_val($k,'key',false,false,false,false,$use);\r\n\t\t\t\t\t\t\t$xml .= $this->serialize_val($v,'value',false,false,false,false,$use);\r\n\t\t\t\t\t\t\t$xml .= '</item>';\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t$xml .= $this->serialize_val($v,$k,false,false,false,false,$use);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$xml .= \"</$name>\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t   \t\t$this->debug(\"serialize_val: serialize unknown\");\r\n\t\t\t\t$xml .= 'not detected, got '.gettype($val).' for '.$val;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\t$this->debug(\"serialize_val returning $xml\");\r\n\t\treturn $xml;\r\n\t}\r\n\r\n    /**\r\n    * serializes a message\r\n    *\r\n    * @param string $body the XML of the SOAP body\r\n    * @param mixed $headers optional string of XML with SOAP header content, or array of soapval objects for SOAP headers, or associative array\r\n    * @param array $namespaces optional the namespaces used in generating the body and headers\r\n    * @param string $style optional (rpc|document)\r\n    * @param string $use optional (encoded|literal)\r\n    * @param string $encodingStyle optional (usually 'http://schemas.xmlsoap.org/soap/encoding/' for encoded)\r\n    * @return string the message\r\n    * @access public\r\n    */\r\n    function serializeEnvelope($body,$headers=false,$namespaces=array(),$style='rpc',$use='encoded',$encodingStyle='http://schemas.xmlsoap.org/soap/encoding/'){\r\n    // TODO: add an option to automatically run utf8_encode on $body and $headers\r\n    // if $this->soap_defencoding is UTF-8.  Not doing this automatically allows\r\n    // one to send arbitrary UTF-8 characters, not just characters that map to ISO-8859-1\r\n\r\n\t$this->debug(\"In serializeEnvelope length=\" . strlen($body) . \" body (max 1000 characters)=\" . substr($body, 0, 1000) . \" style=$style use=$use encodingStyle=$encodingStyle\");\r\n\t$this->debug(\"headers:\");\r\n\t$this->appendDebug($this->varDump($headers));\r\n\t$this->debug(\"namespaces:\");\r\n\t$this->appendDebug($this->varDump($namespaces));\r\n\r\n\t// serialize namespaces\r\n    $ns_string = '';\r\n\tforeach(array_merge($this->namespaces,$namespaces) as $k => $v){\r\n\t\t$ns_string .= \" xmlns:$k=\\\"$v\\\"\";\r\n\t}\r\n\tif($encodingStyle) {\r\n\t\t$ns_string = \" SOAP-ENV:encodingStyle=\\\"$encodingStyle\\\"$ns_string\";\r\n\t}\r\n\r\n\t// serialize headers\r\n\tif($headers){\r\n\t\tif (is_array($headers)) {\r\n\t\t\t$xml = '';\r\n\t\t\tforeach ($headers as $k => $v) {\r\n\t\t\t\tif (is_object($v) && get_class($v) == 'soapval') {\r\n\t\t\t\t\t$xml .= $this->serialize_val($v, false, false, false, false, false, $use);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$xml .= $this->serialize_val($v, $k, false, false, false, false, $use);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t$headers = $xml;\r\n\t\t\t$this->debug(\"In serializeEnvelope, serialized array of headers to $headers\");\r\n\t\t}\r\n\t\t$headers = \"<SOAP-ENV:Header>\".$headers.\"</SOAP-ENV:Header>\";\r\n\t}\r\n\t// serialize envelope\r\n\treturn\r\n\t'<?xml version=\"1.0\" encoding=\"'.$this->soap_defencoding .'\"?'.\">\".\r\n\t'<SOAP-ENV:Envelope'.$ns_string.\">\".\r\n\t$headers.\r\n\t\"<SOAP-ENV:Body>\".\r\n\t\t$body.\r\n\t\"</SOAP-ENV:Body>\".\r\n\t\"</SOAP-ENV:Envelope>\";\r\n    }\r\n\r\n\t/**\r\n\t * formats a string to be inserted into an HTML stream\r\n\t *\r\n\t * @param string $str The string to format\r\n\t * @return string The formatted string\r\n\t * @access public\r\n\t * @deprecated\r\n\t */\r\n    function formatDump($str){\r\n\t\t$str = htmlspecialchars($str);\r\n\t\treturn nl2br($str);\r\n    }\r\n\r\n\t/**\r\n\t* contracts (changes namespace to prefix) a qualified name\r\n\t*\r\n\t* @param    string $qname qname\r\n\t* @return\tstring contracted qname\r\n\t* @access   private\r\n\t*/\r\n\tfunction contractQname($qname){\r\n\t\t// get element namespace\r\n\t\t//$this->xdebug(\"Contract $qname\");\r\n\t\tif (strrpos($qname, ':')) {\r\n\t\t\t// get unqualified name\r\n\t\t\t$name = substr($qname, strrpos($qname, ':') + 1);\r\n\t\t\t// get ns\r\n\t\t\t$ns = substr($qname, 0, strrpos($qname, ':'));\r\n\t\t\t$p = $this->getPrefixFromNamespace($ns);\r\n\t\t\tif ($p) {\r\n\t\t\t\treturn $p . ':' . $name;\r\n\t\t\t}\r\n\t\t\treturn $qname;\r\n\t\t} else {\r\n\t\t\treturn $qname;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* expands (changes prefix to namespace) a qualified name\r\n\t*\r\n\t* @param    string $qname qname\r\n\t* @return\tstring expanded qname\r\n\t* @access   private\r\n\t*/\r\n\tfunction expandQname($qname){\r\n\t\t// get element prefix\r\n\t\tif(strpos($qname,':') && !ereg('^http://',$qname)){\r\n\t\t\t// get unqualified name\r\n\t\t\t$name = substr(strstr($qname,':'),1);\r\n\t\t\t// get ns prefix\r\n\t\t\t$prefix = substr($qname,0,strpos($qname,':'));\r\n\t\t\tif(isset($this->namespaces[$prefix])){\r\n\t\t\t\treturn $this->namespaces[$prefix].':'.$name;\r\n\t\t\t} else {\r\n\t\t\t\treturn $qname;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn $qname;\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n    * returns the local part of a prefixed string\r\n    * returns the original string, if not prefixed\r\n    *\r\n    * @param string $str The prefixed string\r\n    * @return string The local part\r\n    * @access public\r\n    */\r\n\tfunction getLocalPart($str){\r\n\t\tif($sstr = strrchr($str,':')){\r\n\t\t\t// get unqualified name\r\n\t\t\treturn substr( $sstr, 1 );\r\n\t\t} else {\r\n\t\t\treturn $str;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n    * returns the prefix part of a prefixed string\r\n    * returns false, if not prefixed\r\n    *\r\n    * @param string $str The prefixed string\r\n    * @return mixed The prefix or false if there is no prefix\r\n    * @access public\r\n    */\r\n\tfunction getPrefix($str){\r\n\t\tif($pos = strrpos($str,':')){\r\n\t\t\t// get prefix\r\n\t\t\treturn substr($str,0,$pos);\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n    * pass it a prefix, it returns a namespace\r\n    *\r\n    * @param string $prefix The prefix\r\n    * @return mixed The namespace, false if no namespace has the specified prefix\r\n    * @access public\r\n    */\r\n\tfunction getNamespaceFromPrefix($prefix){\r\n\t\tif (isset($this->namespaces[$prefix])) {\r\n\t\t\treturn $this->namespaces[$prefix];\r\n\t\t}\r\n\t\t//$this->setError(\"No namespace registered for prefix '$prefix'\");\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n    * returns the prefix for a given namespace (or prefix)\r\n    * or false if no prefixes registered for the given namespace\r\n    *\r\n    * @param string $ns The namespace\r\n    * @return mixed The prefix, false if the namespace has no prefixes\r\n    * @access public\r\n    */\r\n\tfunction getPrefixFromNamespace($ns) {\r\n\t\tforeach ($this->namespaces as $p => $n) {\r\n\t\t\tif ($ns == $n || $ns == $p) {\r\n\t\t\t    $this->usedNamespaces[$p] = $n;\r\n\t\t\t\treturn $p;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n    * returns the time in ODBC canonical form with microseconds\r\n    *\r\n    * @return string The time in ODBC canonical form with microseconds\r\n    * @access public\r\n    */\r\n\tfunction getmicrotime() {\r\n\t\tif (function_exists('gettimeofday')) {\r\n\t\t\t$tod = gettimeofday();\r\n\t\t\t$sec = $tod['sec'];\r\n\t\t\t$usec = $tod['usec'];\r\n\t\t} else {\r\n\t\t\t$sec = time();\r\n\t\t\t$usec = 0;\r\n\t\t}\r\n\t\treturn strftime('%Y-%m-%d %H:%M:%S', $sec) . '.' . sprintf('%06d', $usec);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a string with the output of var_dump\r\n\t *\r\n\t * @param mixed $data The variable to var_dump\r\n\t * @return string The output of var_dump\r\n\t * @access public\r\n\t */\r\n    function varDump($data) {\r\n\t\tob_start();\r\n\t\tvar_dump($data);\r\n\t\t$ret_val = ob_get_contents();\r\n\t\tob_end_clean();\r\n\t\treturn $ret_val;\r\n\t}\r\n\r\n\t/**\r\n\t* represents the object as a string\r\n\t*\r\n\t* @return\tstring\r\n\t* @access   public\r\n\t*/\r\n\tfunction __toString() {\r\n\t\treturn $this->varDump($this);\r\n\t}\r\n}\r\n\r\n// XML Schema Datatype Helper Functions\r\n\r\n//xsd:dateTime helpers\r\n\r\n/**\r\n* convert unix timestamp to ISO 8601 compliant date string\r\n*\r\n* @param    string $timestamp Unix time stamp\r\n* @param\tboolean $utc Whether the time stamp is UTC or local\r\n* @access   public\r\n*/\r\nfunction timestamp_to_iso8601($timestamp,$utc=true){\r\n\t$datestr = date('Y-m-d\\TH:i:sO',$timestamp);\r\n\tif($utc){\r\n\t\t$eregStr =\r\n\t\t'([0-9]{4})-'.\t// centuries & years CCYY-\r\n\t\t'([0-9]{2})-'.\t// months MM-\r\n\t\t'([0-9]{2})'.\t// days DD\r\n\t\t'T'.\t\t\t// separator T\r\n\t\t'([0-9]{2}):'.\t// hours hh:\r\n\t\t'([0-9]{2}):'.\t// minutes mm:\r\n\t\t'([0-9]{2})(\\.[0-9]*)?'. // seconds ss.ss...\r\n\t\t'(Z|[+\\-][0-9]{2}:?[0-9]{2})?'; // Z to indicate UTC, -/+HH:MM:SS.SS... for local tz's\r\n\r\n\t\tif(ereg($eregStr,$datestr,$regs)){\r\n\t\t\treturn sprintf('%04d-%02d-%02dT%02d:%02d:%02dZ',$regs[1],$regs[2],$regs[3],$regs[4],$regs[5],$regs[6]);\r\n\t\t}\r\n\t\treturn false;\r\n\t} else {\r\n\t\treturn $datestr;\r\n\t}\r\n}\r\n\r\n/**\r\n* convert ISO 8601 compliant date string to unix timestamp\r\n*\r\n* @param    string $datestr ISO 8601 compliant date string\r\n* @access   public\r\n*/\r\nfunction iso8601_to_timestamp($datestr){\r\n\t$eregStr =\r\n\t'([0-9]{4})-'.\t// centuries & years CCYY-\r\n\t'([0-9]{2})-'.\t// months MM-\r\n\t'([0-9]{2})'.\t// days DD\r\n\t'T'.\t\t\t// separator T\r\n\t'([0-9]{2}):'.\t// hours hh:\r\n\t'([0-9]{2}):'.\t// minutes mm:\r\n\t'([0-9]{2})(\\.[0-9]+)?'. // seconds ss.ss...\r\n\t'(Z|[+\\-][0-9]{2}:?[0-9]{2})?'; // Z to indicate UTC, -/+HH:MM:SS.SS... for local tz's\r\n\tif(ereg($eregStr,$datestr,$regs)){\r\n\t\t// not utc\r\n\t\tif($regs[8] != 'Z'){\r\n\t\t\t$op = substr($regs[8],0,1);\r\n\t\t\t$h = substr($regs[8],1,2);\r\n\t\t\t$m = substr($regs[8],strlen($regs[8])-2,2);\r\n\t\t\tif($op == '-'){\r\n\t\t\t\t$regs[4] = $regs[4] + $h;\r\n\t\t\t\t$regs[5] = $regs[5] + $m;\r\n\t\t\t} elseif($op == '+'){\r\n\t\t\t\t$regs[4] = $regs[4] - $h;\r\n\t\t\t\t$regs[5] = $regs[5] - $m;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn gmmktime($regs[4], $regs[5], $regs[6], $regs[2], $regs[3], $regs[1]);\r\n//\t\treturn strtotime(\"$regs[1]-$regs[2]-$regs[3] $regs[4]:$regs[5]:$regs[6]Z\");\r\n\t} else {\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n/**\r\n* sleeps some number of microseconds\r\n*\r\n* @param    string $usec the number of microseconds to sleep\r\n* @access   public\r\n* @deprecated\r\n*/\r\nfunction usleepWindows($usec)\r\n{\r\n\t$start = gettimeofday();\r\n\t\r\n\tdo\r\n\t{\r\n\t\t$stop = gettimeofday();\r\n\t\t$timePassed = 1000000 * ($stop['sec'] - $start['sec'])\r\n\t\t+ $stop['usec'] - $start['usec'];\r\n\t}\r\n\twhile ($timePassed < $usec);\r\n}\r\n\r\n?><?php\r\n\r\n\r\n\r\n/**\r\n* Contains information for a SOAP fault.\r\n* Mainly used for returning faults from deployed functions\r\n* in a server instance.\r\n* @author   Dietrich Ayala <dietrich@ganx4.com>\r\n* @version  $Id: nusoap.php,v 1.114 2007/11/06 15:17:46 snichol Exp $\r\n* @access public\r\n*/\r\nclass nusoap_fault extends nusoap_base {\r\n\t/**\r\n\t * The fault code (client|server)\r\n\t * @var string\r\n\t * @access private\r\n\t */\r\n\tvar $faultcode;\r\n\t/**\r\n\t * The fault actor\r\n\t * @var string\r\n\t * @access private\r\n\t */\r\n\tvar $faultactor;\r\n\t/**\r\n\t * The fault string, a description of the fault\r\n\t * @var string\r\n\t * @access private\r\n\t */\r\n\tvar $faultstring;\r\n\t/**\r\n\t * The fault detail, typically a string or array of string\r\n\t * @var mixed\r\n\t * @access private\r\n\t */\r\n\tvar $faultdetail;\r\n\r\n\t/**\r\n\t* constructor\r\n    *\r\n    * @param string $faultcode (SOAP-ENV:Client | SOAP-ENV:Server)\r\n    * @param string $faultactor only used when msg routed between multiple actors\r\n    * @param string $faultstring human readable error message\r\n    * @param mixed $faultdetail detail, typically a string or array of string\r\n\t*/\r\n\tfunction nusoap_fault($faultcode,$faultactor='',$faultstring='',$faultdetail=''){\r\n\t\tparent::nusoap_base();\r\n\t\t$this->faultcode = $faultcode;\r\n\t\t$this->faultactor = $faultactor;\r\n\t\t$this->faultstring = $faultstring;\r\n\t\t$this->faultdetail = $faultdetail;\r\n\t}\r\n\r\n\t/**\r\n\t* serialize a fault\r\n\t*\r\n\t* @return\tstring\tThe serialization of the fault instance.\r\n\t* @access   public\r\n\t*/\r\n\tfunction serialize(){\r\n\t\t$ns_string = '';\r\n\t\tforeach($this->namespaces as $k => $v){\r\n\t\t\t$ns_string .= \"\\n  xmlns:$k=\\\"$v\\\"\";\r\n\t\t}\r\n\t\t$return_msg =\r\n\t\t\t'<?xml version=\"1.0\" encoding=\"'.$this->soap_defencoding.'\"?>'.\r\n\t\t\t'<SOAP-ENV:Envelope SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"'.$ns_string.\">\\n\".\r\n\t\t\t\t'<SOAP-ENV:Body>'.\r\n\t\t\t\t'<SOAP-ENV:Fault>'.\r\n\t\t\t\t\t$this->serialize_val($this->faultcode, 'faultcode').\r\n\t\t\t\t\t$this->serialize_val($this->faultactor, 'faultactor').\r\n\t\t\t\t\t$this->serialize_val($this->faultstring, 'faultstring').\r\n\t\t\t\t\t$this->serialize_val($this->faultdetail, 'detail').\r\n\t\t\t\t'</SOAP-ENV:Fault>'.\r\n\t\t\t\t'</SOAP-ENV:Body>'.\r\n\t\t\t'</SOAP-ENV:Envelope>';\r\n\t\treturn $return_msg;\r\n\t}\r\n}\r\n\r\n/**\r\n * Backward compatibility\r\n */\r\nclass soap_fault extends nusoap_fault {\r\n}\r\n\r\n?><?php\r\n\r\n\r\n\r\n/**\r\n* parses an XML Schema, allows access to it's data, other utility methods.\r\n* imperfect, no validation... yet, but quite functional.\r\n*\r\n* @author   Dietrich Ayala <dietrich@ganx4.com>\r\n* @author   Scott Nichol <snichol@users.sourceforge.net>\r\n* @version  $Id: nusoap.php,v 1.114 2007/11/06 15:17:46 snichol Exp $\r\n* @access   public\r\n*/\r\nclass nusoap_xmlschema extends nusoap_base  {\r\n\t\r\n\t// files\r\n\tvar $schema = '';\r\n\tvar $xml = '';\r\n\t// namespaces\r\n\tvar $enclosingNamespaces;\r\n\t// schema info\r\n\tvar $schemaInfo = array();\r\n\tvar $schemaTargetNamespace = '';\r\n\t// types, elements, attributes defined by the schema\r\n\tvar $attributes = array();\r\n\tvar $complexTypes = array();\r\n\tvar $complexTypeStack = array();\r\n\tvar $currentComplexType = null;\r\n\tvar $elements = array();\r\n\tvar $elementStack = array();\r\n\tvar $currentElement = null;\r\n\tvar $simpleTypes = array();\r\n\tvar $simpleTypeStack = array();\r\n\tvar $currentSimpleType = null;\r\n\t// imports\r\n\tvar $imports = array();\r\n\t// parser vars\r\n\tvar $parser;\r\n\tvar $position = 0;\r\n\tvar $depth = 0;\r\n\tvar $depth_array = array();\r\n\tvar $message = array();\r\n\tvar $defaultNamespace = array();\r\n    \r\n\t/**\r\n\t* constructor\r\n\t*\r\n\t* @param    string $schema schema document URI\r\n\t* @param    string $xml xml document URI\r\n\t* @param\tstring $namespaces namespaces defined in enclosing XML\r\n\t* @access   public\r\n\t*/\r\n\tfunction nusoap_xmlschema($schema='',$xml='',$namespaces=array()){\r\n\t\tparent::nusoap_base();\r\n\t\t$this->debug('nusoap_xmlschema class instantiated, inside constructor');\r\n\t\t// files\r\n\t\t$this->schema = $schema;\r\n\t\t$this->xml = $xml;\r\n\r\n\t\t// namespaces\r\n\t\t$this->enclosingNamespaces = $namespaces;\r\n\t\t$this->namespaces = array_merge($this->namespaces, $namespaces);\r\n\r\n\t\t// parse schema file\r\n\t\tif($schema != ''){\r\n\t\t\t$this->debug('initial schema file: '.$schema);\r\n\t\t\t$this->parseFile($schema, 'schema');\r\n\t\t}\r\n\r\n\t\t// parse xml file\r\n\t\tif($xml != ''){\r\n\t\t\t$this->debug('initial xml file: '.$xml);\r\n\t\t\t$this->parseFile($xml, 'xml');\r\n\t\t}\r\n\r\n\t}\r\n\r\n    /**\r\n    * parse an XML file\r\n    *\r\n    * @param string $xml path/URL to XML file\r\n    * @param string $type (schema | xml)\r\n\t* @return boolean\r\n    * @access public\r\n    */\r\n\tfunction parseFile($xml,$type){\r\n\t\t// parse xml file\r\n\t\tif($xml != \"\"){\r\n\t\t\t$xmlStr = @join(\"\",@file($xml));\r\n\t\t\tif($xmlStr == \"\"){\r\n\t\t\t\t$msg = 'Error reading XML from '.$xml;\r\n\t\t\t\t$this->setError($msg);\r\n\t\t\t\t$this->debug($msg);\r\n\t\t\treturn false;\r\n\t\t\t} else {\r\n\t\t\t\t$this->debug(\"parsing $xml\");\r\n\t\t\t\t$this->parseString($xmlStr,$type);\r\n\t\t\t\t$this->debug(\"done parsing $xml\");\r\n\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t* parse an XML string\r\n\t*\r\n\t* @param    string $xml path or URL\r\n    * @param\tstring $type (schema|xml)\r\n\t* @access   private\r\n\t*/\r\n\tfunction parseString($xml,$type){\r\n\t\t// parse xml string\r\n\t\tif($xml != \"\"){\r\n\r\n\t    \t// Create an XML parser.\r\n\t    \t$this->parser = xml_parser_create();\r\n\t    \t// Set the options for parsing the XML data.\r\n\t    \txml_parser_set_option($this->parser, XML_OPTION_CASE_FOLDING, 0);\r\n\r\n\t    \t// Set the object for the parser.\r\n\t    \txml_set_object($this->parser, $this);\r\n\r\n\t    \t// Set the element handlers for the parser.\r\n\t\t\tif($type == \"schema\"){\r\n\t\t    \txml_set_element_handler($this->parser, 'schemaStartElement','schemaEndElement');\r\n\t\t    \txml_set_character_data_handler($this->parser,'schemaCharacterData');\r\n\t\t\t} elseif($type == \"xml\"){\r\n\t\t\t\txml_set_element_handler($this->parser, 'xmlStartElement','xmlEndElement');\r\n\t\t    \txml_set_character_data_handler($this->parser,'xmlCharacterData');\r\n\t\t\t}\r\n\r\n\t\t    // Parse the XML file.\r\n\t\t    if(!xml_parse($this->parser,$xml,true)){\r\n\t\t\t// Display an error message.\r\n\t\t\t\t$errstr = sprintf('XML error parsing XML schema on line %d: %s',\r\n\t\t\t\txml_get_current_line_number($this->parser),\r\n\t\t\t\txml_error_string(xml_get_error_code($this->parser))\r\n\t\t\t\t);\r\n\t\t\t\t$this->debug($errstr);\r\n\t\t\t\t$this->debug(\"XML payload:\\n\" . $xml);\r\n\t\t\t\t$this->setError($errstr);\r\n\t    \t}\r\n            \r\n\t\t\txml_parser_free($this->parser);\r\n\t\t} else{\r\n\t\t\t$this->debug('no xml passed to parseString()!!');\r\n\t\t\t$this->setError('no xml passed to parseString()!!');\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * gets a type name for an unnamed type\r\n\t *\r\n\t * @param\tstring\tElement name\r\n\t * @return\tstring\tA type name for an unnamed type\r\n\t * @access\tprivate\r\n\t */\r\n\tfunction CreateTypeName($ename) {\r\n\t\t$scope = '';\r\n\t\tfor ($i = 0; $i < count($this->complexTypeStack); $i++) {\r\n\t\t\t$scope .= $this->complexTypeStack[$i] . '_';\r\n\t\t}\r\n\t\treturn $scope . $ename . '_ContainedType';\r\n\t}\r\n\t\r\n\t/**\r\n\t* start-element handler\r\n\t*\r\n\t* @param    string $parser XML parser object\r\n\t* @param    string $name element name\r\n\t* @param    string $attrs associative array of attributes\r\n\t* @access   private\r\n\t*/\r\n\tfunction schemaStartElement($parser, $name, $attrs) {\r\n\t\t\r\n\t\t// position in the total number of elements, starting from 0\r\n\t\t$pos = $this->position++;\r\n\t\t$depth = $this->depth++;\r\n\t\t// set self as current value for this depth\r\n\t\t$this->depth_array[$depth] = $pos;\r\n\t\t$this->message[$pos] = array('cdata' => ''); \r\n\t\tif ($depth > 0) {\r\n\t\t\t$this->defaultNamespace[$pos] = $this->defaultNamespace[$this->depth_array[$depth - 1]];\r\n\t\t} else {\r\n\t\t\t$this->defaultNamespace[$pos] = false;\r\n\t\t}\r\n\r\n\t\t// get element prefix\r\n\t\tif($prefix = $this->getPrefix($name)){\r\n\t\t\t// get unqualified name\r\n\t\t\t$name = $this->getLocalPart($name);\r\n\t\t} else {\r\n        \t$prefix = '';\r\n        }\r\n\t\t\r\n        // loop thru attributes, expanding, and registering namespace declarations\r\n        if(count($attrs) > 0){\r\n        \tforeach($attrs as $k => $v){\r\n                // if ns declarations, add to class level array of valid namespaces\r\n\t\t\t\tif(ereg(\"^xmlns\",$k)){\r\n                \t//$this->xdebug(\"$k: $v\");\r\n                \t//$this->xdebug('ns_prefix: '.$this->getPrefix($k));\r\n                \tif($ns_prefix = substr(strrchr($k,':'),1)){\r\n                \t\t//$this->xdebug(\"Add namespace[$ns_prefix] = $v\");\r\n\t\t\t\t\t\t$this->namespaces[$ns_prefix] = $v;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$this->defaultNamespace[$pos] = $v;\r\n\t\t\t\t\t\tif (! $this->getPrefixFromNamespace($v)) {\r\n\t\t\t\t\t\t\t$this->namespaces['ns'.(count($this->namespaces)+1)] = $v;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif($v == 'http://www.w3.org/2001/XMLSchema' || $v == 'http://www.w3.org/1999/XMLSchema' || $v == 'http://www.w3.org/2000/10/XMLSchema'){\r\n\t\t\t\t\t\t$this->XMLSchemaVersion = $v;\r\n\t\t\t\t\t\t$this->namespaces['xsi'] = $v.'-instance';\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n        \t}\r\n        \tforeach($attrs as $k => $v){\r\n                // expand each attribute\r\n                $k = strpos($k,':') ? $this->expandQname($k) : $k;\r\n                $v = strpos($v,':') ? $this->expandQname($v) : $v;\r\n        \t\t$eAttrs[$k] = $v;\r\n        \t}\r\n        \t$attrs = $eAttrs;\r\n        } else {\r\n        \t$attrs = array();\r\n        }\r\n\t\t// find status, register data\r\n\t\tswitch($name){\r\n\t\t\tcase 'all':\t\t\t// (optional) compositor content for a complexType\r\n\t\t\tcase 'choice':\r\n\t\t\tcase 'group':\r\n\t\t\tcase 'sequence':\r\n\t\t\t\t//$this->xdebug(\"compositor $name for currentComplexType: $this->currentComplexType and currentElement: $this->currentElement\");\r\n\t\t\t\t$this->complexTypes[$this->currentComplexType]['compositor'] = $name;\r\n\t\t\t\t//if($name == 'all' || $name == 'sequence'){\r\n\t\t\t\t//\t$this->complexTypes[$this->currentComplexType]['phpType'] = 'struct';\r\n\t\t\t\t//}\r\n\t\t\tbreak;\r\n\t\t\tcase 'attribute':\t// complexType attribute\r\n            \t//$this->xdebug(\"parsing attribute $attrs[name] $attrs[ref] of value: \".$attrs['http://schemas.xmlsoap.org/wsdl/:arrayType']);\r\n            \t$this->xdebug(\"parsing attribute:\");\r\n            \t$this->appendDebug($this->varDump($attrs));\r\n\t\t\t\tif (!isset($attrs['form'])) {\r\n\t\t\t\t\t$attrs['form'] = $this->schemaInfo['attributeFormDefault'];\r\n\t\t\t\t}\r\n            \tif (isset($attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'])) {\r\n\t\t\t\t\t$v = $attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'];\r\n\t\t\t\t\tif (!strpos($v, ':')) {\r\n\t\t\t\t\t\t// no namespace in arrayType attribute value...\r\n\t\t\t\t\t\tif ($this->defaultNamespace[$pos]) {\r\n\t\t\t\t\t\t\t// ...so use the default\r\n\t\t\t\t\t\t\t$attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'] = $this->defaultNamespace[$pos] . ':' . $attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n            \t}\r\n                if(isset($attrs['name'])){\r\n\t\t\t\t\t$this->attributes[$attrs['name']] = $attrs;\r\n\t\t\t\t\t$aname = $attrs['name'];\r\n\t\t\t\t} elseif(isset($attrs['ref']) && $attrs['ref'] == 'http://schemas.xmlsoap.org/soap/encoding/:arrayType'){\r\n\t\t\t\t\tif (isset($attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'])) {\r\n\t                \t$aname = $attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'];\r\n\t                } else {\r\n\t                \t$aname = '';\r\n\t                }\r\n\t\t\t\t} elseif(isset($attrs['ref'])){\r\n\t\t\t\t\t$aname = $attrs['ref'];\r\n                    $this->attributes[$attrs['ref']] = $attrs;\r\n\t\t\t\t}\r\n                \r\n\t\t\t\tif($this->currentComplexType){\t// This should *always* be\r\n\t\t\t\t\t$this->complexTypes[$this->currentComplexType]['attrs'][$aname] = $attrs;\r\n\t\t\t\t}\r\n\t\t\t\t// arrayType attribute\r\n\t\t\t\tif(isset($attrs['http://schemas.xmlsoap.org/wsdl/:arrayType']) || $this->getLocalPart($aname) == 'arrayType'){\r\n\t\t\t\t\t$this->complexTypes[$this->currentComplexType]['phpType'] = 'array';\r\n                \t$prefix = $this->getPrefix($aname);\r\n\t\t\t\t\tif(isset($attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'])){\r\n\t\t\t\t\t\t$v = $attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$v = '';\r\n\t\t\t\t\t}\r\n                    if(strpos($v,'[,]')){\r\n                        $this->complexTypes[$this->currentComplexType]['multidimensional'] = true;\r\n                    }\r\n                    $v = substr($v,0,strpos($v,'[')); // clip the []\r\n                    if(!strpos($v,':') && isset($this->typemap[$this->XMLSchemaVersion][$v])){\r\n                        $v = $this->XMLSchemaVersion.':'.$v;\r\n                    }\r\n                    $this->complexTypes[$this->currentComplexType]['arrayType'] = $v;\r\n\t\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\tcase 'complexContent':\t// (optional) content for a complexType\r\n\t\t\tbreak;\r\n\t\t\tcase 'complexType':\r\n\t\t\t\tarray_push($this->complexTypeStack, $this->currentComplexType);\r\n\t\t\t\tif(isset($attrs['name'])){\r\n\t\t\t\t\t// TODO: what is the scope of named complexTypes that appear\r\n\t\t\t\t\t//       nested within other c complexTypes?\r\n\t\t\t\t\t$this->xdebug('processing named complexType '.$attrs['name']);\r\n\t\t\t\t\t//$this->currentElement = false;\r\n\t\t\t\t\t$this->currentComplexType = $attrs['name'];\r\n\t\t\t\t\t$this->complexTypes[$this->currentComplexType] = $attrs;\r\n\t\t\t\t\t$this->complexTypes[$this->currentComplexType]['typeClass'] = 'complexType';\r\n\t\t\t\t\t// This is for constructs like\r\n\t\t\t\t\t//           <complexType name=\"ListOfString\" base=\"soap:Array\">\r\n\t\t\t\t\t//                <sequence>\r\n\t\t\t\t\t//                    <element name=\"string\" type=\"xsd:string\"\r\n\t\t\t\t\t//                        minOccurs=\"0\" maxOccurs=\"unbounded\" />\r\n\t\t\t\t\t//                </sequence>\r\n\t\t\t\t\t//            </complexType>\r\n\t\t\t\t\tif(isset($attrs['base']) && ereg(':Array$',$attrs['base'])){\r\n\t\t\t\t\t\t$this->xdebug('complexType is unusual array');\r\n\t\t\t\t\t\t$this->complexTypes[$this->currentComplexType]['phpType'] = 'array';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$this->complexTypes[$this->currentComplexType]['phpType'] = 'struct';\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$name = $this->CreateTypeName($this->currentElement);\r\n\t\t\t\t\t$this->xdebug('processing unnamed complexType for element ' . $this->currentElement . ' named ' . $name);\r\n\t\t\t\t\t$this->currentComplexType = $name;\r\n\t\t\t\t\t//$this->currentElement = false;\r\n\t\t\t\t\t$this->complexTypes[$this->currentComplexType] = $attrs;\r\n\t\t\t\t\t$this->complexTypes[$this->currentComplexType]['typeClass'] = 'complexType';\r\n\t\t\t\t\t// This is for constructs like\r\n\t\t\t\t\t//           <complexType name=\"ListOfString\" base=\"soap:Array\">\r\n\t\t\t\t\t//                <sequence>\r\n\t\t\t\t\t//                    <element name=\"string\" type=\"xsd:string\"\r\n\t\t\t\t\t//                        minOccurs=\"0\" maxOccurs=\"unbounded\" />\r\n\t\t\t\t\t//                </sequence>\r\n\t\t\t\t\t//            </complexType>\r\n\t\t\t\t\tif(isset($attrs['base']) && ereg(':Array$',$attrs['base'])){\r\n\t\t\t\t\t\t$this->xdebug('complexType is unusual array');\r\n\t\t\t\t\t\t$this->complexTypes[$this->currentComplexType]['phpType'] = 'array';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$this->complexTypes[$this->currentComplexType]['phpType'] = 'struct';\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\tcase 'element':\r\n\t\t\t\tarray_push($this->elementStack, $this->currentElement);\r\n\t\t\t\tif (!isset($attrs['form'])) {\r\n\t\t\t\t\t$attrs['form'] = $this->schemaInfo['elementFormDefault'];\r\n\t\t\t\t}\r\n\t\t\t\tif(isset($attrs['type'])){\r\n\t\t\t\t\t$this->xdebug(\"processing typed element \".$attrs['name'].\" of type \".$attrs['type']);\r\n\t\t\t\t\tif (! $this->getPrefix($attrs['type'])) {\r\n\t\t\t\t\t\tif ($this->defaultNamespace[$pos]) {\r\n\t\t\t\t\t\t\t$attrs['type'] = $this->defaultNamespace[$pos] . ':' . $attrs['type'];\r\n\t\t\t\t\t\t\t$this->xdebug('used default namespace to make type ' . $attrs['type']);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// This is for constructs like\r\n\t\t\t\t\t//           <complexType name=\"ListOfString\" base=\"soap:Array\">\r\n\t\t\t\t\t//                <sequence>\r\n\t\t\t\t\t//                    <element name=\"string\" type=\"xsd:string\"\r\n\t\t\t\t\t//                        minOccurs=\"0\" maxOccurs=\"unbounded\" />\r\n\t\t\t\t\t//                </sequence>\r\n\t\t\t\t\t//            </complexType>\r\n\t\t\t\t\tif ($this->currentComplexType && $this->complexTypes[$this->currentComplexType]['phpType'] == 'array') {\r\n\t\t\t\t\t\t$this->xdebug('arrayType for unusual array is ' . $attrs['type']);\r\n\t\t\t\t\t\t$this->complexTypes[$this->currentComplexType]['arrayType'] = $attrs['type'];\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$this->currentElement = $attrs['name'];\r\n\t\t\t\t\t$ename = $attrs['name'];\r\n\t\t\t\t} elseif(isset($attrs['ref'])){\r\n\t\t\t\t\t$this->xdebug(\"processing element as ref to \".$attrs['ref']);\r\n\t\t\t\t\t$this->currentElement = \"ref to \".$attrs['ref'];\r\n\t\t\t\t\t$ename = $this->getLocalPart($attrs['ref']);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$type = $this->CreateTypeName($this->currentComplexType . '_' . $attrs['name']);\r\n\t\t\t\t\t$this->xdebug(\"processing untyped element \" . $attrs['name'] . ' type ' . $type);\r\n\t\t\t\t\t$this->currentElement = $attrs['name'];\r\n\t\t\t\t\t$attrs['type'] = $this->schemaTargetNamespace . ':' . $type;\r\n\t\t\t\t\t$ename = $attrs['name'];\r\n\t\t\t\t}\r\n\t\t\t\tif (isset($ename) && $this->currentComplexType) {\r\n\t\t\t\t\t$this->xdebug(\"add element $ename to complexType $this->currentComplexType\");\r\n\t\t\t\t\t$this->complexTypes[$this->currentComplexType]['elements'][$ename] = $attrs;\r\n\t\t\t\t} elseif (!isset($attrs['ref'])) {\r\n\t\t\t\t\t$this->xdebug(\"add element $ename to elements array\");\r\n\t\t\t\t\t$this->elements[ $attrs['name'] ] = $attrs;\r\n\t\t\t\t\t$this->elements[ $attrs['name'] ]['typeClass'] = 'element';\r\n\t\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\tcase 'enumeration':\t//\trestriction value list member\r\n\t\t\t\t$this->xdebug('enumeration ' . $attrs['value']);\r\n\t\t\t\tif ($this->currentSimpleType) {\r\n\t\t\t\t\t$this->simpleTypes[$this->currentSimpleType]['enumeration'][] = $attrs['value'];\r\n\t\t\t\t} elseif ($this->currentComplexType) {\r\n\t\t\t\t\t$this->complexTypes[$this->currentComplexType]['enumeration'][] = $attrs['value'];\r\n\t\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\tcase 'extension':\t// simpleContent or complexContent type extension\r\n\t\t\t\t$this->xdebug('extension ' . $attrs['base']);\r\n\t\t\t\tif ($this->currentComplexType) {\r\n\t\t\t\t\t$this->complexTypes[$this->currentComplexType]['extensionBase'] = $attrs['base'];\r\n\t\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\tcase 'import':\r\n\t\t\t    if (isset($attrs['schemaLocation'])) {\r\n\t\t\t\t\t//$this->xdebug('import namespace ' . $attrs['namespace'] . ' from ' . $attrs['schemaLocation']);\r\n                    $this->imports[$attrs['namespace']][] = array('location' => $attrs['schemaLocation'], 'loaded' => false);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t//$this->xdebug('import namespace ' . $attrs['namespace']);\r\n                    $this->imports[$attrs['namespace']][] = array('location' => '', 'loaded' => true);\r\n\t\t\t\t\tif (! $this->getPrefixFromNamespace($attrs['namespace'])) {\r\n\t\t\t\t\t\t$this->namespaces['ns'.(count($this->namespaces)+1)] = $attrs['namespace'];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\tcase 'list':\t// simpleType value list\r\n\t\t\tbreak;\r\n\t\t\tcase 'restriction':\t// simpleType, simpleContent or complexContent value restriction\r\n\t\t\t\t$this->xdebug('restriction ' . $attrs['base']);\r\n\t\t\t\tif($this->currentSimpleType){\r\n\t\t\t\t\t$this->simpleTypes[$this->currentSimpleType]['type'] = $attrs['base'];\r\n\t\t\t\t} elseif($this->currentComplexType){\r\n\t\t\t\t\t$this->complexTypes[$this->currentComplexType]['restrictionBase'] = $attrs['base'];\r\n\t\t\t\t\tif(strstr($attrs['base'],':') == ':Array'){\r\n\t\t\t\t\t\t$this->complexTypes[$this->currentComplexType]['phpType'] = 'array';\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\tcase 'schema':\r\n\t\t\t\t$this->schemaInfo = $attrs;\r\n\t\t\t\t$this->schemaInfo['schemaVersion'] = $this->getNamespaceFromPrefix($prefix);\r\n\t\t\t\tif (isset($attrs['targetNamespace'])) {\r\n\t\t\t\t\t$this->schemaTargetNamespace = $attrs['targetNamespace'];\r\n\t\t\t\t}\r\n\t\t\t\tif (!isset($attrs['elementFormDefault'])) {\r\n\t\t\t\t\t$this->schemaInfo['elementFormDefault'] = 'unqualified';\r\n\t\t\t\t}\r\n\t\t\t\tif (!isset($attrs['attributeFormDefault'])) {\r\n\t\t\t\t\t$this->schemaInfo['attributeFormDefault'] = 'unqualified';\r\n\t\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\tcase 'simpleContent':\t// (optional) content for a complexType\r\n\t\t\tbreak;\r\n\t\t\tcase 'simpleType':\r\n\t\t\t\tarray_push($this->simpleTypeStack, $this->currentSimpleType);\r\n\t\t\t\tif(isset($attrs['name'])){\r\n\t\t\t\t\t$this->xdebug(\"processing simpleType for name \" . $attrs['name']);\r\n\t\t\t\t\t$this->currentSimpleType = $attrs['name'];\r\n\t\t\t\t\t$this->simpleTypes[ $attrs['name'] ] = $attrs;\r\n\t\t\t\t\t$this->simpleTypes[ $attrs['name'] ]['typeClass'] = 'simpleType';\r\n\t\t\t\t\t$this->simpleTypes[ $attrs['name'] ]['phpType'] = 'scalar';\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$name = $this->CreateTypeName($this->currentComplexType . '_' . $this->currentElement);\r\n\t\t\t\t\t$this->xdebug('processing unnamed simpleType for element ' . $this->currentElement . ' named ' . $name);\r\n\t\t\t\t\t$this->currentSimpleType = $name;\r\n\t\t\t\t\t//$this->currentElement = false;\r\n\t\t\t\t\t$this->simpleTypes[$this->currentSimpleType] = $attrs;\r\n\t\t\t\t\t$this->simpleTypes[$this->currentSimpleType]['phpType'] = 'scalar';\r\n\t\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\tcase 'union':\t// simpleType type list\r\n\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\t//$this->xdebug(\"do not have anything to do for element $name\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* end-element handler\r\n\t*\r\n\t* @param    string $parser XML parser object\r\n\t* @param    string $name element name\r\n\t* @access   private\r\n\t*/\r\n\tfunction schemaEndElement($parser, $name) {\r\n\t\t// bring depth down a notch\r\n\t\t$this->depth--;\r\n\t\t// position of current element is equal to the last value left in depth_array for my depth\r\n\t\tif(isset($this->depth_array[$this->depth])){\r\n        \t$pos = $this->depth_array[$this->depth];\r\n        }\r\n\t\t// get element prefix\r\n\t\tif ($prefix = $this->getPrefix($name)){\r\n\t\t\t// get unqualified name\r\n\t\t\t$name = $this->getLocalPart($name);\r\n\t\t} else {\r\n        \t$prefix = '';\r\n        }\r\n\t\t// move on...\r\n\t\tif($name == 'complexType'){\r\n\t\t\t$this->xdebug('done processing complexType ' . ($this->currentComplexType ? $this->currentComplexType : '(unknown)'));\r\n\t\t\t$this->currentComplexType = array_pop($this->complexTypeStack);\r\n\t\t\t//$this->currentElement = false;\r\n\t\t}\r\n\t\tif($name == 'element'){\r\n\t\t\t$this->xdebug('done processing element ' . ($this->currentElement ? $this->currentElement : '(unknown)'));\r\n\t\t\t$this->currentElement = array_pop($this->elementStack);\r\n\t\t}\r\n\t\tif($name == 'simpleType'){\r\n\t\t\t$this->xdebug('done processing simpleType ' . ($this->currentSimpleType ? $this->currentSimpleType : '(unknown)'));\r\n\t\t\t$this->currentSimpleType = array_pop($this->simpleTypeStack);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* element content handler\r\n\t*\r\n\t* @param    string $parser XML parser object\r\n\t* @param    string $data element content\r\n\t* @access   private\r\n\t*/\r\n\tfunction schemaCharacterData($parser, $data){\r\n\t\t$pos = $this->depth_array[$this->depth - 1];\r\n\t\t$this->message[$pos]['cdata'] .= $data;\r\n\t}\r\n\r\n\t/**\r\n\t* serialize the schema\r\n\t*\r\n\t* @access   public\r\n\t*/\r\n\tfunction serializeSchema(){\r\n\r\n\t\t$schemaPrefix = $this->getPrefixFromNamespace($this->XMLSchemaVersion);\r\n\t\t$xml = '';\r\n\t\t// imports\r\n\t\tif (sizeof($this->imports) > 0) {\r\n\t\t\tforeach($this->imports as $ns => $list) {\r\n\t\t\t\tforeach ($list as $ii) {\r\n\t\t\t\t\tif ($ii['location'] != '') {\r\n\t\t\t\t\t\t$xml .= \" <$schemaPrefix:import location=\\\"\" . $ii['location'] . '\" namespace=\"' . $ns . \"\\\" />\\n\";\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$xml .= \" <$schemaPrefix:import namespace=\\\"\" . $ns . \"\\\" />\\n\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} \r\n\t\t} \r\n\t\t// complex types\r\n\t\tforeach($this->complexTypes as $typeName => $attrs){\r\n\t\t\t$contentStr = '';\r\n\t\t\t// serialize child elements\r\n\t\t\tif(isset($attrs['elements']) && (count($attrs['elements']) > 0)){\r\n\t\t\t\tforeach($attrs['elements'] as $element => $eParts){\r\n\t\t\t\t\tif(isset($eParts['ref'])){\r\n\t\t\t\t\t\t$contentStr .= \"   <$schemaPrefix:element ref=\\\"$element\\\"/>\\n\";\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$contentStr .= \"   <$schemaPrefix:element name=\\\"$element\\\" type=\\\"\" . $this->contractQName($eParts['type']) . \"\\\"\";\r\n\t\t\t\t\t\tforeach ($eParts as $aName => $aValue) {\r\n\t\t\t\t\t\t\t// handle, e.g., abstract, default, form, minOccurs, maxOccurs, nillable\r\n\t\t\t\t\t\t\tif ($aName != 'name' && $aName != 'type') {\r\n\t\t\t\t\t\t\t\t$contentStr .= \" $aName=\\\"$aValue\\\"\";\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t$contentStr .= \"/>\\n\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// compositor wraps elements\r\n\t\t\t\tif (isset($attrs['compositor']) && ($attrs['compositor'] != '')) {\r\n\t\t\t\t\t$contentStr = \"  <$schemaPrefix:$attrs[compositor]>\\n\".$contentStr.\"  </$schemaPrefix:$attrs[compositor]>\\n\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// attributes\r\n\t\t\tif(isset($attrs['attrs']) && (count($attrs['attrs']) >= 1)){\r\n\t\t\t\tforeach($attrs['attrs'] as $attr => $aParts){\r\n\t\t\t\t\t$contentStr .= \"    <$schemaPrefix:attribute\";\r\n\t\t\t\t\tforeach ($aParts as $a => $v) {\r\n\t\t\t\t\t\tif ($a == 'ref' || $a == 'type') {\r\n\t\t\t\t\t\t\t$contentStr .= \" $a=\\\"\".$this->contractQName($v).'\"';\r\n\t\t\t\t\t\t} elseif ($a == 'http://schemas.xmlsoap.org/wsdl/:arrayType') {\r\n\t\t\t\t\t\t\t$this->usedNamespaces['wsdl'] = $this->namespaces['wsdl'];\r\n\t\t\t\t\t\t\t$contentStr .= ' wsdl:arrayType=\"'.$this->contractQName($v).'\"';\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t$contentStr .= \" $a=\\\"$v\\\"\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$contentStr .= \"/>\\n\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// if restriction\r\n\t\t\tif (isset($attrs['restrictionBase']) && $attrs['restrictionBase'] != ''){\r\n\t\t\t\t$contentStr = \"   <$schemaPrefix:restriction base=\\\"\".$this->contractQName($attrs['restrictionBase']).\"\\\">\\n\".$contentStr.\"   </$schemaPrefix:restriction>\\n\";\r\n\t\t\t\t// complex or simple content\r\n\t\t\t\tif ((isset($attrs['elements']) && count($attrs['elements']) > 0) || (isset($attrs['attrs']) && count($attrs['attrs']) > 0)){\r\n\t\t\t\t\t$contentStr = \"  <$schemaPrefix:complexContent>\\n\".$contentStr.\"  </$schemaPrefix:complexContent>\\n\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// finalize complex type\r\n\t\t\tif($contentStr != ''){\r\n\t\t\t\t$contentStr = \" <$schemaPrefix:complexType name=\\\"$typeName\\\">\\n\".$contentStr.\" </$schemaPrefix:complexType>\\n\";\r\n\t\t\t} else {\r\n\t\t\t\t$contentStr = \" <$schemaPrefix:complexType name=\\\"$typeName\\\"/>\\n\";\r\n\t\t\t}\r\n\t\t\t$xml .= $contentStr;\r\n\t\t}\r\n\t\t// simple types\r\n\t\tif(isset($this->simpleTypes) && count($this->simpleTypes) > 0){\r\n\t\t\tforeach($this->simpleTypes as $typeName => $eParts){\r\n\t\t\t\t$xml .= \" <$schemaPrefix:simpleType name=\\\"$typeName\\\">\\n  <$schemaPrefix:restriction base=\\\"\".$this->contractQName($eParts['type']).\"\\\">\\n\";\r\n\t\t\t\tif (isset($eParts['enumeration'])) {\r\n\t\t\t\t\tforeach ($eParts['enumeration'] as $e) {\r\n\t\t\t\t\t\t$xml .= \"  <$schemaPrefix:enumeration value=\\\"$e\\\"/>\\n\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t$xml .= \"  </$schemaPrefix:restriction>\\n </$schemaPrefix:simpleType>\";\r\n\t\t\t}\r\n\t\t}\r\n\t\t// elements\r\n\t\tif(isset($this->elements) && count($this->elements) > 0){\r\n\t\t\tforeach($this->elements as $element => $eParts){\r\n\t\t\t\t$xml .= \" <$schemaPrefix:element name=\\\"$element\\\" type=\\\"\".$this->contractQName($eParts['type']).\"\\\"/>\\n\";\r\n\t\t\t}\r\n\t\t}\r\n\t\t// attributes\r\n\t\tif(isset($this->attributes) && count($this->attributes) > 0){\r\n\t\t\tforeach($this->attributes as $attr => $aParts){\r\n\t\t\t\t$xml .= \" <$schemaPrefix:attribute name=\\\"$attr\\\" type=\\\"\".$this->contractQName($aParts['type']).\"\\\"\\n/>\";\r\n\t\t\t}\r\n\t\t}\r\n\t\t// finish 'er up\r\n\t\t$attr = '';\r\n\t\tforeach ($this->schemaInfo as $k => $v) {\r\n\t\t\tif ($k == 'elementFormDefault' || $k == 'attributeFormDefault') {\r\n\t\t\t\t$attr .= \" $k=\\\"$v\\\"\";\r\n\t\t\t}\r\n\t\t}\r\n\t\t$el = \"<$schemaPrefix:schema$attr targetNamespace=\\\"$this->schemaTargetNamespace\\\"\\n\";\r\n\t\tforeach (array_diff($this->usedNamespaces, $this->enclosingNamespaces) as $nsp => $ns) {\r\n\t\t\t$el .= \" xmlns:$nsp=\\\"$ns\\\"\";\r\n\t\t}\r\n\t\t$xml = $el . \">\\n\".$xml.\"</$schemaPrefix:schema>\\n\";\r\n\t\treturn $xml;\r\n\t}\r\n\r\n\t/**\r\n\t* adds debug data to the clas level debug string\r\n\t*\r\n\t* @param    string $string debug data\r\n\t* @access   private\r\n\t*/\r\n\tfunction xdebug($string){\r\n\t\t$this->debug('<' . $this->schemaTargetNamespace . '> '.$string);\r\n\t}\r\n\r\n    /**\r\n    * get the PHP type of a user defined type in the schema\r\n    * PHP type is kind of a misnomer since it actually returns 'struct' for assoc. arrays\r\n    * returns false if no type exists, or not w/ the given namespace\r\n    * else returns a string that is either a native php type, or 'struct'\r\n    *\r\n    * @param string $type name of defined type\r\n    * @param string $ns namespace of type\r\n    * @return mixed\r\n    * @access public\r\n    * @deprecated\r\n    */\r\n\tfunction getPHPType($type,$ns){\r\n\t\tif(isset($this->typemap[$ns][$type])){\r\n\t\t\t//print \"found type '$type' and ns $ns in typemap<br>\";\r\n\t\t\treturn $this->typemap[$ns][$type];\r\n\t\t} elseif(isset($this->complexTypes[$type])){\r\n\t\t\t//print \"getting type '$type' and ns $ns from complexTypes array<br>\";\r\n\t\t\treturn $this->complexTypes[$type]['phpType'];\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n    * returns an associative array of information about a given type\r\n    * returns false if no type exists by the given name\r\n    *\r\n\t*\tFor a complexType typeDef = array(\r\n\t*\t'restrictionBase' => '',\r\n\t*\t'phpType' => '',\r\n\t*\t'compositor' => '(sequence|all)',\r\n\t*\t'elements' => array(), // refs to elements array\r\n\t*\t'attrs' => array() // refs to attributes array\r\n\t*\t... and so on (see addComplexType)\r\n\t*\t)\r\n\t*\r\n\t*   For simpleType or element, the array has different keys.\r\n    *\r\n    * @param string $type\r\n    * @return mixed\r\n    * @access public\r\n    * @see addComplexType\r\n    * @see addSimpleType\r\n    * @see addElement\r\n    */\r\n\tfunction getTypeDef($type){\r\n\t\t//$this->debug(\"in getTypeDef for type $type\");\r\n\t\tif (substr($type, -1) == '^') {\r\n\t\t\t$is_element = 1;\r\n\t\t\t$type = substr($type, 0, -1);\r\n\t\t} else {\r\n\t\t\t$is_element = 0;\r\n\t\t}\r\n\r\n\t\tif((! $is_element) && isset($this->complexTypes[$type])){\r\n\t\t\t$this->xdebug(\"in getTypeDef, found complexType $type\");\r\n\t\t\treturn $this->complexTypes[$type];\r\n\t\t} elseif((! $is_element) && isset($this->simpleTypes[$type])){\r\n\t\t\t$this->xdebug(\"in getTypeDef, found simpleType $type\");\r\n\t\t\tif (!isset($this->simpleTypes[$type]['phpType'])) {\r\n\t\t\t\t// get info for type to tack onto the simple type\r\n\t\t\t\t// TODO: can this ever really apply (i.e. what is a simpleType really?)\r\n\t\t\t\t$uqType = substr($this->simpleTypes[$type]['type'], strrpos($this->simpleTypes[$type]['type'], ':') + 1);\r\n\t\t\t\t$ns = substr($this->simpleTypes[$type]['type'], 0, strrpos($this->simpleTypes[$type]['type'], ':'));\r\n\t\t\t\t$etype = $this->getTypeDef($uqType);\r\n\t\t\t\tif ($etype) {\r\n\t\t\t\t\t$this->xdebug(\"in getTypeDef, found type for simpleType $type:\");\r\n\t\t\t\t\t$this->xdebug($this->varDump($etype));\r\n\t\t\t\t\tif (isset($etype['phpType'])) {\r\n\t\t\t\t\t\t$this->simpleTypes[$type]['phpType'] = $etype['phpType'];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (isset($etype['elements'])) {\r\n\t\t\t\t\t\t$this->simpleTypes[$type]['elements'] = $etype['elements'];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn $this->simpleTypes[$type];\r\n\t\t} elseif(isset($this->elements[$type])){\r\n\t\t\t$this->xdebug(\"in getTypeDef, found element $type\");\r\n\t\t\tif (!isset($this->elements[$type]['phpType'])) {\r\n\t\t\t\t// get info for type to tack onto the element\r\n\t\t\t\t$uqType = substr($this->elements[$type]['type'], strrpos($this->elements[$type]['type'], ':') + 1);\r\n\t\t\t\t$ns = substr($this->elements[$type]['type'], 0, strrpos($this->elements[$type]['type'], ':'));\r\n\t\t\t\t$etype = $this->getTypeDef($uqType);\r\n\t\t\t\tif ($etype) {\r\n\t\t\t\t\t$this->xdebug(\"in getTypeDef, found type for element $type:\");\r\n\t\t\t\t\t$this->xdebug($this->varDump($etype));\r\n\t\t\t\t\tif (isset($etype['phpType'])) {\r\n\t\t\t\t\t\t$this->elements[$type]['phpType'] = $etype['phpType'];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (isset($etype['elements'])) {\r\n\t\t\t\t\t\t$this->elements[$type]['elements'] = $etype['elements'];\r\n\t\t\t\t\t}\r\n\t\t\t\t} elseif ($ns == 'http://www.w3.org/2001/XMLSchema') {\r\n\t\t\t\t\t$this->xdebug(\"in getTypeDef, element $type is an XSD type\");\r\n\t\t\t\t\t$this->elements[$type]['phpType'] = 'scalar';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn $this->elements[$type];\r\n\t\t} elseif(isset($this->attributes[$type])){\r\n\t\t\t$this->xdebug(\"in getTypeDef, found attribute $type\");\r\n\t\t\treturn $this->attributes[$type];\r\n\t\t} elseif (ereg('_ContainedType$', $type)) {\r\n\t\t\t$this->xdebug(\"in getTypeDef, have an untyped element $type\");\r\n\t\t\t$typeDef['typeClass'] = 'simpleType';\r\n\t\t\t$typeDef['phpType'] = 'scalar';\r\n\t\t\t$typeDef['type'] = 'http://www.w3.org/2001/XMLSchema:string';\r\n\t\t\treturn $typeDef;\r\n\t\t}\r\n\t\t$this->xdebug(\"in getTypeDef, did not find $type\");\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n    * returns a sample serialization of a given type, or false if no type by the given name\r\n    *\r\n    * @param string $type name of type\r\n    * @return mixed\r\n    * @access public\r\n    * @deprecated\r\n    */\r\n    function serializeTypeDef($type){\r\n    \t//print \"in sTD() for type $type<br>\";\r\n\tif($typeDef = $this->getTypeDef($type)){\r\n\t\t$str .= '<'.$type;\r\n\t    if(is_array($typeDef['attrs'])){\r\n\t\tforeach($typeDef['attrs'] as $attName => $data){\r\n\t\t    $str .= \" $attName=\\\"{type = \".$data['type'].\"}\\\"\";\r\n\t\t}\r\n\t    }\r\n\t    $str .= \" xmlns=\\\"\".$this->schema['targetNamespace'].\"\\\"\";\r\n\t    if(count($typeDef['elements']) > 0){\r\n\t\t$str .= \">\";\r\n\t\tforeach($typeDef['elements'] as $element => $eData){\r\n\t\t    $str .= $this->serializeTypeDef($element);\r\n\t\t}\r\n\t\t$str .= \"</$type>\";\r\n\t    } elseif($typeDef['typeClass'] == 'element') {\r\n\t\t$str .= \"></$type>\";\r\n\t    } else {\r\n\t\t$str .= \"/>\";\r\n\t    }\r\n\t\t\treturn $str;\r\n\t}\r\n    \treturn false;\r\n    }\r\n\r\n    /**\r\n    * returns HTML form elements that allow a user\r\n    * to enter values for creating an instance of the given type.\r\n    *\r\n    * @param string $name name for type instance\r\n    * @param string $type name of type\r\n    * @return string\r\n    * @access public\r\n    * @deprecated\r\n\t*/\r\n\tfunction typeToForm($name,$type){\r\n\t\t// get typedef\r\n\t\tif($typeDef = $this->getTypeDef($type)){\r\n\t\t\t// if struct\r\n\t\t\tif($typeDef['phpType'] == 'struct'){\r\n\t\t\t\t$buffer .= '<table>';\r\n\t\t\t\tforeach($typeDef['elements'] as $child => $childDef){\r\n\t\t\t\t\t$buffer .= \"\r\n\t\t\t\t\t<tr><td align='right'>$childDef[name] (type: \".$this->getLocalPart($childDef['type']).\"):</td>\r\n\t\t\t\t\t<td><input type='text' name='parameters[\".$name.\"][$childDef[name]]'></td></tr>\";\r\n\t\t\t\t}\r\n\t\t\t\t$buffer .= '</table>';\r\n\t\t\t// if array\r\n\t\t\t} elseif($typeDef['phpType'] == 'array'){\r\n\t\t\t\t$buffer .= '<table>';\r\n\t\t\t\tfor($i=0;$i < 3; $i++){\r\n\t\t\t\t\t$buffer .= \"\r\n\t\t\t\t\t<tr><td align='right'>array item (type: $typeDef[arrayType]):</td>\r\n\t\t\t\t\t<td><input type='text' name='parameters[\".$name.\"][]'></td></tr>\";\r\n\t\t\t\t}\r\n\t\t\t\t$buffer .= '</table>';\r\n\t\t\t// if scalar\r\n\t\t\t} else {\r\n\t\t\t\t$buffer .= \"<input type='text' name='parameters[$name]'>\";\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t$buffer .= \"<input type='text' name='parameters[$name]'>\";\r\n\t\t}\r\n\t\treturn $buffer;\r\n\t}\r\n\t\r\n\t/**\r\n\t* adds a complex type to the schema\r\n\t* \r\n\t* example: array\r\n\t* \r\n\t* addType(\r\n\t* \t'ArrayOfstring',\r\n\t* \t'complexType',\r\n\t* \t'array',\r\n\t* \t'',\r\n\t* \t'SOAP-ENC:Array',\r\n\t* \tarray('ref'=>'SOAP-ENC:arrayType','wsdl:arrayType'=>'string[]'),\r\n\t* \t'xsd:string'\r\n\t* );\r\n\t* \r\n\t* example: PHP associative array ( SOAP Struct )\r\n\t* \r\n\t* addType(\r\n\t* \t'SOAPStruct',\r\n\t* \t'complexType',\r\n\t* \t'struct',\r\n\t* \t'all',\r\n\t* \tarray('myVar'=> array('name'=>'myVar','type'=>'string')\r\n\t* );\r\n\t* \r\n\t* @param name\r\n\t* @param typeClass (complexType|simpleType|attribute)\r\n\t* @param phpType: currently supported are array and struct (php assoc array)\r\n\t* @param compositor (all|sequence|choice)\r\n\t* @param restrictionBase namespace:name (http://schemas.xmlsoap.org/soap/encoding/:Array)\r\n\t* @param elements = array ( name = array(name=>'',type=>'') )\r\n\t* @param attrs = array(\r\n\t* \tarray(\r\n\t*\t\t'ref' => \"http://schemas.xmlsoap.org/soap/encoding/:arrayType\",\r\n\t*\t\t\"http://schemas.xmlsoap.org/wsdl/:arrayType\" => \"string[]\"\r\n\t* \t)\r\n\t* )\r\n\t* @param arrayType: namespace:name (http://www.w3.org/2001/XMLSchema:string)\r\n\t* @access public\r\n\t* @see getTypeDef\r\n\t*/\r\n\tfunction addComplexType($name,$typeClass='complexType',$phpType='array',$compositor='',$restrictionBase='',$elements=array(),$attrs=array(),$arrayType=''){\r\n\t\t$this->complexTypes[$name] = array(\r\n\t    'name'\t\t=> $name,\r\n\t    'typeClass'\t=> $typeClass,\r\n\t    'phpType'\t=> $phpType,\r\n\t\t'compositor'=> $compositor,\r\n\t    'restrictionBase' => $restrictionBase,\r\n\t\t'elements'\t=> $elements,\r\n\t    'attrs'\t\t=> $attrs,\r\n\t    'arrayType'\t=> $arrayType\r\n\t\t);\r\n\t\t\r\n\t\t$this->xdebug(\"addComplexType $name:\");\r\n\t\t$this->appendDebug($this->varDump($this->complexTypes[$name]));\r\n\t}\r\n\t\r\n\t/**\r\n\t* adds a simple type to the schema\r\n\t*\r\n\t* @param string $name\r\n\t* @param string $restrictionBase namespace:name (http://schemas.xmlsoap.org/soap/encoding/:Array)\r\n\t* @param string $typeClass (should always be simpleType)\r\n\t* @param string $phpType (should always be scalar)\r\n\t* @param array $enumeration array of values\r\n\t* @access public\r\n\t* @see nusoap_xmlschema\r\n\t* @see getTypeDef\r\n\t*/\r\n\tfunction addSimpleType($name, $restrictionBase='', $typeClass='simpleType', $phpType='scalar', $enumeration=array()) {\r\n\t\t$this->simpleTypes[$name] = array(\r\n\t    'name'\t\t\t=> $name,\r\n\t    'typeClass'\t\t=> $typeClass,\r\n\t    'phpType'\t\t=> $phpType,\r\n\t    'type'\t\t\t=> $restrictionBase,\r\n\t    'enumeration'\t=> $enumeration\r\n\t\t);\r\n\t\t\r\n\t\t$this->xdebug(\"addSimpleType $name:\");\r\n\t\t$this->appendDebug($this->varDump($this->simpleTypes[$name]));\r\n\t}\r\n\r\n\t/**\r\n\t* adds an element to the schema\r\n\t*\r\n\t* @param array $attrs attributes that must include name and type\r\n\t* @see nusoap_xmlschema\r\n\t* @access public\r\n\t*/\r\n\tfunction addElement($attrs) {\r\n\t\tif (! $this->getPrefix($attrs['type'])) {\r\n\t\t\t$attrs['type'] = $this->schemaTargetNamespace . ':' . $attrs['type'];\r\n\t\t}\r\n\t\t$this->elements[ $attrs['name'] ] = $attrs;\r\n\t\t$this->elements[ $attrs['name'] ]['typeClass'] = 'element';\r\n\t\t\r\n\t\t$this->xdebug(\"addElement \" . $attrs['name']);\r\n\t\t$this->appendDebug($this->varDump($this->elements[ $attrs['name'] ]));\r\n\t}\r\n}\r\n\r\n/**\r\n * Backward compatibility\r\n */\r\nclass XMLSchema extends nusoap_xmlschema {\r\n}\r\n\r\n?><?php\r\n\r\n\r\n\r\n/**\r\n* For creating serializable abstractions of native PHP types.  This class\r\n* allows element name/namespace, XSD type, and XML attributes to be\r\n* associated with a value.  This is extremely useful when WSDL is not\r\n* used, but is also useful when WSDL is used with polymorphic types, including\r\n* xsd:anyType and user-defined types.\r\n*\r\n* @author   Dietrich Ayala <dietrich@ganx4.com>\r\n* @version  $Id: nusoap.php,v 1.114 2007/11/06 15:17:46 snichol Exp $\r\n* @access   public\r\n*/\r\nclass soapval extends nusoap_base {\r\n\t/**\r\n\t * The XML element name\r\n\t *\r\n\t * @var string\r\n\t * @access private\r\n\t */\r\n\tvar $name;\r\n\t/**\r\n\t * The XML type name (string or false)\r\n\t *\r\n\t * @var mixed\r\n\t * @access private\r\n\t */\r\n\tvar $type;\r\n\t/**\r\n\t * The PHP value\r\n\t *\r\n\t * @var mixed\r\n\t * @access private\r\n\t */\r\n\tvar $value;\r\n\t/**\r\n\t * The XML element namespace (string or false)\r\n\t *\r\n\t * @var mixed\r\n\t * @access private\r\n\t */\r\n\tvar $element_ns;\r\n\t/**\r\n\t * The XML type namespace (string or false)\r\n\t *\r\n\t * @var mixed\r\n\t * @access private\r\n\t */\r\n\tvar $type_ns;\r\n\t/**\r\n\t * The XML element attributes (array or false)\r\n\t *\r\n\t * @var mixed\r\n\t * @access private\r\n\t */\r\n\tvar $attributes;\r\n\r\n\t/**\r\n\t* constructor\r\n\t*\r\n\t* @param    string $name optional name\r\n\t* @param    mixed $type optional type name\r\n\t* @param\tmixed $value optional value\r\n\t* @param\tmixed $element_ns optional namespace of value\r\n\t* @param\tmixed $type_ns optional namespace of type\r\n\t* @param\tmixed $attributes associative array of attributes to add to element serialization\r\n\t* @access   public\r\n\t*/\r\n  \tfunction soapval($name='soapval',$type=false,$value=-1,$element_ns=false,$type_ns=false,$attributes=false) {\r\n\t\tparent::nusoap_base();\r\n\t\t$this->name = $name;\r\n\t\t$this->type = $type;\r\n\t\t$this->value = $value;\r\n\t\t$this->element_ns = $element_ns;\r\n\t\t$this->type_ns = $type_ns;\r\n\t\t$this->attributes = $attributes;\r\n    }\r\n\r\n\t/**\r\n\t* return serialized value\r\n\t*\r\n\t* @param\tstring $use The WSDL use value (encoded|literal)\r\n\t* @return\tstring XML data\r\n\t* @access   public\r\n\t*/\r\n\tfunction serialize($use='encoded') {\r\n\t\treturn $this->serialize_val($this->value, $this->name, $this->type, $this->element_ns, $this->type_ns, $this->attributes, $use, true);\r\n    }\r\n\r\n\t/**\r\n\t* decodes a soapval object into a PHP native type\r\n\t*\r\n\t* @return\tmixed\r\n\t* @access   public\r\n\t*/\r\n\tfunction decode(){\r\n\t\treturn $this->value;\r\n\t}\r\n}\r\n\r\n\r\n\r\n?><?php\r\n\r\n\r\n\r\n/**\r\n* transport class for sending/receiving data via HTTP and HTTPS\r\n* NOTE: PHP must be compiled with the CURL extension for HTTPS support\r\n*\r\n* @author   Dietrich Ayala <dietrich@ganx4.com>\r\n* @author   Scott Nichol <snichol@users.sourceforge.net>\r\n* @version  $Id: nusoap.php,v 1.114 2007/11/06 15:17:46 snichol Exp $\r\n* @access public\r\n*/\r\nclass soap_transport_http extends nusoap_base {\r\n\r\n\tvar $url = '';\r\n\tvar $uri = '';\r\n\tvar $digest_uri = '';\r\n\tvar $scheme = '';\r\n\tvar $host = '';\r\n\tvar $port = '';\r\n\tvar $path = '';\r\n\tvar $request_method = 'POST';\r\n\tvar $protocol_version = '1.0';\r\n\tvar $encoding = '';\r\n\tvar $outgoing_headers = array();\r\n\tvar $incoming_headers = array();\r\n\tvar $incoming_cookies = array();\r\n\tvar $outgoing_payload = '';\r\n\tvar $incoming_payload = '';\r\n\tvar $response_status_line;\t// HTTP response status line\r\n\tvar $useSOAPAction = true;\r\n\tvar $persistentConnection = false;\r\n\tvar $ch = false;\t// cURL handle\r\n\tvar $ch_options = array();\t// cURL custom options\r\n\tvar $use_curl = false;\t\t// force cURL use\r\n\tvar $proxy = null;\t\t\t// proxy information (associative array)\r\n\tvar $username = '';\r\n\tvar $password = '';\r\n\tvar $authtype = '';\r\n\tvar $digestRequest = array();\r\n\tvar $certRequest = array();\t// keys must be cainfofile (optional), sslcertfile, sslkeyfile, passphrase, certpassword (optional), verifypeer (optional), verifyhost (optional)\r\n\t\t\t\t\t\t\t\t// cainfofile: certificate authority file, e.g. '$pathToPemFiles/rootca.pem'\r\n\t\t\t\t\t\t\t\t// sslcertfile: SSL certificate file, e.g. '$pathToPemFiles/mycert.pem'\r\n\t\t\t\t\t\t\t\t// sslkeyfile: SSL key file, e.g. '$pathToPemFiles/mykey.pem'\r\n\t\t\t\t\t\t\t\t// passphrase: SSL key password/passphrase\r\n\t\t\t\t\t\t\t\t// certpassword: SSL certificate password\r\n\t\t\t\t\t\t\t\t// verifypeer: default is 1\r\n\t\t\t\t\t\t\t\t// verifyhost: default is 1\r\n\r\n\t/**\r\n\t* constructor\r\n\t*\r\n\t* @param string $url The URL to which to connect\r\n\t* @param array $curl_options User-specified cURL options\r\n\t* @param boolean $use_curl Whether to try to force cURL use\r\n\t* @access public\r\n\t*/\r\n\tfunction soap_transport_http($url, $curl_options = NULL, $use_curl = false){\r\n\t\tparent::nusoap_base();\r\n\t\t$this->debug(\"ctor url=$url use_curl=$use_curl curl_options:\");\r\n\t\t$this->appendDebug($this->varDump($curl_options));\r\n\t\t$this->setURL($url);\r\n\t\tif (is_array($curl_options)) {\r\n\t\t\t$this->ch_options = $curl_options;\r\n\t\t}\r\n\t\t$this->use_curl = $use_curl;\r\n\t\tereg('\\$Revisio' . 'n: ([^ ]+)', $this->revision, $rev);\r\n\t\t$this->setHeader('User-Agent', $this->title.'/'.$this->version.' ('.$rev[1].')');\r\n\t}\r\n\r\n\t/**\r\n\t* sets a cURL option\r\n\t*\r\n\t* @param\tmixed $option The cURL option (always integer?)\r\n\t* @param\tmixed $value The cURL option value\r\n\t* @access   private\r\n\t*/\r\n\tfunction setCurlOption($option, $value) {\r\n\t\t$this->debug(\"setCurlOption option=$option, value=\");\r\n\t\t$this->appendDebug($this->varDump($value));\r\n\t\tcurl_setopt($this->ch, $option, $value);\r\n\t}\r\n\r\n\t/**\r\n\t* sets an HTTP header\r\n\t*\r\n\t* @param string $name The name of the header\r\n\t* @param string $value The value of the header\r\n\t* @access private\r\n\t*/\r\n\tfunction setHeader($name, $value) {\r\n\t\t$this->outgoing_headers[$name] = $value;\r\n\t\t$this->debug(\"set header $name: $value\");\r\n\t}\r\n\r\n\t/**\r\n\t* unsets an HTTP header\r\n\t*\r\n\t* @param string $name The name of the header\r\n\t* @access private\r\n\t*/\r\n\tfunction unsetHeader($name) {\r\n\t\tif (isset($this->outgoing_headers[$name])) {\r\n\t\t\t$this->debug(\"unset header $name\");\r\n\t\t\tunset($this->outgoing_headers[$name]);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* sets the URL to which to connect\r\n\t*\r\n\t* @param string $url The URL to which to connect\r\n\t* @access private\r\n\t*/\r\n\tfunction setURL($url) {\r\n\t\t$this->url = $url;\r\n\r\n\t\t$u = parse_url($url);\r\n\t\tforeach($u as $k => $v){\r\n\t\t\t$this->debug(\"parsed URL $k = $v\");\r\n\t\t\t$this->$k = $v;\r\n\t\t}\r\n\t\t\r\n\t\t// add any GET params to path\r\n\t\tif(isset($u['query']) && $u['query'] != ''){\r\n            $this->path .= '?' . $u['query'];\r\n\t\t}\r\n\t\t\r\n\t\t// set default port\r\n\t\tif(!isset($u['port'])){\r\n\t\t\tif($u['scheme'] == 'https'){\r\n\t\t\t\t$this->port = 443;\r\n\t\t\t} else {\r\n\t\t\t\t$this->port = 80;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t$this->uri = $this->path;\r\n\t\t$this->digest_uri = $this->uri;\r\n\t\t\r\n\t\t// build headers\r\n\t\tif (!isset($u['port'])) {\r\n\t\t\t$this->setHeader('Host', $this->host);\r\n\t\t} else {\r\n\t\t\t$this->setHeader('Host', $this->host.':'.$this->port);\r\n\t\t}\r\n\r\n\t\tif (isset($u['user']) && $u['user'] != '') {\r\n\t\t\t$this->setCredentials(urldecode($u['user']), isset($u['pass']) ? urldecode($u['pass']) : '');\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* gets the I/O method to use\r\n\t*\r\n\t* @return\tstring\tI/O method to use (socket|curl|unknown)\r\n\t* @access\tprivate\r\n\t*/\r\n\tfunction io_method() {\r\n\t\tif ($this->use_curl || ($this->scheme == 'https') || ($this->scheme == 'http' && $this->authtype == 'ntlm') || ($this->scheme == 'http' && is_array($this->proxy) && $this->proxy['authtype'] == 'ntlm'))\r\n\t\t\treturn 'curl';\r\n\t\tif (($this->scheme == 'http' || $this->scheme == 'ssl') && $this->authtype != 'ntlm' && (!is_array($this->proxy) || $this->proxy['authtype'] != 'ntlm'))\r\n\t\t\treturn 'socket';\r\n\t\treturn 'unknown';\r\n\t}\r\n\r\n\t/**\r\n\t* establish an HTTP connection\r\n\t*\r\n\t* @param    integer $timeout set connection timeout in seconds\r\n\t* @param\tinteger $response_timeout set response timeout in seconds\r\n\t* @return\tboolean true if connected, false if not\r\n\t* @access   private\r\n\t*/\r\n\tfunction connect($connection_timeout=0,$response_timeout=30){\r\n\t  \t// For PHP 4.3 with OpenSSL, change https scheme to ssl, then treat like\r\n\t  \t// \"regular\" socket.\r\n\t  \t// TODO: disabled for now because OpenSSL must be *compiled* in (not just\r\n\t  \t//       loaded), and until PHP5 stream_get_wrappers is not available.\r\n//\t  \tif ($this->scheme == 'https') {\r\n//\t\t  \tif (version_compare(phpversion(), '4.3.0') >= 0) {\r\n//\t\t  \t\tif (extension_loaded('openssl')) {\r\n//\t\t  \t\t\t$this->scheme = 'ssl';\r\n//\t\t  \t\t\t$this->debug('Using SSL over OpenSSL');\r\n//\t\t  \t\t}\r\n//\t\t  \t}\r\n//\t\t}\r\n\t\t$this->debug(\"connect connection_timeout $connection_timeout, response_timeout $response_timeout, scheme $this->scheme, host $this->host, port $this->port\");\r\n\t  if ($this->io_method() == 'socket') {\r\n\t\tif (!is_array($this->proxy)) {\r\n\t\t\t$host = $this->host;\r\n\t\t\t$port = $this->port;\r\n\t\t} else {\r\n\t\t\t$host = $this->proxy['host'];\r\n\t\t\t$port = $this->proxy['port'];\r\n\t\t}\r\n\r\n\t\t// use persistent connection\r\n\t\tif($this->persistentConnection && isset($this->fp) && is_resource($this->fp)){\r\n\t\t\tif (!feof($this->fp)) {\r\n\t\t\t\t$this->debug('Re-use persistent connection');\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tfclose($this->fp);\r\n\t\t\t$this->debug('Closed persistent connection at EOF');\r\n\t\t}\r\n\r\n\t\t// munge host if using OpenSSL\r\n\t\tif ($this->scheme == 'ssl') {\r\n\t\t\t$host = 'ssl://' . $host;\r\n\t\t}\r\n\t\t$this->debug('calling fsockopen with host ' . $host . ' connection_timeout ' . $connection_timeout);\r\n\r\n\t\t// open socket\r\n\t\tif($connection_timeout > 0){\r\n\t\t\t$this->fp = @fsockopen( $host, $this->port, $this->errno, $this->error_str, $connection_timeout);\r\n\t\t} else {\r\n\t\t\t$this->fp = @fsockopen( $host, $this->port, $this->errno, $this->error_str);\r\n\t\t}\r\n\t\t\r\n\t\t// test pointer\r\n\t\tif(!$this->fp) {\r\n\t\t\t$msg = 'Couldn\\'t open socket connection to server ' . $this->url;\r\n\t\t\tif ($this->errno) {\r\n\t\t\t\t$msg .= ', Error ('.$this->errno.'): '.$this->error_str;\r\n\t\t\t} else {\r\n\t\t\t\t$msg .= ' prior to connect().  This is often a problem looking up the host name.';\r\n\t\t\t}\r\n\t\t\t$this->debug($msg);\r\n\t\t\t$this->setError($msg);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\t// set response timeout\r\n\t\t$this->debug('set response timeout to ' . $response_timeout);\r\n\t\tsocket_set_timeout( $this->fp, $response_timeout);\r\n\r\n\t\t$this->debug('socket connected');\r\n\t\treturn true;\r\n\t  } else if ($this->io_method() == 'curl') {\r\n\t\tif (!extension_loaded('curl')) {\r\n//\t\t\t$this->setError('cURL Extension, or OpenSSL extension w/ PHP version >= 4.3 is required for HTTPS');\r\n\t\t\t$this->setError('The PHP cURL Extension is required for HTTPS or NLTM.  You will need to re-build or update your PHP to included cURL.');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t// Avoid warnings when PHP does not have these options\r\n\t\tif (defined('CURLOPT_CONNECTIONTIMEOUT'))\r\n\t\t\t$CURLOPT_CONNECTIONTIMEOUT = CURLOPT_CONNECTIONTIMEOUT;\r\n\t\telse\r\n\t\t\t$CURLOPT_CONNECTIONTIMEOUT = 78;\r\n\t\tif (defined('CURLOPT_HTTPAUTH'))\r\n\t\t\t$CURLOPT_HTTPAUTH = CURLOPT_HTTPAUTH;\r\n\t\telse\r\n\t\t\t$CURLOPT_HTTPAUTH = 107;\r\n\t\tif (defined('CURLOPT_PROXYAUTH'))\r\n\t\t\t$CURLOPT_PROXYAUTH = CURLOPT_PROXYAUTH;\r\n\t\telse\r\n\t\t\t$CURLOPT_PROXYAUTH = 111;\r\n\t\tif (defined('CURLAUTH_BASIC'))\r\n\t\t\t$CURLAUTH_BASIC = CURLAUTH_BASIC;\r\n\t\telse\r\n\t\t\t$CURLAUTH_BASIC = 1;\r\n\t\tif (defined('CURLAUTH_DIGEST'))\r\n\t\t\t$CURLAUTH_DIGEST = CURLAUTH_DIGEST;\r\n\t\telse\r\n\t\t\t$CURLAUTH_DIGEST = 2;\r\n\t\tif (defined('CURLAUTH_NTLM'))\r\n\t\t\t$CURLAUTH_NTLM = CURLAUTH_NTLM;\r\n\t\telse\r\n\t\t\t$CURLAUTH_NTLM = 8;\r\n\r\n\t\t$this->debug('connect using cURL');\r\n\t\t// init CURL\r\n\t\t$this->ch = curl_init();\r\n\t\t// set url\r\n\t\t$hostURL = ($this->port != '') ? \"$this->scheme://$this->host:$this->port\" : \"$this->scheme://$this->host\";\r\n\t\t// add path\r\n\t\t$hostURL .= $this->path;\r\n\t\t$this->setCurlOption(CURLOPT_URL, $hostURL);\r\n\t\t// follow location headers (re-directs)\r\n\t\tif (ini_get('safe_mode') || ini_get('open_basedir')) {\r\n\t\t\t$this->debug('safe_mode or open_basedir set, so do not set CURLOPT_FOLLOWLOCATION');\r\n\t\t\t$this->debug('safe_mode = ');\r\n\t\t\t$this->appendDebug($this->varDump(ini_get('safe_mode')));\r\n\t\t\t$this->debug('open_basedir = ');\r\n\t\t\t$this->appendDebug($this->varDump(ini_get('open_basedir')));\r\n\t\t} else {\r\n\t\t\t$this->setCurlOption(CURLOPT_FOLLOWLOCATION, 1);\r\n\t\t}\r\n\t\t// ask for headers in the response output\r\n\t\t$this->setCurlOption(CURLOPT_HEADER, 1);\r\n\t\t// ask for the response output as the return value\r\n\t\t$this->setCurlOption(CURLOPT_RETURNTRANSFER, 1);\r\n\t\t// encode\r\n\t\t// We manage this ourselves through headers and encoding\r\n//\t\tif(function_exists('gzuncompress')){\r\n//\t\t\t$this->setCurlOption(CURLOPT_ENCODING, 'deflate');\r\n//\t\t}\r\n\t\t// persistent connection\r\n\t\tif ($this->persistentConnection) {\r\n\t\t\t// I believe the following comment is now bogus, having applied to\r\n\t\t\t// the code when it used CURLOPT_CUSTOMREQUEST to send the request.\r\n\t\t\t// The way we send data, we cannot use persistent connections, since\r\n\t\t\t// there will be some \"junk\" at the end of our request.\r\n\t\t\t//$this->setCurlOption(CURL_HTTP_VERSION_1_1, true);\r\n\t\t\t$this->persistentConnection = false;\r\n\t\t\t$this->setHeader('Connection', 'close');\r\n\t\t}\r\n\t\t// set timeouts\r\n\t\tif ($connection_timeout != 0) {\r\n\t\t\t$this->setCurlOption($CURLOPT_CONNECTIONTIMEOUT, $connection_timeout);\r\n\t\t}\r\n\t\tif ($response_timeout != 0) {\r\n\t\t\t$this->setCurlOption(CURLOPT_TIMEOUT, $response_timeout);\r\n\t\t}\r\n\r\n\t\tif ($this->scheme == 'https') {\r\n\t\t\t$this->debug('set cURL SSL verify options');\r\n\t\t\t// recent versions of cURL turn on peer/host checking by default,\r\n\t\t\t// while PHP binaries are not compiled with a default location for the\r\n\t\t\t// CA cert bundle, so disable peer/host checking.\r\n\t\t\t//$this->setCurlOption(CURLOPT_CAINFO, 'f:\\php-4.3.2-win32\\extensions\\curl-ca-bundle.crt');\t\t\r\n\t\t\t$this->setCurlOption(CURLOPT_SSL_VERIFYPEER, 0);\r\n\t\t\t$this->setCurlOption(CURLOPT_SSL_VERIFYHOST, 0);\r\n\t\r\n\t\t\t// support client certificates (thanks Tobias Boes, Doug Anarino, Eryan Ariobowo)\r\n\t\t\tif ($this->authtype == 'certificate') {\r\n\t\t\t\t$this->debug('set cURL certificate options');\r\n\t\t\t\tif (isset($this->certRequest['cainfofile'])) {\r\n\t\t\t\t\t$this->setCurlOption(CURLOPT_CAINFO, $this->certRequest['cainfofile']);\r\n\t\t\t\t}\r\n\t\t\t\tif (isset($this->certRequest['verifypeer'])) {\r\n\t\t\t\t\t$this->setCurlOption(CURLOPT_SSL_VERIFYPEER, $this->certRequest['verifypeer']);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$this->setCurlOption(CURLOPT_SSL_VERIFYPEER, 1);\r\n\t\t\t\t}\r\n\t\t\t\tif (isset($this->certRequest['verifyhost'])) {\r\n\t\t\t\t\t$this->setCurlOption(CURLOPT_SSL_VERIFYHOST, $this->certRequest['verifyhost']);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$this->setCurlOption(CURLOPT_SSL_VERIFYHOST, 1);\r\n\t\t\t\t}\r\n\t\t\t\tif (isset($this->certRequest['sslcertfile'])) {\r\n\t\t\t\t\t$this->setCurlOption(CURLOPT_SSLCERT, $this->certRequest['sslcertfile']);\r\n\t\t\t\t}\r\n\t\t\t\tif (isset($this->certRequest['sslkeyfile'])) {\r\n\t\t\t\t\t$this->setCurlOption(CURLOPT_SSLKEY, $this->certRequest['sslkeyfile']);\r\n\t\t\t\t}\r\n\t\t\t\tif (isset($this->certRequest['passphrase'])) {\r\n\t\t\t\t\t$this->setCurlOption(CURLOPT_SSLKEYPASSWD, $this->certRequest['passphrase']);\r\n\t\t\t\t}\r\n\t\t\t\tif (isset($this->certRequest['certpassword'])) {\r\n\t\t\t\t\t$this->setCurlOption(CURLOPT_SSLCERTPASSWD, $this->certRequest['certpassword']);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ($this->authtype && ($this->authtype != 'certificate')) {\r\n\t\t\tif ($this->username) {\r\n\t\t\t\t$this->debug('set cURL username/password');\r\n\t\t\t\t$this->setCurlOption(CURLOPT_USERPWD, \"$this->username:$this->password\");\r\n\t\t\t}\r\n\t\t\tif ($this->authtype == 'basic') {\r\n\t\t\t\t$this->debug('set cURL for Basic authentication');\r\n\t\t\t\t$this->setCurlOption($CURLOPT_HTTPAUTH, $CURLAUTH_BASIC);\r\n\t\t\t}\r\n\t\t\tif ($this->authtype == 'digest') {\r\n\t\t\t\t$this->debug('set cURL for digest authentication');\r\n\t\t\t\t$this->setCurlOption($CURLOPT_HTTPAUTH, $CURLAUTH_DIGEST);\r\n\t\t\t}\r\n\t\t\tif ($this->authtype == 'ntlm') {\r\n\t\t\t\t$this->debug('set cURL for NTLM authentication');\r\n\t\t\t\t$this->setCurlOption($CURLOPT_HTTPAUTH, $CURLAUTH_NTLM);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (is_array($this->proxy)) {\r\n\t\t\t$this->debug('set cURL proxy options');\r\n\t\t\tif ($this->proxy['port'] != '') {\r\n\t\t\t\t$this->setCurlOption(CURLOPT_PROXY, $this->proxy['host'].':'.$this->proxy['port']);\r\n\t\t\t} else {\r\n\t\t\t\t$this->setCurlOption(CURLOPT_PROXY, $this->proxy['host']);\r\n\t\t\t}\r\n\t\t\tif ($this->proxy['username'] || $this->proxy['password']) {\r\n\t\t\t\t$this->debug('set cURL proxy authentication options');\r\n\t\t\t\t$this->setCurlOption(CURLOPT_PROXYUSERPWD, $this->proxy['username'].':'.$this->proxy['password']);\r\n\t\t\t\tif ($this->proxy['authtype'] == 'basic') {\r\n\t\t\t\t\t$this->setCurlOption($CURLOPT_PROXYAUTH, $CURLAUTH_BASIC);\r\n\t\t\t\t}\r\n\t\t\t\tif ($this->proxy['authtype'] == 'ntlm') {\r\n\t\t\t\t\t$this->setCurlOption($CURLOPT_PROXYAUTH, $CURLAUTH_NTLM);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t$this->debug('cURL connection set up');\r\n\t\treturn true;\r\n\t  } else {\r\n\t\t$this->setError('Unknown scheme ' . $this->scheme);\r\n\t\t$this->debug('Unknown scheme ' . $this->scheme);\r\n\t\treturn false;\r\n\t  }\r\n\t}\r\n\r\n\t/**\r\n\t* sends the SOAP request and gets the SOAP response via HTTP[S]\r\n\t*\r\n\t* @param    string $data message data\r\n\t* @param    integer $timeout set connection timeout in seconds\r\n\t* @param\tinteger $response_timeout set response timeout in seconds\r\n\t* @param\tarray $cookies cookies to send\r\n\t* @return\tstring data\r\n\t* @access   public\r\n\t*/\r\n\tfunction send($data, $timeout=0, $response_timeout=30, $cookies=NULL) {\r\n\t\t\r\n\t\t$this->debug('entered send() with data of length: '.strlen($data));\r\n\r\n\t\t$this->tryagain = true;\r\n\t\t$tries = 0;\r\n\t\twhile ($this->tryagain) {\r\n\t\t\t$this->tryagain = false;\r\n\t\t\tif ($tries++ < 2) {\r\n\t\t\t\t// make connnection\r\n\t\t\t\tif (!$this->connect($timeout, $response_timeout)){\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// send request\r\n\t\t\t\tif (!$this->sendRequest($data, $cookies)){\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// get response\r\n\t\t\t\t$respdata = $this->getResponse();\r\n\t\t\t} else {\r\n\t\t\t\t$this->setError(\"Too many tries to get an OK response ($this->response_status_line)\");\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t\t$this->debug('end of send()');\r\n\t\treturn $respdata;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* sends the SOAP request and gets the SOAP response via HTTPS using CURL\r\n\t*\r\n\t* @param    string $data message data\r\n\t* @param    integer $timeout set connection timeout in seconds\r\n\t* @param\tinteger $response_timeout set response timeout in seconds\r\n\t* @param\tarray $cookies cookies to send\r\n\t* @return\tstring data\r\n\t* @access   public\r\n\t* @deprecated\r\n\t*/\r\n\tfunction sendHTTPS($data, $timeout=0, $response_timeout=30, $cookies) {\r\n\t\treturn $this->send($data, $timeout, $response_timeout, $cookies);\r\n\t}\r\n\t\r\n\t/**\r\n\t* if authenticating, set user credentials here\r\n\t*\r\n\t* @param    string $username\r\n\t* @param    string $password\r\n\t* @param\tstring $authtype (basic|digest|certificate|ntlm)\r\n\t* @param\tarray $digestRequest (keys must be nonce, nc, realm, qop)\r\n\t* @param\tarray $certRequest (keys must be cainfofile (optional), sslcertfile, sslkeyfile, passphrase, certpassword (optional), verifypeer (optional), verifyhost (optional): see corresponding options in cURL docs)\r\n\t* @access   public\r\n\t*/\r\n\tfunction setCredentials($username, $password, $authtype = 'basic', $digestRequest = array(), $certRequest = array()) {\r\n\t\t$this->debug(\"setCredentials username=$username authtype=$authtype digestRequest=\");\r\n\t\t$this->appendDebug($this->varDump($digestRequest));\r\n\t\t$this->debug(\"certRequest=\");\r\n\t\t$this->appendDebug($this->varDump($certRequest));\r\n\t\t// cf. RFC 2617\r\n\t\tif ($authtype == 'basic') {\r\n\t\t\t$this->setHeader('Authorization', 'Basic '.base64_encode(str_replace(':','',$username).':'.$password));\r\n\t\t} elseif ($authtype == 'digest') {\r\n\t\t\tif (isset($digestRequest['nonce'])) {\r\n\t\t\t\t$digestRequest['nc'] = isset($digestRequest['nc']) ? $digestRequest['nc']++ : 1;\r\n\t\t\t\t\r\n\t\t\t\t// calculate the Digest hashes (calculate code based on digest implementation found at: http://www.rassoc.com/gregr/weblog/stories/2002/07/09/webServicesSecurityHttpDigestAuthenticationWithoutActiveDirectory.html)\r\n\t\r\n\t\t\t\t// A1 = unq(username-value) \":\" unq(realm-value) \":\" passwd\r\n\t\t\t\t$A1 = $username. ':' . (isset($digestRequest['realm']) ? $digestRequest['realm'] : '') . ':' . $password;\r\n\t\r\n\t\t\t\t// H(A1) = MD5(A1)\r\n\t\t\t\t$HA1 = md5($A1);\r\n\t\r\n\t\t\t\t// A2 = Method \":\" digest-uri-value\r\n\t\t\t\t$A2 = $this->request_method . ':' . $this->digest_uri;\r\n\t\r\n\t\t\t\t// H(A2)\r\n\t\t\t\t$HA2 =  md5($A2);\r\n\t\r\n\t\t\t\t// KD(secret, data) = H(concat(secret, \":\", data))\r\n\t\t\t\t// if qop == auth:\r\n\t\t\t\t// request-digest  = <\"> < KD ( H(A1),     unq(nonce-value)\r\n\t\t\t\t//                              \":\" nc-value\r\n\t\t\t\t//                              \":\" unq(cnonce-value)\r\n\t\t\t\t//                              \":\" unq(qop-value)\r\n\t\t\t\t//                              \":\" H(A2)\r\n\t\t\t\t//                            ) <\">\r\n\t\t\t\t// if qop is missing,\r\n\t\t\t\t// request-digest  = <\"> < KD ( H(A1), unq(nonce-value) \":\" H(A2) ) > <\">\r\n\t\r\n\t\t\t\t$unhashedDigest = '';\r\n\t\t\t\t$nonce = isset($digestRequest['nonce']) ? $digestRequest['nonce'] : '';\r\n\t\t\t\t$cnonce = $nonce;\r\n\t\t\t\tif ($digestRequest['qop'] != '') {\r\n\t\t\t\t\t$unhashedDigest = $HA1 . ':' . $nonce . ':' . sprintf(\"%08d\", $digestRequest['nc']) . ':' . $cnonce . ':' . $digestRequest['qop'] . ':' . $HA2;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$unhashedDigest = $HA1 . ':' . $nonce . ':' . $HA2;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t$hashedDigest = md5($unhashedDigest);\r\n\t\r\n\t\t\t\t$opaque = '';\t\r\n\t\t\t\tif (isset($digestRequest['opaque'])) {\r\n\t\t\t\t\t$opaque = ', opaque=\"' . $digestRequest['opaque'] . '\"';\r\n\t\t\t\t}\r\n\r\n\t\t\t\t$this->setHeader('Authorization', 'Digest username=\"' . $username . '\", realm=\"' . $digestRequest['realm'] . '\", nonce=\"' . $nonce . '\", uri=\"' . $this->digest_uri . $opaque . '\", cnonce=\"' . $cnonce . '\", nc=' . sprintf(\"%08x\", $digestRequest['nc']) . ', qop=\"' . $digestRequest['qop'] . '\", response=\"' . $hashedDigest . '\"');\r\n\t\t\t}\r\n\t\t} elseif ($authtype == 'certificate') {\r\n\t\t\t$this->certRequest = $certRequest;\r\n\t\t\t$this->debug('Authorization header not set for certificate');\r\n\t\t} elseif ($authtype == 'ntlm') {\r\n\t\t\t// do nothing\r\n\t\t\t$this->debug('Authorization header not set for ntlm');\r\n\t\t}\r\n\t\t$this->username = $username;\r\n\t\t$this->password = $password;\r\n\t\t$this->authtype = $authtype;\r\n\t\t$this->digestRequest = $digestRequest;\r\n\t}\r\n\t\r\n\t/**\r\n\t* set the soapaction value\r\n\t*\r\n\t* @param    string $soapaction\r\n\t* @access   public\r\n\t*/\r\n\tfunction setSOAPAction($soapaction) {\r\n\t\t$this->setHeader('SOAPAction', '\"' . $soapaction . '\"');\r\n\t}\r\n\t\r\n\t/**\r\n\t* use http encoding\r\n\t*\r\n\t* @param    string $enc encoding style. supported values: gzip, deflate, or both\r\n\t* @access   public\r\n\t*/\r\n\tfunction setEncoding($enc='gzip, deflate') {\r\n\t\tif (function_exists('gzdeflate')) {\r\n\t\t\t$this->protocol_version = '1.1';\r\n\t\t\t$this->setHeader('Accept-Encoding', $enc);\r\n\t\t\tif (!isset($this->outgoing_headers['Connection'])) {\r\n\t\t\t\t$this->setHeader('Connection', 'close');\r\n\t\t\t\t$this->persistentConnection = false;\r\n\t\t\t}\r\n\t\t\tset_magic_quotes_runtime(0);\r\n\t\t\t// deprecated\r\n\t\t\t$this->encoding = $enc;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t* set proxy info here\r\n\t*\r\n\t* @param    string $proxyhost use an empty string to remove proxy\r\n\t* @param    string $proxyport\r\n\t* @param\tstring $proxyusername\r\n\t* @param\tstring $proxypassword\r\n\t* @param\tstring $proxyauthtype (basic|ntlm)\r\n\t* @access   public\r\n\t*/\r\n\tfunction setProxy($proxyhost, $proxyport, $proxyusername = '', $proxypassword = '', $proxyauthtype = 'basic') {\r\n\t\tif ($proxyhost) {\r\n\t\t\t$this->proxy = array(\r\n\t\t\t\t'host' => $proxyhost,\r\n\t\t\t\t'port' => $proxyport,\r\n\t\t\t\t'username' => $proxyusername,\r\n\t\t\t\t'password' => $proxypassword,\r\n\t\t\t\t'authtype' => $proxyauthtype\r\n\t\t\t);\r\n\t\t\tif ($proxyusername != '' && $proxypassword != '' && $proxyauthtype = 'basic') {\r\n\t\t\t\t$this->setHeader('Proxy-Authorization', ' Basic '.base64_encode($proxyusername.':'.$proxypassword));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t$this->debug('remove proxy');\r\n\t\t\t$proxy = null;\r\n\t\t\tunsetHeader('Proxy-Authorization');\r\n\t\t}\r\n\t}\r\n\t\r\n\r\n\t/**\r\n\t * Test if the given string starts with a header that is to be skipped.\r\n\t * Skippable headers result from chunked transfer and proxy requests.\r\n\t *\r\n\t * @param\tstring $data The string to check.\r\n\t * @returns\tboolean\tWhether a skippable header was found.\r\n\t * @access\tprivate\r\n\t */\r\n\tfunction isSkippableCurlHeader(&$data) {\r\n\t\t$skipHeaders = array(\t'HTTP/1.1 100',\r\n\t\t\t\t\t\t\t\t'HTTP/1.0 301',\r\n\t\t\t\t\t\t\t\t'HTTP/1.1 301',\r\n\t\t\t\t\t\t\t\t'HTTP/1.0 302',\r\n\t\t\t\t\t\t\t\t'HTTP/1.1 302',\r\n\t\t\t\t\t\t\t\t'HTTP/1.0 401',\r\n\t\t\t\t\t\t\t\t'HTTP/1.1 401',\r\n\t\t\t\t\t\t\t\t'HTTP/1.0 200 Connection established');\r\n\t\tforeach ($skipHeaders as $hd) {\r\n\t\t\t$prefix = substr($data, 0, strlen($hd));\r\n\t\t\tif ($prefix == $hd) return true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t* decode a string that is encoded w/ \"chunked' transfer encoding\r\n \t* as defined in RFC2068 19.4.6\r\n\t*\r\n\t* @param    string $buffer\r\n\t* @param    string $lb\r\n\t* @returns\tstring\r\n\t* @access   public\r\n\t* @deprecated\r\n\t*/\r\n\tfunction decodeChunked($buffer, $lb){\r\n\t\t// length := 0\r\n\t\t$length = 0;\r\n\t\t$new = '';\r\n\t\t\r\n\t\t// read chunk-size, chunk-extension (if any) and CRLF\r\n\t\t// get the position of the linebreak\r\n\t\t$chunkend = strpos($buffer, $lb);\r\n\t\tif ($chunkend == FALSE) {\r\n\t\t\t$this->debug('no linebreak found in decodeChunked');\r\n\t\t\treturn $new;\r\n\t\t}\r\n\t\t$temp = substr($buffer,0,$chunkend);\r\n\t\t$chunk_size = hexdec( trim($temp) );\r\n\t\t$chunkstart = $chunkend + strlen($lb);\r\n\t\t// while (chunk-size > 0) {\r\n\t\twhile ($chunk_size > 0) {\r\n\t\t\t$this->debug(\"chunkstart: $chunkstart chunk_size: $chunk_size\");\r\n\t\t\t$chunkend = strpos( $buffer, $lb, $chunkstart + $chunk_size);\r\n\t\t  \t\r\n\t\t\t// Just in case we got a broken connection\r\n\t\t  \tif ($chunkend == FALSE) {\r\n\t\t  \t    $chunk = substr($buffer,$chunkstart);\r\n\t\t\t\t// append chunk-data to entity-body\r\n\t\t    \t$new .= $chunk;\r\n\t\t  \t    $length += strlen($chunk);\r\n\t\t  \t    break;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t  \t// read chunk-data and CRLF\r\n\t\t  \t$chunk = substr($buffer,$chunkstart,$chunkend-$chunkstart);\r\n\t\t  \t// append chunk-data to entity-body\r\n\t\t  \t$new .= $chunk;\r\n\t\t  \t// length := length + chunk-size\r\n\t\t  \t$length += strlen($chunk);\r\n\t\t  \t// read chunk-size and CRLF\r\n\t\t  \t$chunkstart = $chunkend + strlen($lb);\r\n\t\t\t\r\n\t\t  \t$chunkend = strpos($buffer, $lb, $chunkstart) + strlen($lb);\r\n\t\t\tif ($chunkend == FALSE) {\r\n\t\t\t\tbreak; //Just in case we got a broken connection\r\n\t\t\t}\r\n\t\t\t$temp = substr($buffer,$chunkstart,$chunkend-$chunkstart);\r\n\t\t\t$chunk_size = hexdec( trim($temp) );\r\n\t\t\t$chunkstart = $chunkend;\r\n\t\t}\r\n\t\treturn $new;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Writes the payload, including HTTP headers, to $this->outgoing_payload.\r\n\t *\r\n\t * @param\tstring $data HTTP body\r\n\t * @param\tstring $cookie_str data for HTTP Cookie header\r\n\t * @return\tvoid\r\n\t * @access\tprivate\r\n\t */\r\n\tfunction buildPayload($data, $cookie_str = '') {\r\n\t\t// Note: for cURL connections, $this->outgoing_payload is ignored,\r\n\t\t// as is the Content-Length header, but these are still created as\r\n\t\t// debugging guides.\r\n\r\n\t\t// add content-length header\r\n\t\t$this->setHeader('Content-Length', strlen($data));\r\n\r\n\t\t// start building outgoing payload:\r\n\t\tif ($this->proxy) {\r\n\t\t\t$uri = $this->url;\r\n\t\t} else {\r\n\t\t\t$uri = $this->uri;\r\n\t\t}\r\n\t\t$req = \"$this->request_method $uri HTTP/$this->protocol_version\";\r\n\t\t$this->debug(\"HTTP request: $req\");\r\n\t\t$this->outgoing_payload = \"$req\\r\\n\";\r\n\r\n\t\t// loop thru headers, serializing\r\n\t\tforeach($this->outgoing_headers as $k => $v){\r\n\t\t\t$hdr = $k.': '.$v;\r\n\t\t\t$this->debug(\"HTTP header: $hdr\");\r\n\t\t\t$this->outgoing_payload .= \"$hdr\\r\\n\";\r\n\t\t}\r\n\r\n\t\t// add any cookies\r\n\t\tif ($cookie_str != '') {\r\n\t\t\t$hdr = 'Cookie: '.$cookie_str;\r\n\t\t\t$this->debug(\"HTTP header: $hdr\");\r\n\t\t\t$this->outgoing_payload .= \"$hdr\\r\\n\";\r\n\t\t}\r\n\r\n\t\t// header/body separator\r\n\t\t$this->outgoing_payload .= \"\\r\\n\";\r\n\t\t\r\n\t\t// add data\r\n\t\t$this->outgoing_payload .= $data;\r\n\t}\r\n\r\n\t/**\r\n\t* sends the SOAP request via HTTP[S]\r\n\t*\r\n\t* @param    string $data message data\r\n\t* @param\tarray $cookies cookies to send\r\n\t* @return\tboolean\ttrue if OK, false if problem\r\n\t* @access   private\r\n\t*/\r\n\tfunction sendRequest($data, $cookies = NULL) {\r\n\t\t// build cookie string\r\n\t\t$cookie_str = $this->getCookiesForRequest($cookies, (($this->scheme == 'ssl') || ($this->scheme == 'https')));\r\n\r\n\t\t// build payload\r\n\t\t$this->buildPayload($data, $cookie_str);\r\n\r\n\t  if ($this->io_method() == 'socket') {\r\n\t\t// send payload\r\n\t\tif(!fputs($this->fp, $this->outgoing_payload, strlen($this->outgoing_payload))) {\r\n\t\t\t$this->setError('couldn\\'t write message data to socket');\r\n\t\t\t$this->debug('couldn\\'t write message data to socket');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t$this->debug('wrote data to socket, length = ' . strlen($this->outgoing_payload));\r\n\t\treturn true;\r\n\t  } else if ($this->io_method() == 'curl') {\r\n\t\t// set payload\r\n\t\t// cURL does say this should only be the verb, and in fact it\r\n\t\t// turns out that the URI and HTTP version are appended to this, which\r\n\t\t// some servers refuse to work with (so we no longer use this method!)\r\n\t\t//$this->setCurlOption(CURLOPT_CUSTOMREQUEST, $this->outgoing_payload);\r\n\t\t$curl_headers = array();\r\n\t\tforeach($this->outgoing_headers as $k => $v){\r\n\t\t\tif ($k == 'Connection' || $k == 'Content-Length' || $k == 'Host' || $k == 'Authorization' || $k == 'Proxy-Authorization') {\r\n\t\t\t\t$this->debug(\"Skip cURL header $k: $v\");\r\n\t\t\t} else {\r\n\t\t\t\t$curl_headers[] = \"$k: $v\";\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ($cookie_str != '') {\r\n\t\t\t$curl_headers[] = 'Cookie: ' . $cookie_str;\r\n\t\t}\r\n\t\t$this->setCurlOption(CURLOPT_HTTPHEADER, $curl_headers);\r\n\t\t$this->debug('set cURL HTTP headers');\r\n\t\tif ($this->request_method == \"POST\") {\r\n\t  \t\t$this->setCurlOption(CURLOPT_POST, 1);\r\n\t  \t\t$this->setCurlOption(CURLOPT_POSTFIELDS, $data);\r\n\t\t\t$this->debug('set cURL POST data');\r\n\t  \t} else {\r\n\t  \t}\r\n\t\t// insert custom user-set cURL options\r\n\t\tforeach ($this->ch_options as $key => $val) {\r\n\t\t\t$this->setCurlOption($key, $val);\r\n\t\t}\r\n\r\n\t\t$this->debug('set cURL payload');\r\n\t\treturn true;\r\n\t  }\r\n\t}\r\n\r\n\t/**\r\n\t* gets the SOAP response via HTTP[S]\r\n\t*\r\n\t* @return\tstring the response (also sets member variables like incoming_payload)\r\n\t* @access   private\r\n\t*/\r\n\tfunction getResponse(){\r\n\t\t$this->incoming_payload = '';\r\n\t    \r\n\t  if ($this->io_method() == 'socket') {\r\n\t    // loop until headers have been retrieved\r\n\t    $data = '';\r\n\t    while (!isset($lb)){\r\n\r\n\t\t\t// We might EOF during header read.\r\n\t\t\tif(feof($this->fp)) {\r\n\t\t\t\t$this->incoming_payload = $data;\r\n\t\t\t\t$this->debug('found no headers before EOF after length ' . strlen($data));\r\n\t\t\t\t$this->debug(\"received before EOF:\\n\" . $data);\r\n\t\t\t\t$this->setError('server failed to send headers');\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t$tmp = fgets($this->fp, 256);\r\n\t\t\t$tmplen = strlen($tmp);\r\n\t\t\t$this->debug(\"read line of $tmplen bytes: \" . trim($tmp));\r\n\r\n\t\t\tif ($tmplen == 0) {\r\n\t\t\t\t$this->incoming_payload = $data;\r\n\t\t\t\t$this->debug('socket read of headers timed out after length ' . strlen($data));\r\n\t\t\t\t$this->debug(\"read before timeout: \" . $data);\r\n\t\t\t\t$this->setError('socket read of headers timed out');\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t$data .= $tmp;\r\n\t\t\t$pos = strpos($data,\"\\r\\n\\r\\n\");\r\n\t\t\tif($pos > 1){\r\n\t\t\t\t$lb = \"\\r\\n\";\r\n\t\t\t} else {\r\n\t\t\t\t$pos = strpos($data,\"\\n\\n\");\r\n\t\t\t\tif($pos > 1){\r\n\t\t\t\t\t$lb = \"\\n\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// remove 100 headers\r\n\t\t\tif (isset($lb) && ereg('^HTTP/1.1 100',$data)) {\r\n\t\t\t\tunset($lb);\r\n\t\t\t\t$data = '';\r\n\t\t\t}//\r\n\t\t}\r\n\t\t// store header data\r\n\t\t$this->incoming_payload .= $data;\r\n\t\t$this->debug('found end of headers after length ' . strlen($data));\r\n\t\t// process headers\r\n\t\t$header_data = trim(substr($data,0,$pos));\r\n\t\t$header_array = explode($lb,$header_data);\r\n\t\t$this->incoming_headers = array();\r\n\t\t$this->incoming_cookies = array();\r\n\t\tforeach($header_array as $header_line){\r\n\t\t\t$arr = explode(':',$header_line, 2);\r\n\t\t\tif(count($arr) > 1){\r\n\t\t\t\t$header_name = strtolower(trim($arr[0]));\r\n\t\t\t\t$this->incoming_headers[$header_name] = trim($arr[1]);\r\n\t\t\t\tif ($header_name == 'set-cookie') {\r\n\t\t\t\t\t// TODO: allow multiple cookies from parseCookie\r\n\t\t\t\t\t$cookie = $this->parseCookie(trim($arr[1]));\r\n\t\t\t\t\tif ($cookie) {\r\n\t\t\t\t\t\t$this->incoming_cookies[] = $cookie;\r\n\t\t\t\t\t\t$this->debug('found cookie: ' . $cookie['name'] . ' = ' . $cookie['value']);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$this->debug('did not find cookie in ' . trim($arr[1]));\r\n\t\t\t\t\t}\r\n    \t\t\t}\r\n\t\t\t} else if (isset($header_name)) {\r\n\t\t\t\t// append continuation line to previous header\r\n\t\t\t\t$this->incoming_headers[$header_name] .= $lb . ' ' . $header_line;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// loop until msg has been received\r\n\t\tif (isset($this->incoming_headers['transfer-encoding']) && strtolower($this->incoming_headers['transfer-encoding']) == 'chunked') {\r\n\t\t\t$content_length =  2147483647;\t// ignore any content-length header\r\n\t\t\t$chunked = true;\r\n\t\t\t$this->debug(\"want to read chunked content\");\r\n\t\t} elseif (isset($this->incoming_headers['content-length'])) {\r\n\t\t\t$content_length = $this->incoming_headers['content-length'];\r\n\t\t\t$chunked = false;\r\n\t\t\t$this->debug(\"want to read content of length $content_length\");\r\n\t\t} else {\r\n\t\t\t$content_length =  2147483647;\r\n\t\t\t$chunked = false;\r\n\t\t\t$this->debug(\"want to read content to EOF\");\r\n\t\t}\r\n\t\t$data = '';\r\n\t\tdo {\r\n\t\t\tif ($chunked) {\r\n\t\t\t\t$tmp = fgets($this->fp, 256);\r\n\t\t\t\t$tmplen = strlen($tmp);\r\n\t\t\t\t$this->debug(\"read chunk line of $tmplen bytes\");\r\n\t\t\t\tif ($tmplen == 0) {\r\n\t\t\t\t\t$this->incoming_payload = $data;\r\n\t\t\t\t\t$this->debug('socket read of chunk length timed out after length ' . strlen($data));\r\n\t\t\t\t\t$this->debug(\"read before timeout:\\n\" . $data);\r\n\t\t\t\t\t$this->setError('socket read of chunk length timed out');\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t$content_length = hexdec(trim($tmp));\r\n\t\t\t\t$this->debug(\"chunk length $content_length\");\r\n\t\t\t}\r\n\t\t\t$strlen = 0;\r\n\t\t    while (($strlen < $content_length) && (!feof($this->fp))) {\r\n\t\t    \t$readlen = min(8192, $content_length - $strlen);\r\n\t\t\t\t$tmp = fread($this->fp, $readlen);\r\n\t\t\t\t$tmplen = strlen($tmp);\r\n\t\t\t\t$this->debug(\"read buffer of $tmplen bytes\");\r\n\t\t\t\tif (($tmplen == 0) && (!feof($this->fp))) {\r\n\t\t\t\t\t$this->incoming_payload = $data;\r\n\t\t\t\t\t$this->debug('socket read of body timed out after length ' . strlen($data));\r\n\t\t\t\t\t$this->debug(\"read before timeout:\\n\" . $data);\r\n\t\t\t\t\t$this->setError('socket read of body timed out');\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t$strlen += $tmplen;\r\n\t\t\t\t$data .= $tmp;\r\n\t\t\t}\r\n\t\t\tif ($chunked && ($content_length > 0)) {\r\n\t\t\t\t$tmp = fgets($this->fp, 256);\r\n\t\t\t\t$tmplen = strlen($tmp);\r\n\t\t\t\t$this->debug(\"read chunk terminator of $tmplen bytes\");\r\n\t\t\t\tif ($tmplen == 0) {\r\n\t\t\t\t\t$this->incoming_payload = $data;\r\n\t\t\t\t\t$this->debug('socket read of chunk terminator timed out after length ' . strlen($data));\r\n\t\t\t\t\t$this->debug(\"read before timeout:\\n\" . $data);\r\n\t\t\t\t\t$this->setError('socket read of chunk terminator timed out');\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} while ($chunked && ($content_length > 0) && (!feof($this->fp)));\r\n\t\tif (feof($this->fp)) {\r\n\t\t\t$this->debug('read to EOF');\r\n\t\t}\r\n\t\t$this->debug('read body of length ' . strlen($data));\r\n\t\t$this->incoming_payload .= $data;\r\n\t\t$this->debug('received a total of '.strlen($this->incoming_payload).' bytes of data from server');\r\n\t\t\r\n\t\t// close filepointer\r\n\t\tif(\r\n\t\t\t(isset($this->incoming_headers['connection']) && strtolower($this->incoming_headers['connection']) == 'close') || \r\n\t\t\t(! $this->persistentConnection) || feof($this->fp)){\r\n\t\t\tfclose($this->fp);\r\n\t\t\t$this->fp = false;\r\n\t\t\t$this->debug('closed socket');\r\n\t\t}\r\n\t\t\r\n\t\t// connection was closed unexpectedly\r\n\t\tif($this->incoming_payload == ''){\r\n\t\t\t$this->setError('no response from server');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\t// decode transfer-encoding\r\n//\t\tif(isset($this->incoming_headers['transfer-encoding']) && strtolower($this->incoming_headers['transfer-encoding']) == 'chunked'){\r\n//\t\t\tif(!$data = $this->decodeChunked($data, $lb)){\r\n//\t\t\t\t$this->setError('Decoding of chunked data failed');\r\n//\t\t\t\treturn false;\r\n//\t\t\t}\r\n\t\t\t//print \"<pre>\\nde-chunked:\\n---------------\\n$data\\n\\n---------------\\n</pre>\";\r\n\t\t\t// set decoded payload\r\n//\t\t\t$this->incoming_payload = $header_data.$lb.$lb.$data;\r\n//\t\t}\r\n\t\r\n\t  } else if ($this->io_method() == 'curl') {\r\n\t\t// send and receive\r\n\t\t$this->debug('send and receive with cURL');\r\n\t\t$this->incoming_payload = curl_exec($this->ch);\r\n\t\t$data = $this->incoming_payload;\r\n\r\n        $cErr = curl_error($this->ch);\r\n\t\tif ($cErr != '') {\r\n        \t$err = 'cURL ERROR: '.curl_errno($this->ch).': '.$cErr.'<br>';\r\n        \t// TODO: there is a PHP bug that can cause this to SEGV for CURLINFO_CONTENT_TYPE\r\n\t\t\tforeach(curl_getinfo($this->ch) as $k => $v){\r\n\t\t\t\t$err .= \"$k: $v<br>\";\r\n\t\t\t}\r\n\t\t\t$this->debug($err);\r\n\t\t\t$this->setError($err);\r\n\t\t\tcurl_close($this->ch);\r\n\t    \treturn false;\r\n\t\t} else {\r\n\t\t\t//echo '<pre>';\r\n\t\t\t//var_dump(curl_getinfo($this->ch));\r\n\t\t\t//echo '</pre>';\r\n\t\t}\r\n\t\t// close curl\r\n\t\t$this->debug('No cURL error, closing cURL');\r\n\t\tcurl_close($this->ch);\r\n\t\t\r\n\t\t// try removing skippable headers\r\n\t\t$savedata = $data;\r\n\t\twhile ($this->isSkippableCurlHeader($data)) {\r\n\t\t\t$this->debug(\"Found HTTP header to skip\");\r\n\t\t\tif ($pos = strpos($data,\"\\r\\n\\r\\n\")) {\r\n\t\t\t\t$data = ltrim(substr($data,$pos));\r\n\t\t\t} elseif($pos = strpos($data,\"\\n\\n\") ) {\r\n\t\t\t\t$data = ltrim(substr($data,$pos));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ($data == '') {\r\n\t\t\t// have nothing left; just remove 100 header(s)\r\n\t\t\t$data = $savedata;\r\n\t\t\twhile (ereg('^HTTP/1.1 100',$data)) {\r\n\t\t\t\tif ($pos = strpos($data,\"\\r\\n\\r\\n\")) {\r\n\t\t\t\t\t$data = ltrim(substr($data,$pos));\r\n\t\t\t\t} elseif($pos = strpos($data,\"\\n\\n\") ) {\r\n\t\t\t\t\t$data = ltrim(substr($data,$pos));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// separate content from HTTP headers\r\n\t\tif ($pos = strpos($data,\"\\r\\n\\r\\n\")) {\r\n\t\t\t$lb = \"\\r\\n\";\r\n\t\t} elseif( $pos = strpos($data,\"\\n\\n\")) {\r\n\t\t\t$lb = \"\\n\";\r\n\t\t} else {\r\n\t\t\t$this->debug('no proper separation of headers and document');\r\n\t\t\t$this->setError('no proper separation of headers and document');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t$header_data = trim(substr($data,0,$pos));\r\n\t\t$header_array = explode($lb,$header_data);\r\n\t\t$data = ltrim(substr($data,$pos));\r\n\t\t$this->debug('found proper separation of headers and document');\r\n\t\t$this->debug('cleaned data, stringlen: '.strlen($data));\r\n\t\t// clean headers\r\n\t\tforeach ($header_array as $header_line) {\r\n\t\t\t$arr = explode(':',$header_line,2);\r\n\t\t\tif(count($arr) > 1){\r\n\t\t\t\t$header_name = strtolower(trim($arr[0]));\r\n\t\t\t\t$this->incoming_headers[$header_name] = trim($arr[1]);\r\n\t\t\t\tif ($header_name == 'set-cookie') {\r\n\t\t\t\t\t// TODO: allow multiple cookies from parseCookie\r\n\t\t\t\t\t$cookie = $this->parseCookie(trim($arr[1]));\r\n\t\t\t\t\tif ($cookie) {\r\n\t\t\t\t\t\t$this->incoming_cookies[] = $cookie;\r\n\t\t\t\t\t\t$this->debug('found cookie: ' . $cookie['name'] . ' = ' . $cookie['value']);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$this->debug('did not find cookie in ' . trim($arr[1]));\r\n\t\t\t\t\t}\r\n    \t\t\t}\r\n\t\t\t} else if (isset($header_name)) {\r\n\t\t\t\t// append continuation line to previous header\r\n\t\t\t\t$this->incoming_headers[$header_name] .= $lb . ' ' . $header_line;\r\n\t\t\t}\r\n\t\t}\r\n\t  }\r\n\r\n\t\t$this->response_status_line = $header_array[0];\r\n\t\t$arr = explode(' ', $this->response_status_line, 3);\r\n\t\t$http_version = $arr[0];\r\n\t\t$http_status = intval($arr[1]);\r\n\t\t$http_reason = count($arr) > 2 ? $arr[2] : '';\r\n\r\n \t\t// see if we need to resend the request with http digest authentication\r\n \t\tif (isset($this->incoming_headers['location']) && ($http_status == 301 || $http_status == 302)) {\r\n \t\t\t$this->debug(\"Got $http_status $http_reason with Location: \" . $this->incoming_headers['location']);\r\n \t\t\t$this->setURL($this->incoming_headers['location']);\r\n\t\t\t$this->tryagain = true;\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n \t\t// see if we need to resend the request with http digest authentication\r\n \t\tif (isset($this->incoming_headers['www-authenticate']) && $http_status == 401) {\r\n \t\t\t$this->debug(\"Got 401 $http_reason with WWW-Authenticate: \" . $this->incoming_headers['www-authenticate']);\r\n \t\t\tif (strstr($this->incoming_headers['www-authenticate'], \"Digest \")) {\r\n \t\t\t\t$this->debug('Server wants digest authentication');\r\n \t\t\t\t// remove \"Digest \" from our elements\r\n \t\t\t\t$digestString = str_replace('Digest ', '', $this->incoming_headers['www-authenticate']);\r\n \t\t\t\t\r\n \t\t\t\t// parse elements into array\r\n \t\t\t\t$digestElements = explode(',', $digestString);\r\n \t\t\t\tforeach ($digestElements as $val) {\r\n \t\t\t\t\t$tempElement = explode('=', trim($val), 2);\r\n \t\t\t\t\t$digestRequest[$tempElement[0]] = str_replace(\"\\\"\", '', $tempElement[1]);\r\n \t\t\t\t}\r\n\r\n\t\t\t\t// should have (at least) qop, realm, nonce\r\n \t\t\t\tif (isset($digestRequest['nonce'])) {\r\n \t\t\t\t\t$this->setCredentials($this->username, $this->password, 'digest', $digestRequest);\r\n \t\t\t\t\t$this->tryagain = true;\r\n \t\t\t\t\treturn false;\r\n \t\t\t\t}\r\n \t\t\t}\r\n\t\t\t$this->debug('HTTP authentication failed');\r\n\t\t\t$this->setError('HTTP authentication failed');\r\n\t\t\treturn false;\r\n \t\t}\r\n\t\t\r\n\t\tif (\r\n\t\t\t($http_status >= 300 && $http_status <= 307) ||\r\n\t\t\t($http_status >= 400 && $http_status <= 417) ||\r\n\t\t\t($http_status >= 501 && $http_status <= 505)\r\n\t\t   ) {\r\n\t\t\t$this->setError(\"Unsupported HTTP response status $http_status $http_reason (soapclient->response has contents of the response)\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// decode content-encoding\r\n\t\tif(isset($this->incoming_headers['content-encoding']) && $this->incoming_headers['content-encoding'] != ''){\r\n\t\t\tif(strtolower($this->incoming_headers['content-encoding']) == 'deflate' || strtolower($this->incoming_headers['content-encoding']) == 'gzip'){\r\n    \t\t\t// if decoding works, use it. else assume data wasn't gzencoded\r\n    \t\t\tif(function_exists('gzinflate')){\r\n\t\t\t\t\t//$timer->setMarker('starting decoding of gzip/deflated content');\r\n\t\t\t\t\t// IIS 5 requires gzinflate instead of gzuncompress (similar to IE 5 and gzdeflate v. gzcompress)\r\n\t\t\t\t\t// this means there are no Zlib headers, although there should be\r\n\t\t\t\t\t$this->debug('The gzinflate function exists');\r\n\t\t\t\t\t$datalen = strlen($data);\r\n\t\t\t\t\tif ($this->incoming_headers['content-encoding'] == 'deflate') {\r\n\t\t\t\t\t\tif ($degzdata = @gzinflate($data)) {\r\n\t    \t\t\t\t\t$data = $degzdata;\r\n\t    \t\t\t\t\t$this->debug('The payload has been inflated to ' . strlen($data) . ' bytes');\r\n\t    \t\t\t\t\tif (strlen($data) < $datalen) {\r\n\t    \t\t\t\t\t\t// test for the case that the payload has been compressed twice\r\n\t\t    \t\t\t\t\t$this->debug('The inflated payload is smaller than the gzipped one; try again');\r\n\t\t\t\t\t\t\t\tif ($degzdata = @gzinflate($data)) {\r\n\t\t\t    \t\t\t\t\t$data = $degzdata;\r\n\t\t\t    \t\t\t\t\t$this->debug('The payload has been inflated again to ' . strlen($data) . ' bytes');\r\n\t\t\t\t\t\t\t\t}\r\n\t    \t\t\t\t\t}\r\n\t    \t\t\t\t} else {\r\n\t    \t\t\t\t\t$this->debug('Error using gzinflate to inflate the payload');\r\n\t    \t\t\t\t\t$this->setError('Error using gzinflate to inflate the payload');\r\n\t    \t\t\t\t}\r\n\t\t\t\t\t} elseif ($this->incoming_headers['content-encoding'] == 'gzip') {\r\n\t\t\t\t\t\tif ($degzdata = @gzinflate(substr($data, 10))) {\t// do our best\r\n\t\t\t\t\t\t\t$data = $degzdata;\r\n\t    \t\t\t\t\t$this->debug('The payload has been un-gzipped to ' . strlen($data) . ' bytes');\r\n\t    \t\t\t\t\tif (strlen($data) < $datalen) {\r\n\t    \t\t\t\t\t\t// test for the case that the payload has been compressed twice\r\n\t\t    \t\t\t\t\t$this->debug('The un-gzipped payload is smaller than the gzipped one; try again');\r\n\t\t\t\t\t\t\t\tif ($degzdata = @gzinflate(substr($data, 10))) {\r\n\t\t\t    \t\t\t\t\t$data = $degzdata;\r\n\t\t\t    \t\t\t\t\t$this->debug('The payload has been un-gzipped again to ' . strlen($data) . ' bytes');\r\n\t\t\t\t\t\t\t\t}\r\n\t    \t\t\t\t\t}\r\n\t    \t\t\t\t} else {\r\n\t    \t\t\t\t\t$this->debug('Error using gzinflate to un-gzip the payload');\r\n\t\t\t\t\t\t\t$this->setError('Error using gzinflate to un-gzip the payload');\r\n\t    \t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//$timer->setMarker('finished decoding of gzip/deflated content');\r\n\t\t\t\t\t//print \"<xmp>\\nde-inflated:\\n---------------\\n$data\\n-------------\\n</xmp>\";\r\n\t\t\t\t\t// set decoded payload\r\n\t\t\t\t\t$this->incoming_payload = $header_data.$lb.$lb.$data;\r\n    \t\t\t} else {\r\n\t\t\t\t\t$this->debug('The server sent compressed data. Your php install must have the Zlib extension compiled in to support this.');\r\n\t\t\t\t\t$this->setError('The server sent compressed data. Your php install must have the Zlib extension compiled in to support this.');\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t$this->debug('Unsupported Content-Encoding ' . $this->incoming_headers['content-encoding']);\r\n\t\t\t\t$this->setError('Unsupported Content-Encoding ' . $this->incoming_headers['content-encoding']);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t$this->debug('No Content-Encoding header');\r\n\t\t}\r\n\t\t\r\n\t\tif(strlen($data) == 0){\r\n\t\t\t$this->debug('no data after headers!');\r\n\t\t\t$this->setError('no data present after HTTP headers');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\treturn $data;\r\n\t}\r\n\r\n\t/**\r\n\t * sets the content-type for the SOAP message to be sent\r\n\t *\r\n\t * @param\tstring $type the content type, MIME style\r\n\t * @param\tmixed $charset character set used for encoding (or false)\r\n\t * @access\tpublic\r\n\t */\r\n\tfunction setContentType($type, $charset = false) {\r\n\t\t$this->setHeader('Content-Type', $type . ($charset ? '; charset=' . $charset : ''));\r\n\t}\r\n\r\n\t/**\r\n\t * specifies that an HTTP persistent connection should be used\r\n\t *\r\n\t * @return\tboolean whether the request was honored by this method.\r\n\t * @access\tpublic\r\n\t */\r\n\tfunction usePersistentConnection(){\r\n\t\tif (isset($this->outgoing_headers['Accept-Encoding'])) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t$this->protocol_version = '1.1';\r\n\t\t$this->persistentConnection = true;\r\n\t\t$this->setHeader('Connection', 'Keep-Alive');\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * parse an incoming Cookie into it's parts\r\n\t *\r\n\t * @param\tstring $cookie_str content of cookie\r\n\t * @return\tarray with data of that cookie\r\n\t * @access\tprivate\r\n\t */\r\n\t/*\r\n\t * TODO: allow a Set-Cookie string to be parsed into multiple cookies\r\n\t */\r\n\tfunction parseCookie($cookie_str) {\r\n\t\t$cookie_str = str_replace('; ', ';', $cookie_str) . ';';\r\n\t\t$data = split(';', $cookie_str);\r\n\t\t$value_str = $data[0];\r\n\r\n\t\t$cookie_param = 'domain=';\r\n\t\t$start = strpos($cookie_str, $cookie_param);\r\n\t\tif ($start > 0) {\r\n\t\t\t$domain = substr($cookie_str, $start + strlen($cookie_param));\r\n\t\t\t$domain = substr($domain, 0, strpos($domain, ';'));\r\n\t\t} else {\r\n\t\t\t$domain = '';\r\n\t\t}\r\n\r\n\t\t$cookie_param = 'expires=';\r\n\t\t$start = strpos($cookie_str, $cookie_param);\r\n\t\tif ($start > 0) {\r\n\t\t\t$expires = substr($cookie_str, $start + strlen($cookie_param));\r\n\t\t\t$expires = substr($expires, 0, strpos($expires, ';'));\r\n\t\t} else {\r\n\t\t\t$expires = '';\r\n\t\t}\r\n\r\n\t\t$cookie_param = 'path=';\r\n\t\t$start = strpos($cookie_str, $cookie_param);\r\n\t\tif ( $start > 0 ) {\r\n\t\t\t$path = substr($cookie_str, $start + strlen($cookie_param));\r\n\t\t\t$path = substr($path, 0, strpos($path, ';'));\r\n\t\t} else {\r\n\t\t\t$path = '/';\r\n\t\t}\r\n\t\t\t\t\t\t\r\n\t\t$cookie_param = ';secure;';\r\n\t\tif (strpos($cookie_str, $cookie_param) !== FALSE) {\r\n\t\t\t$secure = true;\r\n\t\t} else {\r\n\t\t\t$secure = false;\r\n\t\t}\r\n\r\n\t\t$sep_pos = strpos($value_str, '=');\r\n\r\n\t\tif ($sep_pos) {\r\n\t\t\t$name = substr($value_str, 0, $sep_pos);\r\n\t\t\t$value = substr($value_str, $sep_pos + 1);\r\n\t\t\t$cookie= array(\t'name' => $name,\r\n\t\t\t                'value' => $value,\r\n\t\t\t\t\t\t\t'domain' => $domain,\r\n\t\t\t\t\t\t\t'path' => $path,\r\n\t\t\t\t\t\t\t'expires' => $expires,\r\n\t\t\t\t\t\t\t'secure' => $secure\r\n\t\t\t\t\t\t\t);\t\t\r\n\t\t\treturn $cookie;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n  \r\n\t/**\r\n\t * sort out cookies for the current request\r\n\t *\r\n\t * @param\tarray $cookies array with all cookies\r\n\t * @param\tboolean $secure is the send-content secure or not?\r\n\t * @return\tstring for Cookie-HTTP-Header\r\n\t * @access\tprivate\r\n\t */\r\n\tfunction getCookiesForRequest($cookies, $secure=false) {\r\n\t\t$cookie_str = '';\r\n\t\tif ((! is_null($cookies)) && (is_array($cookies))) {\r\n\t\t\tforeach ($cookies as $cookie) {\r\n\t\t\t\tif (! is_array($cookie)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t    \t\t$this->debug(\"check cookie for validity: \".$cookie['name'].'='.$cookie['value']);\r\n\t\t\t\tif ((isset($cookie['expires'])) && (! empty($cookie['expires']))) {\r\n\t\t\t\t\tif (strtotime($cookie['expires']) <= time()) {\r\n\t\t\t\t\t\t$this->debug('cookie has expired');\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif ((isset($cookie['domain'])) && (! empty($cookie['domain']))) {\r\n\t\t\t\t\t$domain = preg_quote($cookie['domain']);\r\n\t\t\t\t\tif (! preg_match(\"'.*$domain$'i\", $this->host)) {\r\n\t\t\t\t\t\t$this->debug('cookie has different domain');\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif ((isset($cookie['path'])) && (! empty($cookie['path']))) {\r\n\t\t\t\t\t$path = preg_quote($cookie['path']);\r\n\t\t\t\t\tif (! preg_match(\"'^$path.*'i\", $this->path)) {\r\n\t\t\t\t\t\t$this->debug('cookie is for a different path');\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif ((! $secure) && (isset($cookie['secure'])) && ($cookie['secure'])) {\r\n\t\t\t\t\t$this->debug('cookie is secure, transport is not');\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t$cookie_str .= $cookie['name'] . '=' . $cookie['value'] . '; ';\r\n\t    \t\t$this->debug('add cookie to Cookie-String: ' . $cookie['name'] . '=' . $cookie['value']);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn $cookie_str;\r\n  }\r\n}\r\n\r\n?><?php\r\n\r\n\r\n\r\n/**\r\n*\r\n* nusoap_server allows the user to create a SOAP server\r\n* that is capable of receiving messages and returning responses\r\n*\r\n* @author   Dietrich Ayala <dietrich@ganx4.com>\r\n* @author   Scott Nichol <snichol@users.sourceforge.net>\r\n* @version  $Id: nusoap.php,v 1.114 2007/11/06 15:17:46 snichol Exp $\r\n* @access   public\r\n*/\r\nclass nusoap_server extends nusoap_base {\r\n\t/**\r\n\t * HTTP headers of request\r\n\t * @var array\r\n\t * @access private\r\n\t */\r\n\tvar $headers = array();\r\n\t/**\r\n\t * HTTP request\r\n\t * @var string\r\n\t * @access private\r\n\t */\r\n\tvar $request = '';\r\n\t/**\r\n\t * SOAP headers from request (incomplete namespace resolution; special characters not escaped) (text)\r\n\t * @var string\r\n\t * @access public\r\n\t */\r\n\tvar $requestHeaders = '';\r\n\t/**\r\n\t * SOAP Headers from request (parsed)\r\n\t * @var mixed\r\n\t * @access public\r\n\t */\r\n\tvar $requestHeader = NULL;\r\n\t/**\r\n\t * SOAP body request portion (incomplete namespace resolution; special characters not escaped) (text)\r\n\t * @var string\r\n\t * @access public\r\n\t */\r\n\tvar $document = '';\r\n\t/**\r\n\t * SOAP payload for request (text)\r\n\t * @var string\r\n\t * @access public\r\n\t */\r\n\tvar $requestSOAP = '';\r\n\t/**\r\n\t * requested method namespace URI\r\n\t * @var string\r\n\t * @access private\r\n\t */\r\n\tvar $methodURI = '';\r\n\t/**\r\n\t * name of method requested\r\n\t * @var string\r\n\t * @access private\r\n\t */\r\n\tvar $methodname = '';\r\n\t/**\r\n\t * method parameters from request\r\n\t * @var array\r\n\t * @access private\r\n\t */\r\n\tvar $methodparams = array();\r\n\t/**\r\n\t * SOAP Action from request\r\n\t * @var string\r\n\t * @access private\r\n\t */\r\n\tvar $SOAPAction = '';\r\n\t/**\r\n\t * character set encoding of incoming (request) messages\r\n\t * @var string\r\n\t * @access public\r\n\t */\r\n\tvar $xml_encoding = '';\r\n\t/**\r\n\t * toggles whether the parser decodes element content w/ utf8_decode()\r\n\t * @var boolean\r\n\t * @access public\r\n\t */\r\n    var $decode_utf8 = true;\r\n\r\n\t/**\r\n\t * HTTP headers of response\r\n\t * @var array\r\n\t * @access public\r\n\t */\r\n\tvar $outgoing_headers = array();\r\n\t/**\r\n\t * HTTP response\r\n\t * @var string\r\n\t * @access private\r\n\t */\r\n\tvar $response = '';\r\n\t/**\r\n\t * SOAP headers for response (text or array of soapval or associative array)\r\n\t * @var mixed\r\n\t * @access public\r\n\t */\r\n\tvar $responseHeaders = '';\r\n\t/**\r\n\t * SOAP payload for response (text)\r\n\t * @var string\r\n\t * @access private\r\n\t */\r\n\tvar $responseSOAP = '';\r\n\t/**\r\n\t * method return value to place in response\r\n\t * @var mixed\r\n\t * @access private\r\n\t */\r\n\tvar $methodreturn = false;\r\n\t/**\r\n\t * whether $methodreturn is a string of literal XML\r\n\t * @var boolean\r\n\t * @access public\r\n\t */\r\n\tvar $methodreturnisliteralxml = false;\r\n\t/**\r\n\t * SOAP fault for response (or false)\r\n\t * @var mixed\r\n\t * @access private\r\n\t */\r\n\tvar $fault = false;\r\n\t/**\r\n\t * text indication of result (for debugging)\r\n\t * @var string\r\n\t * @access private\r\n\t */\r\n\tvar $result = 'successful';\r\n\r\n\t/**\r\n\t * assoc array of operations => opData; operations are added by the register()\r\n\t * method or by parsing an external WSDL definition\r\n\t * @var array\r\n\t * @access private\r\n\t */\r\n\tvar $operations = array();\r\n\t/**\r\n\t * wsdl instance (if one)\r\n\t * @var mixed\r\n\t * @access private\r\n\t */\r\n\tvar $wsdl = false;\r\n\t/**\r\n\t * URL for WSDL (if one)\r\n\t * @var mixed\r\n\t * @access private\r\n\t */\r\n\tvar $externalWSDLURL = false;\r\n\t/**\r\n\t * whether to append debug to response as XML comment\r\n\t * @var boolean\r\n\t * @access public\r\n\t */\r\n\tvar $debug_flag = false;\r\n\r\n\r\n\t/**\r\n\t* constructor\r\n    * the optional parameter is a path to a WSDL file that you'd like to bind the server instance to.\r\n\t*\r\n    * @param mixed $wsdl file path or URL (string), or wsdl instance (object)\r\n\t* @access   public\r\n\t*/\r\n\tfunction nusoap_server($wsdl=false){\r\n\t\tparent::nusoap_base();\r\n\t\t// turn on debugging?\r\n\t\tglobal $debug;\r\n\t\tglobal $HTTP_SERVER_VARS;\r\n\r\n\t\tif (isset($_SERVER)) {\r\n\t\t\t$this->debug(\"_SERVER is defined:\");\r\n\t\t\t$this->appendDebug($this->varDump($_SERVER));\r\n\t\t} elseif (isset($HTTP_SERVER_VARS)) {\r\n\t\t\t$this->debug(\"HTTP_SERVER_VARS is defined:\");\r\n\t\t\t$this->appendDebug($this->varDump($HTTP_SERVER_VARS));\r\n\t\t} else {\r\n\t\t\t$this->debug(\"Neither _SERVER nor HTTP_SERVER_VARS is defined.\");\r\n\t\t}\r\n\r\n\t\tif (isset($debug)) {\r\n\t\t\t$this->debug(\"In nusoap_server, set debug_flag=$debug based on global flag\");\r\n\t\t\t$this->debug_flag = $debug;\r\n\t\t} elseif (isset($_SERVER['QUERY_STRING'])) {\r\n\t\t\t$qs = explode('&', $_SERVER['QUERY_STRING']);\r\n\t\t\tforeach ($qs as $v) {\r\n\t\t\t\tif (substr($v, 0, 6) == 'debug=') {\r\n\t\t\t\t\t$this->debug(\"In nusoap_server, set debug_flag=\" . substr($v, 6) . \" based on query string #1\");\r\n\t\t\t\t\t$this->debug_flag = substr($v, 6);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} elseif (isset($HTTP_SERVER_VARS['QUERY_STRING'])) {\r\n\t\t\t$qs = explode('&', $HTTP_SERVER_VARS['QUERY_STRING']);\r\n\t\t\tforeach ($qs as $v) {\r\n\t\t\t\tif (substr($v, 0, 6) == 'debug=') {\r\n\t\t\t\t\t$this->debug(\"In nusoap_server, set debug_flag=\" . substr($v, 6) . \" based on query string #2\");\r\n\t\t\t\t\t$this->debug_flag = substr($v, 6);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// wsdl\r\n\t\tif($wsdl){\r\n\t\t\t$this->debug(\"In nusoap_server, WSDL is specified\");\r\n\t\t\tif (is_object($wsdl) && (get_class($wsdl) == 'wsdl')) {\r\n\t\t\t\t$this->wsdl = $wsdl;\r\n\t\t\t\t$this->externalWSDLURL = $this->wsdl->wsdl;\r\n\t\t\t\t$this->debug('Use existing wsdl instance from ' . $this->externalWSDLURL);\r\n\t\t\t} else {\r\n\t\t\t\t$this->debug('Create wsdl from ' . $wsdl);\r\n\t\t\t\t$this->wsdl = new wsdl($wsdl);\r\n\t\t\t\t$this->externalWSDLURL = $wsdl;\r\n\t\t\t}\r\n\t\t\t$this->appendDebug($this->wsdl->getDebug());\r\n\t\t\t$this->wsdl->clearDebug();\r\n\t\t\tif($err = $this->wsdl->getError()){\r\n\t\t\t\tdie('WSDL ERROR: '.$err);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* processes request and returns response\r\n\t*\r\n\t* @param    string $data usually is the value of $HTTP_RAW_POST_DATA\r\n\t* @access   public\r\n\t*/\r\n\tfunction service($data){\r\n\t\tglobal $HTTP_SERVER_VARS;\r\n\r\n\t\tif (isset($_SERVER['QUERY_STRING'])) {\r\n\t\t\t$qs = $_SERVER['QUERY_STRING'];\r\n\t\t} elseif (isset($HTTP_SERVER_VARS['QUERY_STRING'])) {\r\n\t\t\t$qs = $HTTP_SERVER_VARS['QUERY_STRING'];\r\n\t\t} else {\r\n\t\t\t$qs = '';\r\n\t\t}\r\n\t\t$this->debug(\"In service, query string=$qs\");\r\n\r\n\t\tif (ereg('wsdl', $qs) ){\r\n\t\t\t$this->debug(\"In service, this is a request for WSDL\");\r\n\t\t\tif($this->externalWSDLURL){\r\n              if (strpos($this->externalWSDLURL,\"://\")!==false) { // assume URL\r\n\t\t\t\theader('Location: '.$this->externalWSDLURL);\r\n              } else { // assume file\r\n                header(\"Content-Type: text/xml\\r\\n\");\r\n                $fp = fopen($this->externalWSDLURL, 'r');\r\n                fpassthru($fp);\r\n              }\r\n\t\t\t} elseif ($this->wsdl) {\r\n\t\t\t\theader(\"Content-Type: text/xml; charset=ISO-8859-1\\r\\n\");\r\n\t\t\t\tprint $this->wsdl->serialize($this->debug_flag);\r\n\t\t\t\tif ($this->debug_flag) {\r\n\t\t\t\t\t$this->debug('wsdl:');\r\n\t\t\t\t\t$this->appendDebug($this->varDump($this->wsdl));\r\n\t\t\t\t\tprint $this->getDebugAsXMLComment();\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\theader(\"Content-Type: text/html; charset=ISO-8859-1\\r\\n\");\r\n\t\t\t\tprint \"This service does not provide WSDL\";\r\n\t\t\t}\r\n\t\t} elseif ($data == '' && $this->wsdl) {\r\n\t\t\t$this->debug(\"In service, there is no data, so return Web description\");\r\n\t\t\tprint $this->wsdl->webDescription();\r\n\t\t} else {\r\n\t\t\t$this->debug(\"In service, invoke the request\");\r\n\t\t\t$this->parse_request($data);\r\n\t\t\tif (! $this->fault) {\r\n\t\t\t\t$this->invoke_method();\r\n\t\t\t}\r\n\t\t\tif (! $this->fault) {\r\n\t\t\t\t$this->serialize_return();\r\n\t\t\t}\r\n\t\t\t$this->send_response();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* parses HTTP request headers.\r\n\t*\r\n\t* The following fields are set by this function (when successful)\r\n\t*\r\n\t* headers\r\n\t* request\r\n\t* xml_encoding\r\n\t* SOAPAction\r\n\t*\r\n\t* @access   private\r\n\t*/\r\n\tfunction parse_http_headers() {\r\n\t\tglobal $HTTP_SERVER_VARS;\r\n\r\n\t\t$this->request = '';\r\n\t\t$this->SOAPAction = '';\r\n\t\tif(function_exists('getallheaders')){\r\n\t\t\t$this->debug(\"In parse_http_headers, use getallheaders\");\r\n\t\t\t$headers = getallheaders();\r\n\t\t\tforeach($headers as $k=>$v){\r\n\t\t\t\t$k = strtolower($k);\r\n\t\t\t\t$this->headers[$k] = $v;\r\n\t\t\t\t$this->request .= \"$k: $v\\r\\n\";\r\n\t\t\t\t$this->debug(\"$k: $v\");\r\n\t\t\t}\r\n\t\t\t// get SOAPAction header\r\n\t\t\tif(isset($this->headers['soapaction'])){\r\n\t\t\t\t$this->SOAPAction = str_replace('\"','',$this->headers['soapaction']);\r\n\t\t\t}\r\n\t\t\t// get the character encoding of the incoming request\r\n\t\t\tif(isset($this->headers['content-type']) && strpos($this->headers['content-type'],'=')){\r\n\t\t\t\t$enc = str_replace('\"','',substr(strstr($this->headers[\"content-type\"],'='),1));\r\n\t\t\t\tif(eregi('^(ISO-8859-1|US-ASCII|UTF-8)$',$enc)){\r\n\t\t\t\t\t$this->xml_encoding = strtoupper($enc);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$this->xml_encoding = 'US-ASCII';\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1\r\n\t\t\t\t$this->xml_encoding = 'ISO-8859-1';\r\n\t\t\t}\r\n\t\t} elseif(isset($_SERVER) && is_array($_SERVER)){\r\n\t\t\t$this->debug(\"In parse_http_headers, use _SERVER\");\r\n\t\t\tforeach ($_SERVER as $k => $v) {\r\n\t\t\t\tif (substr($k, 0, 5) == 'HTTP_') {\r\n\t\t\t\t\t$k = str_replace(' ', '-', strtolower(str_replace('_', ' ', substr($k, 5))));\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$k = str_replace(' ', '-', strtolower(str_replace('_', ' ', $k)));\r\n\t\t\t\t}\r\n\t\t\t\tif ($k == 'soapaction') {\r\n\t\t\t\t\t// get SOAPAction header\r\n\t\t\t\t\t$k = 'SOAPAction';\r\n\t\t\t\t\t$v = str_replace('\"', '', $v);\r\n\t\t\t\t\t$v = str_replace('\\\\', '', $v);\r\n\t\t\t\t\t$this->SOAPAction = $v;\r\n\t\t\t\t} else if ($k == 'content-type') {\r\n\t\t\t\t\t// get the character encoding of the incoming request\r\n\t\t\t\t\tif (strpos($v, '=')) {\r\n\t\t\t\t\t\t$enc = substr(strstr($v, '='), 1);\r\n\t\t\t\t\t\t$enc = str_replace('\"', '', $enc);\r\n\t\t\t\t\t\t$enc = str_replace('\\\\', '', $enc);\r\n\t\t\t\t\t\tif (eregi('^(ISO-8859-1|US-ASCII|UTF-8)$', $enc)) {\r\n\t\t\t\t\t\t\t$this->xml_encoding = strtoupper($enc);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t$this->xml_encoding = 'US-ASCII';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1\r\n\t\t\t\t\t\t$this->xml_encoding = 'ISO-8859-1';\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t$this->headers[$k] = $v;\r\n\t\t\t\t$this->request .= \"$k: $v\\r\\n\";\r\n\t\t\t\t$this->debug(\"$k: $v\");\r\n\t\t\t}\r\n\t\t} elseif (is_array($HTTP_SERVER_VARS)) {\r\n\t\t\t$this->debug(\"In parse_http_headers, use HTTP_SERVER_VARS\");\r\n\t\t\tforeach ($HTTP_SERVER_VARS as $k => $v) {\r\n\t\t\t\tif (substr($k, 0, 5) == 'HTTP_') {\r\n\t\t\t\t\t$k = str_replace(' ', '-', strtolower(str_replace('_', ' ', substr($k, 5)))); \t                                         $k = strtolower(substr($k, 5));\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$k = str_replace(' ', '-', strtolower(str_replace('_', ' ', $k))); \t                                         $k = strtolower($k);\r\n\t\t\t\t}\r\n\t\t\t\tif ($k == 'soapaction') {\r\n\t\t\t\t\t// get SOAPAction header\r\n\t\t\t\t\t$k = 'SOAPAction';\r\n\t\t\t\t\t$v = str_replace('\"', '', $v);\r\n\t\t\t\t\t$v = str_replace('\\\\', '', $v);\r\n\t\t\t\t\t$this->SOAPAction = $v;\r\n\t\t\t\t} else if ($k == 'content-type') {\r\n\t\t\t\t\t// get the character encoding of the incoming request\r\n\t\t\t\t\tif (strpos($v, '=')) {\r\n\t\t\t\t\t\t$enc = substr(strstr($v, '='), 1);\r\n\t\t\t\t\t\t$enc = str_replace('\"', '', $enc);\r\n\t\t\t\t\t\t$enc = str_replace('\\\\', '', $enc);\r\n\t\t\t\t\t\tif (eregi('^(ISO-8859-1|US-ASCII|UTF-8)$', $enc)) {\r\n\t\t\t\t\t\t\t$this->xml_encoding = strtoupper($enc);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t$this->xml_encoding = 'US-ASCII';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1\r\n\t\t\t\t\t\t$this->xml_encoding = 'ISO-8859-1';\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t$this->headers[$k] = $v;\r\n\t\t\t\t$this->request .= \"$k: $v\\r\\n\";\r\n\t\t\t\t$this->debug(\"$k: $v\");\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t$this->debug(\"In parse_http_headers, HTTP headers not accessible\");\r\n\t\t\t$this->setError(\"HTTP headers not accessible\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* parses a request\r\n\t*\r\n\t* The following fields are set by this function (when successful)\r\n\t*\r\n\t* headers\r\n\t* request\r\n\t* xml_encoding\r\n\t* SOAPAction\r\n\t* request\r\n\t* requestSOAP\r\n\t* methodURI\r\n\t* methodname\r\n\t* methodparams\r\n\t* requestHeaders\r\n\t* document\r\n\t*\r\n\t* This sets the fault field on error\r\n\t*\r\n\t* @param    string $data XML string\r\n\t* @access   private\r\n\t*/\r\n\tfunction parse_request($data='') {\r\n\t\t$this->debug('entering parse_request()');\r\n\t\t$this->parse_http_headers();\r\n\t\t$this->debug('got character encoding: '.$this->xml_encoding);\r\n\t\t// uncompress if necessary\r\n\t\tif (isset($this->headers['content-encoding']) && $this->headers['content-encoding'] != '') {\r\n\t\t\t$this->debug('got content encoding: ' . $this->headers['content-encoding']);\r\n\t\t\tif ($this->headers['content-encoding'] == 'deflate' || $this->headers['content-encoding'] == 'gzip') {\r\n\t\t    \t// if decoding works, use it. else assume data wasn't gzencoded\r\n\t\t\t\tif (function_exists('gzuncompress')) {\r\n\t\t\t\t\tif ($this->headers['content-encoding'] == 'deflate' && $degzdata = @gzuncompress($data)) {\r\n\t\t\t\t\t\t$data = $degzdata;\r\n\t\t\t\t\t} elseif ($this->headers['content-encoding'] == 'gzip' && $degzdata = gzinflate(substr($data, 10))) {\r\n\t\t\t\t\t\t$data = $degzdata;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$this->fault('SOAP-ENV:Client', 'Errors occurred when trying to decode the data');\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$this->fault('SOAP-ENV:Client', 'This Server does not support compressed data');\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t$this->request .= \"\\r\\n\".$data;\r\n\t\t$data = $this->parseRequest($this->headers, $data);\r\n\t\t$this->requestSOAP = $data;\r\n\t\t$this->debug('leaving parse_request');\r\n\t}\r\n\r\n\t/**\r\n\t* invokes a PHP function for the requested SOAP method\r\n\t*\r\n\t* The following fields are set by this function (when successful)\r\n\t*\r\n\t* methodreturn\r\n\t*\r\n\t* Note that the PHP function that is called may also set the following\r\n\t* fields to affect the response sent to the client\r\n\t*\r\n\t* responseHeaders\r\n\t* outgoing_headers\r\n\t*\r\n\t* This sets the fault field on error\r\n\t*\r\n\t* @access   private\r\n\t*/\r\n\tfunction invoke_method() {\r\n\t\t$this->debug('in invoke_method, methodname=' . $this->methodname . ' methodURI=' . $this->methodURI . ' SOAPAction=' . $this->SOAPAction);\r\n\r\n\t\tif ($this->wsdl) {\r\n\t\t\tif ($this->opData = $this->wsdl->getOperationData($this->methodname)) {\r\n\t\t\t\t$this->debug('in invoke_method, found WSDL operation=' . $this->methodname);\r\n\t\t\t\t$this->appendDebug('opData=' . $this->varDump($this->opData));\r\n\t\t\t} elseif ($this->opData = $this->wsdl->getOperationDataForSoapAction($this->SOAPAction)) {\r\n\t\t\t\t// Note: hopefully this case will only be used for doc/lit, since rpc services should have wrapper element\r\n\t\t\t\t$this->debug('in invoke_method, found WSDL soapAction=' . $this->SOAPAction . ' for operation=' . $this->opData['name']);\r\n\t\t\t\t$this->appendDebug('opData=' . $this->varDump($this->opData));\r\n\t\t\t\t$this->methodname = $this->opData['name'];\r\n\t\t\t} else {\r\n\t\t\t\t$this->debug('in invoke_method, no WSDL for operation=' . $this->methodname);\r\n\t\t\t\t$this->fault('SOAP-ENV:Client', \"Operation '\" . $this->methodname . \"' is not defined in the WSDL for this service\");\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t$this->debug('in invoke_method, no WSDL to validate method');\r\n\t\t}\r\n\r\n\t\t// if a . is present in $this->methodname, we see if there is a class in scope,\r\n\t\t// which could be referred to. We will also distinguish between two deliminators,\r\n\t\t// to allow methods to be called a the class or an instance\r\n\t\t$class = '';\r\n\t\t$method = '';\r\n\t\tif (strpos($this->methodname, '..') > 0) {\r\n\t\t\t$delim = '..';\r\n\t\t} else if (strpos($this->methodname, '.') > 0) {\r\n\t\t\t$delim = '.';\r\n\t\t} else {\r\n\t\t\t$delim = '';\r\n\t\t}\r\n\r\n\t\tif (strlen($delim) > 0 && substr_count($this->methodname, $delim) == 1 &&\r\n\t\t\tclass_exists(substr($this->methodname, 0, strpos($this->methodname, $delim)))) {\r\n\t\t\t// get the class and method name\r\n\t\t\t$class = substr($this->methodname, 0, strpos($this->methodname, $delim));\r\n\t\t\t$method = substr($this->methodname, strpos($this->methodname, $delim) + strlen($delim));\r\n\t\t\t$this->debug(\"in invoke_method, class=$class method=$method delim=$delim\");\r\n\t\t}\r\n\r\n\t\t// does method exist?\r\n\t\tif ($class == '') {\r\n\t\t\tif (!function_exists($this->methodname)) {\r\n\t\t\t\t$this->debug(\"in invoke_method, function '$this->methodname' not found!\");\r\n\t\t\t\t$this->result = 'fault: method not found';\r\n\t\t\t\t$this->fault('SOAP-ENV:Client',\"method '$this->methodname' not defined in service\");\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t$method_to_compare = (substr(phpversion(), 0, 2) == '4.') ? strtolower($method) : $method;\r\n\t\t\tif (!in_array($method_to_compare, get_class_methods($class))) {\r\n\t\t\t\t$this->debug(\"in invoke_method, method '$this->methodname' not found in class '$class'!\");\r\n\t\t\t\t$this->result = 'fault: method not found';\r\n\t\t\t\t$this->fault('SOAP-ENV:Client',\"method '$this->methodname' not defined in service\");\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// evaluate message, getting back parameters\r\n\t\t// verify that request parameters match the method's signature\r\n\t\tif(! $this->verify_method($this->methodname,$this->methodparams)){\r\n\t\t\t// debug\r\n\t\t\t$this->debug('ERROR: request not verified against method signature');\r\n\t\t\t$this->result = 'fault: request failed validation against method signature';\r\n\t\t\t// return fault\r\n\t\t\t$this->fault('SOAP-ENV:Client',\"Operation '$this->methodname' not defined in service.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// if there are parameters to pass\r\n\t\t$this->debug('in invoke_method, params:');\r\n\t\t$this->appendDebug($this->varDump($this->methodparams));\r\n\t\t$this->debug(\"in invoke_method, calling '$this->methodname'\");\r\n\t\tif (!function_exists('call_user_func_array')) {\r\n\t\t\tif ($class == '') {\r\n\t\t\t\t$this->debug('in invoke_method, calling function using eval()');\r\n\t\t\t\t$funcCall = \"\\$this->methodreturn = $this->methodname(\";\r\n\t\t\t} else {\r\n\t\t\t\tif ($delim == '..') {\r\n\t\t\t\t\t$this->debug('in invoke_method, calling class method using eval()');\r\n\t\t\t\t\t$funcCall = \"\\$this->methodreturn = \".$class.\"::\".$method.\"(\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$this->debug('in invoke_method, calling instance method using eval()');\r\n\t\t\t\t\t// generate unique instance name\r\n\t\t\t\t\t$instname = \"\\$inst_\".time();\r\n\t\t\t\t\t$funcCall = $instname.\" = new \".$class.\"(); \";\r\n\t\t\t\t\t$funcCall .= \"\\$this->methodreturn = \".$instname.\"->\".$method.\"(\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif ($this->methodparams) {\r\n\t\t\t\tforeach ($this->methodparams as $param) {\r\n\t\t\t\t\tif (is_array($param) || is_object($param)) {\r\n\t\t\t\t\t\t$this->fault('SOAP-ENV:Client', 'NuSOAP does not handle complexType parameters correctly when using eval; call_user_func_array must be available');\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$funcCall .= \"\\\"$param\\\",\";\r\n\t\t\t\t}\r\n\t\t\t\t$funcCall = substr($funcCall, 0, -1);\r\n\t\t\t}\r\n\t\t\t$funcCall .= ');';\r\n\t\t\t$this->debug('in invoke_method, function call: '.$funcCall);\r\n\t\t\t@eval($funcCall);\r\n\t\t} else {\r\n\t\t\tif ($class == '') {\r\n\t\t\t\t$this->debug('in invoke_method, calling function using call_user_func_array()');\r\n\t\t\t\t$call_arg = \"$this->methodname\";\t// straight assignment changes $this->methodname to lower case after call_user_func_array()\r\n\t\t\t} elseif ($delim == '..') {\r\n\t\t\t\t$this->debug('in invoke_method, calling class method using call_user_func_array()');\r\n\t\t\t\t$call_arg = array ($class, $method);\r\n\t\t\t} else {\r\n\t\t\t\t$this->debug('in invoke_method, calling instance method using call_user_func_array()');\r\n\t\t\t\t$instance = new $class ();\r\n\t\t\t\t$call_arg = array(&$instance, $method);\r\n\t\t\t}\r\n\t\t\tif (is_array($this->methodparams)) {\r\n\t\t\t\t$this->methodreturn = call_user_func_array($call_arg, array_values($this->methodparams));\r\n\t\t\t} else {\r\n\t\t\t\t$this->methodreturn = call_user_func_array($call_arg, array());\r\n\t\t\t}\r\n\t\t}\r\n        $this->debug('in invoke_method, methodreturn:');\r\n        $this->appendDebug($this->varDump($this->methodreturn));\r\n\t\t$this->debug(\"in invoke_method, called method $this->methodname, received data of type \".gettype($this->methodreturn));\r\n\t}\r\n\r\n\t/**\r\n\t* serializes the return value from a PHP function into a full SOAP Envelope\r\n\t*\r\n\t* The following fields are set by this function (when successful)\r\n\t*\r\n\t* responseSOAP\r\n\t*\r\n\t* This sets the fault field on error\r\n\t*\r\n\t* @access   private\r\n\t*/\r\n\tfunction serialize_return() {\r\n\t\t$this->debug('Entering serialize_return methodname: ' . $this->methodname . ' methodURI: ' . $this->methodURI);\r\n\t\t// if fault\r\n\t\tif (isset($this->methodreturn) && ((get_class($this->methodreturn) == 'soap_fault') || (get_class($this->methodreturn) == 'nusoap_fault'))) {\r\n\t\t\t$this->debug('got a fault object from method');\r\n\t\t\t$this->fault = $this->methodreturn;\r\n\t\t\treturn;\r\n\t\t} elseif ($this->methodreturnisliteralxml) {\r\n\t\t\t$return_val = $this->methodreturn;\r\n\t\t// returned value(s)\r\n\t\t} else {\r\n\t\t\t$this->debug('got a(n) '.gettype($this->methodreturn).' from method');\r\n\t\t\t$this->debug('serializing return value');\r\n\t\t\tif($this->wsdl){\r\n\t\t\t\tif (sizeof($this->opData['output']['parts']) > 1) {\r\n\t\t\t\t\t$this->debug('more than one output part, so use the method return unchanged');\r\n\t\t\t    \t$opParams = $this->methodreturn;\r\n\t\t\t    } elseif (sizeof($this->opData['output']['parts']) == 1) {\r\n\t\t\t\t\t$this->debug('exactly one output part, so wrap the method return in a simple array');\r\n\t\t\t\t\t// TODO: verify that it is not already wrapped!\r\n\t\t\t    \t//foreach ($this->opData['output']['parts'] as $name => $type) {\r\n\t\t\t\t\t//\t$this->debug('wrap in element named ' . $name);\r\n\t\t\t    \t//}\r\n\t\t\t    \t$opParams = array($this->methodreturn);\r\n\t\t\t    }\r\n\t\t\t    $return_val = $this->wsdl->serializeRPCParameters($this->methodname,'output',$opParams);\r\n\t\t\t    $this->appendDebug($this->wsdl->getDebug());\r\n\t\t\t    $this->wsdl->clearDebug();\r\n\t\t\t\tif($errstr = $this->wsdl->getError()){\r\n\t\t\t\t\t$this->debug('got wsdl error: '.$errstr);\r\n\t\t\t\t\t$this->fault('SOAP-ENV:Server', 'unable to serialize result');\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (isset($this->methodreturn)) {\r\n\t\t\t\t\t$return_val = $this->serialize_val($this->methodreturn, 'return');\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$return_val = '';\r\n\t\t\t\t\t$this->debug('in absence of WSDL, assume void return for backward compatibility');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t$this->debug('return value:');\r\n\t\t$this->appendDebug($this->varDump($return_val));\r\n\r\n\t\t$this->debug('serializing response');\r\n\t\tif ($this->wsdl) {\r\n\t\t\t$this->debug('have WSDL for serialization: style is ' . $this->opData['style']);\r\n\t\t\tif ($this->opData['style'] == 'rpc') {\r\n\t\t\t\t$this->debug('style is rpc for serialization: use is ' . $this->opData['output']['use']);\r\n\t\t\t\tif ($this->opData['output']['use'] == 'literal') {\r\n\t\t\t\t\t// http://www.ws-i.org/Profiles/BasicProfile-1.1-2004-08-24.html R2735 says rpc/literal accessor elements should not be in a namespace\r\n\t\t\t\t\t$payload = '<ns1:'.$this->methodname.'Response xmlns:ns1=\"'.$this->methodURI.'\">'.$return_val.'</ns1:'.$this->methodname.\"Response>\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$payload = '<ns1:'.$this->methodname.'Response xmlns:ns1=\"'.$this->methodURI.'\">'.$return_val.'</ns1:'.$this->methodname.\"Response>\";\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t$this->debug('style is not rpc for serialization: assume document');\r\n\t\t\t\t$payload = $return_val;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t$this->debug('do not have WSDL for serialization: assume rpc/encoded');\r\n\t\t\t$payload = '<ns1:'.$this->methodname.'Response xmlns:ns1=\"'.$this->methodURI.'\">'.$return_val.'</ns1:'.$this->methodname.\"Response>\";\r\n\t\t}\r\n\t\t$this->result = 'successful';\r\n\t\tif($this->wsdl){\r\n\t\t\t//if($this->debug_flag){\r\n            \t$this->appendDebug($this->wsdl->getDebug());\r\n            //\t}\r\n\t\t\tif (isset($opData['output']['encodingStyle'])) {\r\n\t\t\t\t$encodingStyle = $opData['output']['encodingStyle'];\r\n\t\t\t} else {\r\n\t\t\t\t$encodingStyle = '';\r\n\t\t\t}\r\n\t\t\t// Added: In case we use a WSDL, return a serialized env. WITH the usedNamespaces.\r\n\t\t\t$this->responseSOAP = $this->serializeEnvelope($payload,$this->responseHeaders,$this->wsdl->usedNamespaces,$this->opData['style'],$this->opData['output']['use'],$encodingStyle);\r\n\t\t} else {\r\n\t\t\t$this->responseSOAP = $this->serializeEnvelope($payload,$this->responseHeaders);\r\n\t\t}\r\n\t\t$this->debug(\"Leaving serialize_return\");\r\n\t}\r\n\r\n\t/**\r\n\t* sends an HTTP response\r\n\t*\r\n\t* The following fields are set by this function (when successful)\r\n\t*\r\n\t* outgoing_headers\r\n\t* response\r\n\t*\r\n\t* @access   private\r\n\t*/\r\n\tfunction send_response() {\r\n\t\t$this->debug('Enter send_response');\r\n\t\tif ($this->fault) {\r\n\t\t\t$payload = $this->fault->serialize();\r\n\t\t\t$this->outgoing_headers[] = \"HTTP/1.0 500 Internal Server Error\";\r\n\t\t\t$this->outgoing_headers[] = \"Status: 500 Internal Server Error\";\r\n\t\t} else {\r\n\t\t\t$payload = $this->responseSOAP;\r\n\t\t\t// Some combinations of PHP+Web server allow the Status\r\n\t\t\t// to come through as a header.  Since OK is the default\r\n\t\t\t// just do nothing.\r\n\t\t\t// $this->outgoing_headers[] = \"HTTP/1.0 200 OK\";\r\n\t\t\t// $this->outgoing_headers[] = \"Status: 200 OK\";\r\n\t\t}\r\n        // add debug data if in debug mode\r\n\t\tif(isset($this->debug_flag) && $this->debug_flag){\r\n        \t$payload .= $this->getDebugAsXMLComment();\r\n        }\r\n\t\t$this->outgoing_headers[] = \"Server: $this->title Server v$this->version\";\r\n\t\tereg('\\$Revisio' . 'n: ([^ ]+)', $this->revision, $rev);\r\n\t\t$this->outgoing_headers[] = \"X-SOAP-Server: $this->title/$this->version (\".$rev[1].\")\";\r\n\t\t// Let the Web server decide about this\r\n\t\t//$this->outgoing_headers[] = \"Connection: Close\\r\\n\";\r\n\t\t$payload = $this->getHTTPBody($payload);\r\n\t\t$type = $this->getHTTPContentType();\r\n\t\t$charset = $this->getHTTPContentTypeCharset();\r\n\t\t$this->outgoing_headers[] = \"Content-Type: $type\" . ($charset ? '; charset=' . $charset : '');\r\n\t\t//begin code to compress payload - by John\r\n\t\t// NOTE: there is no way to know whether the Web server will also compress\r\n\t\t// this data.\r\n\t\tif (strlen($payload) > 1024 && isset($this->headers) && isset($this->headers['accept-encoding'])) {\t\r\n\t\t\tif (strstr($this->headers['accept-encoding'], 'gzip')) {\r\n\t\t\t\tif (function_exists('gzencode')) {\r\n\t\t\t\t\tif (isset($this->debug_flag) && $this->debug_flag) {\r\n\t\t\t\t\t\t$payload .= \"<!-- Content being gzipped -->\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$this->outgoing_headers[] = \"Content-Encoding: gzip\";\r\n\t\t\t\t\t$payload = gzencode($payload);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (isset($this->debug_flag) && $this->debug_flag) {\r\n\t\t\t\t\t\t$payload .= \"<!-- Content will not be gzipped: no gzencode -->\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} elseif (strstr($this->headers['accept-encoding'], 'deflate')) {\r\n\t\t\t\t// Note: MSIE requires gzdeflate output (no Zlib header and checksum),\r\n\t\t\t\t// instead of gzcompress output,\r\n\t\t\t\t// which conflicts with HTTP 1.1 spec (http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.5)\r\n\t\t\t\tif (function_exists('gzdeflate')) {\r\n\t\t\t\t\tif (isset($this->debug_flag) && $this->debug_flag) {\r\n\t\t\t\t\t\t$payload .= \"<!-- Content being deflated -->\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$this->outgoing_headers[] = \"Content-Encoding: deflate\";\r\n\t\t\t\t\t$payload = gzdeflate($payload);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (isset($this->debug_flag) && $this->debug_flag) {\r\n\t\t\t\t\t\t$payload .= \"<!-- Content will not be deflated: no gzcompress -->\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t//end code\r\n\t\t$this->outgoing_headers[] = \"Content-Length: \".strlen($payload);\r\n\t\treset($this->outgoing_headers);\r\n\t\tforeach($this->outgoing_headers as $hdr){\r\n\t\t\theader($hdr, false);\r\n\t\t}\r\n\t\tprint $payload;\r\n\t\t$this->response = join(\"\\r\\n\",$this->outgoing_headers).\"\\r\\n\\r\\n\".$payload;\r\n\t}\r\n\r\n\t/**\r\n\t* takes the value that was created by parsing the request\r\n\t* and compares to the method's signature, if available.\r\n\t*\r\n\t* @param\tstring\t$operation\tThe operation to be invoked\r\n\t* @param\tarray\t$request\tThe array of parameter values\r\n\t* @return\tboolean\tWhether the operation was found\r\n\t* @access   private\r\n\t*/\r\n\tfunction verify_method($operation,$request){\r\n\t\tif(isset($this->wsdl) && is_object($this->wsdl)){\r\n\t\t\tif($this->wsdl->getOperationData($operation)){\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t    } elseif(isset($this->operations[$operation])){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t* processes SOAP message received from client\r\n\t*\r\n\t* @param\tarray\t$headers\tThe HTTP headers\r\n\t* @param\tstring\t$data\t\tunprocessed request data from client\r\n\t* @return\tmixed\tvalue of the message, decoded into a PHP type\r\n\t* @access   private\r\n\t*/\r\n    function parseRequest($headers, $data) {\r\n\t\t$this->debug('Entering parseRequest() for data of length ' . strlen($data) . ' and type ' . $headers['content-type']);\r\n\t\tif (!strstr($headers['content-type'], 'text/xml')) {\r\n\t\t\t$this->setError('Request not of type text/xml');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (strpos($headers['content-type'], '=')) {\r\n\t\t\t$enc = str_replace('\"', '', substr(strstr($headers[\"content-type\"], '='), 1));\r\n\t\t\t$this->debug('Got response encoding: ' . $enc);\r\n\t\t\tif(eregi('^(ISO-8859-1|US-ASCII|UTF-8)$',$enc)){\r\n\t\t\t\t$this->xml_encoding = strtoupper($enc);\r\n\t\t\t} else {\r\n\t\t\t\t$this->xml_encoding = 'US-ASCII';\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1\r\n\t\t\t$this->xml_encoding = 'ISO-8859-1';\r\n\t\t}\r\n\t\t$this->debug('Use encoding: ' . $this->xml_encoding . ' when creating nusoap_parser');\r\n\t\t// parse response, get soap parser obj\r\n\t\t$parser = new nusoap_parser($data,$this->xml_encoding,'',$this->decode_utf8);\r\n\t\t// parser debug\r\n\t\t$this->debug(\"parser debug: \\n\".$parser->getDebug());\r\n\t\t// if fault occurred during message parsing\r\n\t\tif($err = $parser->getError()){\r\n\t\t\t$this->result = 'fault: error in msg parsing: '.$err;\r\n\t\t\t$this->fault('SOAP-ENV:Client',\"error in msg parsing:\\n\".$err);\r\n\t\t// else successfully parsed request into soapval object\r\n\t\t} else {\r\n\t\t\t// get/set methodname\r\n\t\t\t$this->methodURI = $parser->root_struct_namespace;\r\n\t\t\t$this->methodname = $parser->root_struct_name;\r\n\t\t\t$this->debug('methodname: '.$this->methodname.' methodURI: '.$this->methodURI);\r\n\t\t\t$this->debug('calling parser->get_soapbody()');\r\n\t\t\t$this->methodparams = $parser->get_soapbody();\r\n\t\t\t// get SOAP headers\r\n\t\t\t$this->requestHeaders = $parser->getHeaders();\r\n\t\t\t// get SOAP Header\r\n\t\t\t$this->requestHeader = $parser->get_soapheader();\r\n            // add document for doclit support\r\n            $this->document = $parser->document;\r\n\t\t}\r\n\t }\r\n\r\n\t/**\r\n\t* gets the HTTP body for the current response.\r\n\t*\r\n\t* @param string $soapmsg The SOAP payload\r\n\t* @return string The HTTP body, which includes the SOAP payload\r\n\t* @access private\r\n\t*/\r\n\tfunction getHTTPBody($soapmsg) {\r\n\t\treturn $soapmsg;\r\n\t}\r\n\t\r\n\t/**\r\n\t* gets the HTTP content type for the current response.\r\n\t*\r\n\t* Note: getHTTPBody must be called before this.\r\n\t*\r\n\t* @return string the HTTP content type for the current response.\r\n\t* @access private\r\n\t*/\r\n\tfunction getHTTPContentType() {\r\n\t\treturn 'text/xml';\r\n\t}\r\n\t\r\n\t/**\r\n\t* gets the HTTP content type charset for the current response.\r\n\t* returns false for non-text content types.\r\n\t*\r\n\t* Note: getHTTPBody must be called before this.\r\n\t*\r\n\t* @return string the HTTP content type charset for the current response.\r\n\t* @access private\r\n\t*/\r\n\tfunction getHTTPContentTypeCharset() {\r\n\t\treturn $this->soap_defencoding;\r\n\t}\r\n\r\n\t/**\r\n\t* add a method to the dispatch map (this has been replaced by the register method)\r\n\t*\r\n\t* @param    string $methodname\r\n\t* @param    string $in array of input values\r\n\t* @param    string $out array of output values\r\n\t* @access   public\r\n\t* @deprecated\r\n\t*/\r\n\tfunction add_to_map($methodname,$in,$out){\r\n\t\t\t$this->operations[$methodname] = array('name' => $methodname,'in' => $in,'out' => $out);\r\n\t}\r\n\r\n\t/**\r\n\t* register a service function with the server\r\n\t*\r\n\t* @param    string $name the name of the PHP function, class.method or class..method\r\n\t* @param    array $in assoc array of input values: key = param name, value = param type\r\n\t* @param    array $out assoc array of output values: key = param name, value = param type\r\n\t* @param\tmixed $namespace the element namespace for the method or false\r\n\t* @param\tmixed $soapaction the soapaction for the method or false\r\n\t* @param\tmixed $style optional (rpc|document) or false Note: when 'document' is specified, parameter and return wrappers are created for you automatically\r\n\t* @param\tmixed $use optional (encoded|literal) or false\r\n\t* @param\tstring $documentation optional Description to include in WSDL\r\n\t* @param\tstring $encodingStyle optional (usually 'http://schemas.xmlsoap.org/soap/encoding/' for encoded)\r\n\t* @access   public\r\n\t*/\r\n\tfunction register($name,$in=array(),$out=array(),$namespace=false,$soapaction=false,$style=false,$use=false,$documentation='',$encodingStyle=''){\r\n\t\tglobal $HTTP_SERVER_VARS;\r\n\r\n\t\tif($this->externalWSDLURL){\r\n\t\t\tdie('You cannot bind to an external WSDL file, and register methods outside of it! Please choose either WSDL or no WSDL.');\r\n\t\t}\r\n\t\tif (! $name) {\r\n\t\t\tdie('You must specify a name when you register an operation');\r\n\t\t}\r\n\t\tif (!is_array($in)) {\r\n\t\t\tdie('You must provide an array for operation inputs');\r\n\t\t}\r\n\t\tif (!is_array($out)) {\r\n\t\t\tdie('You must provide an array for operation outputs');\r\n\t\t}\r\n\t\tif(false == $namespace) {\r\n\t\t}\r\n\t\tif(false == $soapaction) {\r\n\t\t\tif (isset($_SERVER)) {\r\n\t\t\t\t$SERVER_NAME = $_SERVER['SERVER_NAME'];\r\n\t\t\t\t$SCRIPT_NAME = isset($_SERVER['PHP_SELF']) ? $_SERVER['PHP_SELF'] : $_SERVER['SCRIPT_NAME'];\r\n\t\t\t\t$HTTPS = isset($_SERVER['HTTPS']) ? $_SERVER['HTTPS'] : (isset($HTTP_SERVER_VARS['HTTPS']) ? $HTTP_SERVER_VARS['HTTPS'] : 'off');\r\n\t\t\t} elseif (isset($HTTP_SERVER_VARS)) {\r\n\t\t\t\t$SERVER_NAME = $HTTP_SERVER_VARS['SERVER_NAME'];\r\n\t\t\t\t$SCRIPT_NAME = isset($HTTP_SERVER_VARS['PHP_SELF']) ? $HTTP_SERVER_VARS['PHP_SELF'] : $HTTP_SERVER_VARS['SCRIPT_NAME'];\r\n\t\t\t\t$HTTPS = isset($HTTP_SERVER_VARS['HTTPS']) ? $HTTP_SERVER_VARS['HTTPS'] : 'off';\r\n\t\t\t} else {\r\n\t\t\t\t$this->setError(\"Neither _SERVER nor HTTP_SERVER_VARS is available\");\r\n\t\t\t}\r\n        \tif ($HTTPS == '1' || $HTTPS == 'on') {\r\n        \t\t$SCHEME = 'https';\r\n        \t} else {\r\n        \t\t$SCHEME = 'http';\r\n        \t}\r\n\t\t\t$soapaction = \"$SCHEME://$SERVER_NAME$SCRIPT_NAME/$name\";\r\n\t\t}\r\n\t\tif(false == $style) {\r\n\t\t\t$style = \"rpc\";\r\n\t\t}\r\n\t\tif(false == $use) {\r\n\t\t\t$use = \"encoded\";\r\n\t\t}\r\n\t\tif ($use == 'encoded' && $encodingStyle = '') {\r\n\t\t\t$encodingStyle = 'http://schemas.xmlsoap.org/soap/encoding/';\r\n\t\t}\r\n\r\n\t\t$this->operations[$name] = array(\r\n\t    'name' => $name,\r\n\t    'in' => $in,\r\n\t    'out' => $out,\r\n\t    'namespace' => $namespace,\r\n\t    'soapaction' => $soapaction,\r\n\t    'style' => $style);\r\n        if($this->wsdl){\r\n        \t$this->wsdl->addOperation($name,$in,$out,$namespace,$soapaction,$style,$use,$documentation,$encodingStyle);\r\n\t    }\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* Specify a fault to be returned to the client.\r\n\t* This also acts as a flag to the server that a fault has occured.\r\n\t*\r\n\t* @param\tstring $faultcode\r\n\t* @param\tstring $faultstring\r\n\t* @param\tstring $faultactor\r\n\t* @param\tstring $faultdetail\r\n\t* @access   public\r\n\t*/\r\n\tfunction fault($faultcode,$faultstring,$faultactor='',$faultdetail=''){\r\n\t\tif ($faultdetail == '' && $this->debug_flag) {\r\n\t\t\t$faultdetail = $this->getDebug();\r\n\t\t}\r\n\t\t$this->fault = new nusoap_fault($faultcode,$faultactor,$faultstring,$faultdetail);\r\n\t\t$this->fault->soap_defencoding = $this->soap_defencoding;\r\n\t}\r\n\r\n    /**\r\n    * Sets up wsdl object.\r\n    * Acts as a flag to enable internal WSDL generation\r\n    *\r\n    * @param string $serviceName, name of the service\r\n    * @param mixed $namespace optional 'tns' service namespace or false\r\n    * @param mixed $endpoint optional URL of service endpoint or false\r\n    * @param string $style optional (rpc|document) WSDL style (also specified by operation)\r\n    * @param string $transport optional SOAP transport\r\n    * @param mixed $schemaTargetNamespace optional 'types' targetNamespace for service schema or false\r\n    */\r\n    function configureWSDL($serviceName,$namespace = false,$endpoint = false,$style='rpc', $transport = 'http://schemas.xmlsoap.org/soap/http', $schemaTargetNamespace = false)\r\n    {\r\n    \tglobal $HTTP_SERVER_VARS;\r\n\r\n\t\tif (isset($_SERVER)) {\r\n\t\t\t$SERVER_NAME = $_SERVER['SERVER_NAME'];\r\n\t\t\t$SERVER_PORT = $_SERVER['SERVER_PORT'];\r\n\t\t\t$SCRIPT_NAME = isset($_SERVER['PHP_SELF']) ? $_SERVER['PHP_SELF'] : $_SERVER['SCRIPT_NAME'];\r\n\t\t\t$HTTPS = isset($_SERVER['HTTPS']) ? $_SERVER['HTTPS'] : (isset($HTTP_SERVER_VARS['HTTPS']) ? $HTTP_SERVER_VARS['HTTPS'] : 'off');\r\n\t\t} elseif (isset($HTTP_SERVER_VARS)) {\r\n\t\t\t$SERVER_NAME = $HTTP_SERVER_VARS['SERVER_NAME'];\r\n\t\t\t$SERVER_PORT = $HTTP_SERVER_VARS['SERVER_PORT'];\r\n\t\t\t$SCRIPT_NAME = isset($HTTP_SERVER_VARS['PHP_SELF']) ? $HTTP_SERVER_VARS['PHP_SELF'] : $HTTP_SERVER_VARS['SCRIPT_NAME'];\r\n\t\t\t$HTTPS = isset($HTTP_SERVER_VARS['HTTPS']) ? $HTTP_SERVER_VARS['HTTPS'] : 'off';\r\n\t\t} else {\r\n\t\t\t$this->setError(\"Neither _SERVER nor HTTP_SERVER_VARS is available\");\r\n\t\t}\r\n\t\t// If server name has port number attached then strip it (else port number gets duplicated in WSDL output) (occurred using lighttpd and FastCGI)\r\n\t\t$colon = strpos($SERVER_NAME,\":\");\r\n\t\tif ($colon) {\r\n\t\t    $SERVER_NAME = substr($SERVER_NAME, 0, $colon);\r\n\t\t}\r\n\t\tif ($SERVER_PORT == 80) {\r\n\t\t\t$SERVER_PORT = '';\r\n\t\t} else {\r\n\t\t\t$SERVER_PORT = ':' . $SERVER_PORT;\r\n\t\t}\r\n        if(false == $namespace) {\r\n            $namespace = \"http://$SERVER_NAME/soap/$serviceName\";\r\n        }\r\n        \r\n        if(false == $endpoint) {\r\n        \tif ($HTTPS == '1' || $HTTPS == 'on') {\r\n        \t\t$SCHEME = 'https';\r\n        \t} else {\r\n        \t\t$SCHEME = 'http';\r\n        \t}\r\n            $endpoint = \"$SCHEME://$SERVER_NAME$SERVER_PORT$SCRIPT_NAME\";\r\n        }\r\n        \r\n        if(false == $schemaTargetNamespace) {\r\n            $schemaTargetNamespace = $namespace;\r\n        }\r\n        \r\n\t\t$this->wsdl = new wsdl;\r\n\t\t$this->wsdl->serviceName = $serviceName;\r\n        $this->wsdl->endpoint = $endpoint;\r\n\t\t$this->wsdl->namespaces['tns'] = $namespace;\r\n\t\t$this->wsdl->namespaces['soap'] = 'http://schemas.xmlsoap.org/wsdl/soap/';\r\n\t\t$this->wsdl->namespaces['wsdl'] = 'http://schemas.xmlsoap.org/wsdl/';\r\n\t\tif ($schemaTargetNamespace != $namespace) {\r\n\t\t\t$this->wsdl->namespaces['types'] = $schemaTargetNamespace;\r\n\t\t}\r\n        $this->wsdl->schemas[$schemaTargetNamespace][0] = new nusoap_xmlschema('', '', $this->wsdl->namespaces);\r\n        if ($style == 'document') {\r\n\t        $this->wsdl->schemas[$schemaTargetNamespace][0]->schemaInfo['elementFormDefault'] = 'qualified';\r\n        }\r\n        $this->wsdl->schemas[$schemaTargetNamespace][0]->schemaTargetNamespace = $schemaTargetNamespace;\r\n        $this->wsdl->schemas[$schemaTargetNamespace][0]->imports['http://schemas.xmlsoap.org/soap/encoding/'][0] = array('location' => '', 'loaded' => true);\r\n        $this->wsdl->schemas[$schemaTargetNamespace][0]->imports['http://schemas.xmlsoap.org/wsdl/'][0] = array('location' => '', 'loaded' => true);\r\n        $this->wsdl->bindings[$serviceName.'Binding'] = array(\r\n        \t'name'=>$serviceName.'Binding',\r\n            'style'=>$style,\r\n            'transport'=>$transport,\r\n            'portType'=>$serviceName.'PortType');\r\n        $this->wsdl->ports[$serviceName.'Port'] = array(\r\n        \t'binding'=>$serviceName.'Binding',\r\n            'location'=>$endpoint,\r\n            'bindingType'=>'http://schemas.xmlsoap.org/wsdl/soap/');\r\n    }\r\n}\r\n\r\n/**\r\n * Backward compatibility\r\n */\r\nclass soap_server extends nusoap_server {\r\n}\r\n\r\n?><?php\r\n\r\n\r\n\r\n/**\r\n* parses a WSDL file, allows access to it's data, other utility methods.\r\n* also builds WSDL structures programmatically.\r\n* \r\n* @author   Dietrich Ayala <dietrich@ganx4.com>\r\n* @author   Scott Nichol <snichol@users.sourceforge.net>\r\n* @version  $Id: nusoap.php,v 1.114 2007/11/06 15:17:46 snichol Exp $\r\n* @access public \r\n*/\r\nclass wsdl extends nusoap_base {\r\n\t// URL or filename of the root of this WSDL\r\n    var $wsdl; \r\n    // define internal arrays of bindings, ports, operations, messages, etc.\r\n    var $schemas = array();\r\n    var $currentSchema;\r\n    var $message = array();\r\n    var $complexTypes = array();\r\n    var $messages = array();\r\n    var $currentMessage;\r\n    var $currentOperation;\r\n    var $portTypes = array();\r\n    var $currentPortType;\r\n    var $bindings = array();\r\n    var $currentBinding;\r\n    var $ports = array();\r\n    var $currentPort;\r\n    var $opData = array();\r\n    var $status = '';\r\n    var $documentation = false;\r\n    var $endpoint = ''; \r\n    // array of wsdl docs to import\r\n    var $import = array(); \r\n    // parser vars\r\n    var $parser;\r\n    var $position = 0;\r\n    var $depth = 0;\r\n    var $depth_array = array();\r\n\t// for getting wsdl\r\n\tvar $proxyhost = '';\r\n    var $proxyport = '';\r\n\tvar $proxyusername = '';\r\n\tvar $proxypassword = '';\r\n\tvar $timeout = 0;\r\n\tvar $response_timeout = 30;\r\n\tvar $curl_options = array();\t// User-specified cURL options\r\n\tvar $use_curl = false;\t\t\t// whether to always try to use cURL\r\n\t// for HTTP authentication\r\n\tvar $username = '';\t\t\t\t// Username for HTTP authentication\r\n\tvar $password = '';\t\t\t\t// Password for HTTP authentication\r\n\tvar $authtype = '';\t\t\t\t// Type of HTTP authentication\r\n\tvar $certRequest = array();\t\t// Certificate for HTTP SSL authentication\r\n\r\n    /**\r\n     * constructor\r\n     * \r\n     * @param string $wsdl WSDL document URL\r\n\t * @param string $proxyhost\r\n\t * @param string $proxyport\r\n\t * @param string $proxyusername\r\n\t * @param string $proxypassword\r\n\t * @param integer $timeout set the connection timeout\r\n\t * @param integer $response_timeout set the response timeout\r\n\t * @param array $curl_options user-specified cURL options\r\n\t * @param boolean $use_curl try to use cURL\r\n     * @access public \r\n     */\r\n    function wsdl($wsdl = '',$proxyhost=false,$proxyport=false,$proxyusername=false,$proxypassword=false,$timeout=0,$response_timeout=30,$curl_options=null,$use_curl=false){\r\n\t\tparent::nusoap_base();\r\n\t\t$this->debug(\"ctor wsdl=$wsdl timeout=$timeout response_timeout=$response_timeout\");\r\n        $this->proxyhost = $proxyhost;\r\n        $this->proxyport = $proxyport;\r\n\t\t$this->proxyusername = $proxyusername;\r\n\t\t$this->proxypassword = $proxypassword;\r\n\t\t$this->timeout = $timeout;\r\n\t\t$this->response_timeout = $response_timeout;\r\n\t\tif (is_array($curl_options))\r\n\t\t\t$this->curl_options = $curl_options;\r\n\t\t$this->use_curl = $use_curl;\r\n\t\t$this->fetchWSDL($wsdl);\r\n    }\r\n\r\n\t/**\r\n\t * fetches the WSDL document and parses it\r\n\t *\r\n\t * @access public\r\n\t */\r\n\tfunction fetchWSDL($wsdl) {\r\n\t\t$this->debug(\"parse and process WSDL path=$wsdl\");\r\n\t\t$this->wsdl = $wsdl;\r\n        // parse wsdl file\r\n        if ($this->wsdl != \"\") {\r\n            $this->parseWSDL($this->wsdl);\r\n        }\r\n        // imports\r\n        // TODO: handle imports more properly, grabbing them in-line and nesting them\r\n    \t$imported_urls = array();\r\n    \t$imported = 1;\r\n    \twhile ($imported > 0) {\r\n    \t\t$imported = 0;\r\n    \t\t// Schema imports\r\n    \t\tforeach ($this->schemas as $ns => $list) {\r\n    \t\t\tforeach ($list as $xs) {\r\n\t\t\t\t\t$wsdlparts = parse_url($this->wsdl);\t// this is bogusly simple!\r\n\t\t            foreach ($xs->imports as $ns2 => $list2) {\r\n\t\t                for ($ii = 0; $ii < count($list2); $ii++) {\r\n\t\t                \tif (! $list2[$ii]['loaded']) {\r\n\t\t                \t\t$this->schemas[$ns]->imports[$ns2][$ii]['loaded'] = true;\r\n\t\t                \t\t$url = $list2[$ii]['location'];\r\n\t\t\t\t\t\t\t\tif ($url != '') {\r\n\t\t\t\t\t\t\t\t\t$urlparts = parse_url($url);\r\n\t\t\t\t\t\t\t\t\tif (!isset($urlparts['host'])) {\r\n\t\t\t\t\t\t\t\t\t\t$url = $wsdlparts['scheme'] . '://' . $wsdlparts['host'] . (isset($wsdlparts['port']) ? ':' .$wsdlparts['port'] : '') .\r\n\t\t\t\t\t\t\t\t\t\t\t\tsubstr($wsdlparts['path'],0,strrpos($wsdlparts['path'],'/') + 1) .$urlparts['path'];\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (! in_array($url, $imported_urls)) {\r\n\t\t\t\t\t                \t$this->parseWSDL($url);\r\n\t\t\t\t                \t\t$imported++;\r\n\t\t\t\t                \t\t$imported_urls[] = $url;\r\n\t\t\t\t                \t}\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t$this->debug(\"Unexpected scenario: empty URL for unloaded import\");\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t            } \r\n    \t\t\t}\r\n    \t\t}\r\n    \t\t// WSDL imports\r\n\t\t\t$wsdlparts = parse_url($this->wsdl);\t// this is bogusly simple!\r\n            foreach ($this->import as $ns => $list) {\r\n                for ($ii = 0; $ii < count($list); $ii++) {\r\n                \tif (! $list[$ii]['loaded']) {\r\n                \t\t$this->import[$ns][$ii]['loaded'] = true;\r\n                \t\t$url = $list[$ii]['location'];\r\n\t\t\t\t\t\tif ($url != '') {\r\n\t\t\t\t\t\t\t$urlparts = parse_url($url);\r\n\t\t\t\t\t\t\tif (!isset($urlparts['host'])) {\r\n\t\t\t\t\t\t\t\t$url = $wsdlparts['scheme'] . '://' . $wsdlparts['host'] . (isset($wsdlparts['port']) ? ':' . $wsdlparts['port'] : '') .\r\n\t\t\t\t\t\t\t\t\t\tsubstr($wsdlparts['path'],0,strrpos($wsdlparts['path'],'/') + 1) .$urlparts['path'];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (! in_array($url, $imported_urls)) {\r\n\t\t\t                \t$this->parseWSDL($url);\r\n\t\t                \t\t$imported++;\r\n\t\t                \t\t$imported_urls[] = $url;\r\n\t\t                \t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t$this->debug(\"Unexpected scenario: empty URL for unloaded import\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n            } \r\n\t\t}\r\n        // add new data to operation data\r\n        foreach($this->bindings as $binding => $bindingData) {\r\n            if (isset($bindingData['operations']) && is_array($bindingData['operations'])) {\r\n                foreach($bindingData['operations'] as $operation => $data) {\r\n                    $this->debug('post-parse data gathering for ' . $operation);\r\n                    $this->bindings[$binding]['operations'][$operation]['input'] = \r\n\t\t\t\t\t\tisset($this->bindings[$binding]['operations'][$operation]['input']) ? \r\n\t\t\t\t\t\tarray_merge($this->bindings[$binding]['operations'][$operation]['input'], $this->portTypes[ $bindingData['portType'] ][$operation]['input']) :\r\n\t\t\t\t\t\t$this->portTypes[ $bindingData['portType'] ][$operation]['input'];\r\n                    $this->bindings[$binding]['operations'][$operation]['output'] = \r\n\t\t\t\t\t\tisset($this->bindings[$binding]['operations'][$operation]['output']) ?\r\n\t\t\t\t\t\tarray_merge($this->bindings[$binding]['operations'][$operation]['output'], $this->portTypes[ $bindingData['portType'] ][$operation]['output']) :\r\n\t\t\t\t\t\t$this->portTypes[ $bindingData['portType'] ][$operation]['output'];\r\n                    if(isset($this->messages[ $this->bindings[$binding]['operations'][$operation]['input']['message'] ])){\r\n\t\t\t\t\t\t$this->bindings[$binding]['operations'][$operation]['input']['parts'] = $this->messages[ $this->bindings[$binding]['operations'][$operation]['input']['message'] ];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(isset($this->messages[ $this->bindings[$binding]['operations'][$operation]['output']['message'] ])){\r\n                   \t\t$this->bindings[$binding]['operations'][$operation]['output']['parts'] = $this->messages[ $this->bindings[$binding]['operations'][$operation]['output']['message'] ];\r\n                    }\r\n                    // Set operation style if necessary, but do not override one already provided\r\n\t\t\t\t\tif (isset($bindingData['style']) && !isset($this->bindings[$binding]['operations'][$operation]['style'])) {\r\n                        $this->bindings[$binding]['operations'][$operation]['style'] = $bindingData['style'];\r\n                    }\r\n                    $this->bindings[$binding]['operations'][$operation]['transport'] = isset($bindingData['transport']) ? $bindingData['transport'] : '';\r\n                    $this->bindings[$binding]['operations'][$operation]['documentation'] = isset($this->portTypes[ $bindingData['portType'] ][$operation]['documentation']) ? $this->portTypes[ $bindingData['portType'] ][$operation]['documentation'] : '';\r\n                    $this->bindings[$binding]['operations'][$operation]['endpoint'] = isset($bindingData['endpoint']) ? $bindingData['endpoint'] : '';\r\n                } \r\n            } \r\n        }\r\n\t}\r\n\r\n    /**\r\n     * parses the wsdl document\r\n     * \r\n     * @param string $wsdl path or URL\r\n     * @access private \r\n     */\r\n    function parseWSDL($wsdl = '') {\r\n\t\t$this->debug(\"parse WSDL at path=$wsdl\");\r\n\r\n        if ($wsdl == '') {\r\n            $this->debug('no wsdl passed to parseWSDL()!!');\r\n            $this->setError('no wsdl passed to parseWSDL()!!');\r\n            return false;\r\n        }\r\n        \r\n        // parse $wsdl for url format\r\n        $wsdl_props = parse_url($wsdl);\r\n\r\n        if (isset($wsdl_props['scheme']) && ($wsdl_props['scheme'] == 'http' || $wsdl_props['scheme'] == 'https')) {\r\n            $this->debug('getting WSDL http(s) URL ' . $wsdl);\r\n        \t// get wsdl\r\n\t        $tr = new soap_transport_http($wsdl, $this->curl_options, $this->use_curl);\r\n\t\t\t$tr->request_method = 'GET';\r\n\t\t\t$tr->useSOAPAction = false;\r\n\t\t\tif($this->proxyhost && $this->proxyport){\r\n\t\t\t\t$tr->setProxy($this->proxyhost,$this->proxyport,$this->proxyusername,$this->proxypassword);\r\n\t\t\t}\r\n\t\t\tif ($this->authtype != '') {\r\n\t\t\t\t$tr->setCredentials($this->username, $this->password, $this->authtype, array(), $this->certRequest);\r\n\t\t\t}\r\n\t\t\t$tr->setEncoding('gzip, deflate');\r\n\t\t\t$wsdl_string = $tr->send('', $this->timeout, $this->response_timeout);\r\n\t\t\t//$this->debug(\"WSDL request\\n\" . $tr->outgoing_payload);\r\n\t\t\t//$this->debug(\"WSDL response\\n\" . $tr->incoming_payload);\r\n\t\t\t$this->appendDebug($tr->getDebug());\r\n\t\t\t// catch errors\r\n\t\t\tif($err = $tr->getError() ){\r\n\t\t\t\t$errstr = 'HTTP ERROR: '.$err;\r\n\t\t\t\t$this->debug($errstr);\r\n\t            $this->setError($errstr);\r\n\t\t\t\tunset($tr);\r\n\t            return false;\r\n\t\t\t}\r\n\t\t\tunset($tr);\r\n\t\t\t$this->debug(\"got WSDL URL\");\r\n        } else {\r\n            // $wsdl is not http(s), so treat it as a file URL or plain file path\r\n        \tif (isset($wsdl_props['scheme']) && ($wsdl_props['scheme'] == 'file') && isset($wsdl_props['path'])) {\r\n        \t\t$path = isset($wsdl_props['host']) ? ($wsdl_props['host'] . ':' . $wsdl_props['path']) : $wsdl_props['path'];\r\n        \t} else {\r\n        \t\t$path = $wsdl;\r\n        \t}\r\n            $this->debug('getting WSDL file ' . $path);\r\n            if ($fp = @fopen($path, 'r')) {\r\n                $wsdl_string = '';\r\n                while ($data = fread($fp, 32768)) {\r\n                    $wsdl_string .= $data;\r\n                } \r\n                fclose($fp);\r\n            } else {\r\n            \t$errstr = \"Bad path to WSDL file $path\";\r\n            \t$this->debug($errstr);\r\n                $this->setError($errstr);\r\n                return false;\r\n            } \r\n        }\r\n        $this->debug('Parse WSDL');\r\n        // end new code added\r\n        // Create an XML parser.\r\n        $this->parser = xml_parser_create(); \r\n        // Set the options for parsing the XML data.\r\n        // xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 1);\r\n        xml_parser_set_option($this->parser, XML_OPTION_CASE_FOLDING, 0); \r\n        // Set the object for the parser.\r\n        xml_set_object($this->parser, $this); \r\n        // Set the element handlers for the parser.\r\n        xml_set_element_handler($this->parser, 'start_element', 'end_element');\r\n        xml_set_character_data_handler($this->parser, 'character_data');\r\n        // Parse the XML file.\r\n        if (!xml_parse($this->parser, $wsdl_string, true)) {\r\n            // Display an error message.\r\n            $errstr = sprintf(\r\n\t\t\t\t'XML error parsing WSDL from %s on line %d: %s',\r\n\t\t\t\t$wsdl,\r\n                xml_get_current_line_number($this->parser),\r\n                xml_error_string(xml_get_error_code($this->parser))\r\n                );\r\n            $this->debug($errstr);\r\n\t\t\t$this->debug(\"XML payload:\\n\" . $wsdl_string);\r\n            $this->setError($errstr);\r\n            return false;\r\n        } \r\n\t\t// free the parser\r\n        xml_parser_free($this->parser);\r\n        $this->debug('Parsing WSDL done');\r\n\t\t// catch wsdl parse errors\r\n\t\tif($this->getError()){\r\n\t\t\treturn false;\r\n\t\t}\r\n        return true;\r\n    } \r\n\r\n    /**\r\n     * start-element handler\r\n     * \r\n     * @param string $parser XML parser object\r\n     * @param string $name element name\r\n     * @param string $attrs associative array of attributes\r\n     * @access private \r\n     */\r\n    function start_element($parser, $name, $attrs)\r\n    {\r\n        if ($this->status == 'schema') {\r\n            $this->currentSchema->schemaStartElement($parser, $name, $attrs);\r\n            $this->appendDebug($this->currentSchema->getDebug());\r\n            $this->currentSchema->clearDebug();\r\n        } elseif (ereg('schema$', $name)) {\r\n        \t$this->debug('Parsing WSDL schema');\r\n            // $this->debug(\"startElement for $name ($attrs[name]). status = $this->status (\".$this->getLocalPart($name).\")\");\r\n            $this->status = 'schema';\r\n            $this->currentSchema = new nusoap_xmlschema('', '', $this->namespaces);\r\n            $this->currentSchema->schemaStartElement($parser, $name, $attrs);\r\n            $this->appendDebug($this->currentSchema->getDebug());\r\n            $this->currentSchema->clearDebug();\r\n        } else {\r\n            // position in the total number of elements, starting from 0\r\n            $pos = $this->position++;\r\n            $depth = $this->depth++; \r\n            // set self as current value for this depth\r\n            $this->depth_array[$depth] = $pos;\r\n            $this->message[$pos] = array('cdata' => ''); \r\n            // process attributes\r\n            if (count($attrs) > 0) {\r\n\t\t\t\t// register namespace declarations\r\n                foreach($attrs as $k => $v) {\r\n                    if (ereg(\"^xmlns\", $k)) {\r\n                        if ($ns_prefix = substr(strrchr($k, ':'), 1)) {\r\n                            $this->namespaces[$ns_prefix] = $v;\r\n                        } else {\r\n                            $this->namespaces['ns' . (count($this->namespaces) + 1)] = $v;\r\n                        } \r\n                        if ($v == 'http://www.w3.org/2001/XMLSchema' || $v == 'http://www.w3.org/1999/XMLSchema' || $v == 'http://www.w3.org/2000/10/XMLSchema') {\r\n                            $this->XMLSchemaVersion = $v;\r\n                            $this->namespaces['xsi'] = $v . '-instance';\r\n                        } \r\n                    }\r\n                }\r\n                // expand each attribute prefix to its namespace\r\n                foreach($attrs as $k => $v) {\r\n                    $k = strpos($k, ':') ? $this->expandQname($k) : $k;\r\n                    if ($k != 'location' && $k != 'soapAction' && $k != 'namespace') {\r\n                        $v = strpos($v, ':') ? $this->expandQname($v) : $v;\r\n                    } \r\n                    $eAttrs[$k] = $v;\r\n                } \r\n                $attrs = $eAttrs;\r\n            } else {\r\n                $attrs = array();\r\n            } \r\n            // get element prefix, namespace and name\r\n            if (ereg(':', $name)) {\r\n                // get ns prefix\r\n                $prefix = substr($name, 0, strpos($name, ':')); \r\n                // get ns\r\n                $namespace = isset($this->namespaces[$prefix]) ? $this->namespaces[$prefix] : ''; \r\n                // get unqualified name\r\n                $name = substr(strstr($name, ':'), 1);\r\n            } \r\n\t\t\t// process attributes, expanding any prefixes to namespaces\r\n            // find status, register data\r\n            switch ($this->status) {\r\n                case 'message':\r\n                    if ($name == 'part') {\r\n\t\t\t            if (isset($attrs['type'])) {\r\n\t\t                    $this->debug(\"msg \" . $this->currentMessage . \": found part (with type) $attrs[name]: \" . implode(',', $attrs));\r\n\t\t                    $this->messages[$this->currentMessage][$attrs['name']] = $attrs['type'];\r\n            \t\t\t} \r\n\t\t\t            if (isset($attrs['element'])) {\r\n\t\t                    $this->debug(\"msg \" . $this->currentMessage . \": found part (with element) $attrs[name]: \" . implode(',', $attrs));\r\n\t\t\t                $this->messages[$this->currentMessage][$attrs['name']] = $attrs['element'] . '^';\r\n\t\t\t            } \r\n        \t\t\t} \r\n        \t\t\tbreak;\r\n\t\t\t    case 'portType':\r\n\t\t\t        switch ($name) {\r\n\t\t\t            case 'operation':\r\n\t\t\t                $this->currentPortOperation = $attrs['name'];\r\n\t\t\t                $this->debug(\"portType $this->currentPortType operation: $this->currentPortOperation\");\r\n\t\t\t                if (isset($attrs['parameterOrder'])) {\r\n\t\t\t                \t$this->portTypes[$this->currentPortType][$attrs['name']]['parameterOrder'] = $attrs['parameterOrder'];\r\n\t\t\t        \t\t} \r\n\t\t\t        \t\tbreak;\r\n\t\t\t\t\t    case 'documentation':\r\n\t\t\t\t\t        $this->documentation = true;\r\n\t\t\t\t\t        break; \r\n\t\t\t\t\t    // merge input/output data\r\n\t\t\t\t\t    default:\r\n\t\t\t\t\t        $m = isset($attrs['message']) ? $this->getLocalPart($attrs['message']) : '';\r\n\t\t\t\t\t        $this->portTypes[$this->currentPortType][$this->currentPortOperation][$name]['message'] = $m;\r\n\t\t\t\t\t        break;\r\n\t\t\t\t\t} \r\n\t\t\t    \tbreak;\r\n\t\t\t\tcase 'binding':\r\n\t\t\t\t    switch ($name) {\r\n\t\t\t\t        case 'binding': \r\n\t\t\t\t            // get ns prefix\r\n\t\t\t\t            if (isset($attrs['style'])) {\r\n\t\t\t\t            $this->bindings[$this->currentBinding]['prefix'] = $prefix;\r\n\t\t\t\t\t    \t} \r\n\t\t\t\t\t    \t$this->bindings[$this->currentBinding] = array_merge($this->bindings[$this->currentBinding], $attrs);\r\n\t\t\t\t\t    \tbreak;\r\n\t\t\t\t\t\tcase 'header':\r\n\t\t\t\t\t\t    $this->bindings[$this->currentBinding]['operations'][$this->currentOperation][$this->opStatus]['headers'][] = $attrs;\r\n\t\t\t\t\t\t    break;\r\n\t\t\t\t\t\tcase 'operation':\r\n\t\t\t\t\t\t    if (isset($attrs['soapAction'])) {\r\n\t\t\t\t\t\t        $this->bindings[$this->currentBinding]['operations'][$this->currentOperation]['soapAction'] = $attrs['soapAction'];\r\n\t\t\t\t\t\t    } \r\n\t\t\t\t\t\t    if (isset($attrs['style'])) {\r\n\t\t\t\t\t\t        $this->bindings[$this->currentBinding]['operations'][$this->currentOperation]['style'] = $attrs['style'];\r\n\t\t\t\t\t\t    } \r\n\t\t\t\t\t\t    if (isset($attrs['name'])) {\r\n\t\t\t\t\t\t        $this->currentOperation = $attrs['name'];\r\n\t\t\t\t\t\t        $this->debug(\"current binding operation: $this->currentOperation\");\r\n\t\t\t\t\t\t        $this->bindings[$this->currentBinding]['operations'][$this->currentOperation]['name'] = $attrs['name'];\r\n\t\t\t\t\t\t        $this->bindings[$this->currentBinding]['operations'][$this->currentOperation]['binding'] = $this->currentBinding;\r\n\t\t\t\t\t\t        $this->bindings[$this->currentBinding]['operations'][$this->currentOperation]['endpoint'] = isset($this->bindings[$this->currentBinding]['endpoint']) ? $this->bindings[$this->currentBinding]['endpoint'] : '';\r\n\t\t\t\t\t\t    } \r\n\t\t\t\t\t\t    break;\r\n\t\t\t\t\t\tcase 'input':\r\n\t\t\t\t\t\t    $this->opStatus = 'input';\r\n\t\t\t\t\t\t    break;\r\n\t\t\t\t\t\tcase 'output':\r\n\t\t\t\t\t\t    $this->opStatus = 'output';\r\n\t\t\t\t\t\t    break;\r\n\t\t\t\t\t\tcase 'body':\r\n\t\t\t\t\t\t    if (isset($this->bindings[$this->currentBinding]['operations'][$this->currentOperation][$this->opStatus])) {\r\n\t\t\t\t\t\t        $this->bindings[$this->currentBinding]['operations'][$this->currentOperation][$this->opStatus] = array_merge($this->bindings[$this->currentBinding]['operations'][$this->currentOperation][$this->opStatus], $attrs);\r\n\t\t\t\t\t\t    } else {\r\n\t\t\t\t\t\t        $this->bindings[$this->currentBinding]['operations'][$this->currentOperation][$this->opStatus] = $attrs;\r\n\t\t\t\t\t\t    } \r\n\t\t\t\t\t\t    break;\r\n\t\t\t\t\t} \r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'service':\r\n\t\t\t\t\tswitch ($name) {\r\n\t\t\t\t\t    case 'port':\r\n\t\t\t\t\t        $this->currentPort = $attrs['name'];\r\n\t\t\t\t\t        $this->debug('current port: ' . $this->currentPort);\r\n\t\t\t\t\t        $this->ports[$this->currentPort]['binding'] = $this->getLocalPart($attrs['binding']);\r\n\t\t\t\t\t\r\n\t\t\t\t\t        break;\r\n\t\t\t\t\t    case 'address':\r\n\t\t\t\t\t        $this->ports[$this->currentPort]['location'] = $attrs['location'];\r\n\t\t\t\t\t        $this->ports[$this->currentPort]['bindingType'] = $namespace;\r\n\t\t\t\t\t        $this->bindings[ $this->ports[$this->currentPort]['binding'] ]['bindingType'] = $namespace;\r\n\t\t\t\t\t        $this->bindings[ $this->ports[$this->currentPort]['binding'] ]['endpoint'] = $attrs['location'];\r\n\t\t\t\t\t        break;\r\n\t\t\t\t\t} \r\n\t\t\t\t\tbreak;\r\n\t\t\t} \r\n\t\t// set status\r\n\t\tswitch ($name) {\r\n\t\t\tcase 'import':\r\n\t\t\t    if (isset($attrs['location'])) {\r\n                    $this->import[$attrs['namespace']][] = array('location' => $attrs['location'], 'loaded' => false);\r\n                    $this->debug('parsing import ' . $attrs['namespace']. ' - ' . $attrs['location'] . ' (' . count($this->import[$attrs['namespace']]).')');\r\n\t\t\t\t} else {\r\n                    $this->import[$attrs['namespace']][] = array('location' => '', 'loaded' => true);\r\n\t\t\t\t\tif (! $this->getPrefixFromNamespace($attrs['namespace'])) {\r\n\t\t\t\t\t\t$this->namespaces['ns'.(count($this->namespaces)+1)] = $attrs['namespace'];\r\n\t\t\t\t\t}\r\n                    $this->debug('parsing import ' . $attrs['namespace']. ' - [no location] (' . count($this->import[$attrs['namespace']]).')');\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t//wait for schema\r\n\t\t\t//case 'types':\r\n\t\t\t//\t$this->status = 'schema';\r\n\t\t\t//\tbreak;\r\n\t\t\tcase 'message':\r\n\t\t\t\t$this->status = 'message';\r\n\t\t\t\t$this->messages[$attrs['name']] = array();\r\n\t\t\t\t$this->currentMessage = $attrs['name'];\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'portType':\r\n\t\t\t\t$this->status = 'portType';\r\n\t\t\t\t$this->portTypes[$attrs['name']] = array();\r\n\t\t\t\t$this->currentPortType = $attrs['name'];\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"binding\":\r\n\t\t\t\tif (isset($attrs['name'])) {\r\n\t\t\t\t// get binding name\r\n\t\t\t\t\tif (strpos($attrs['name'], ':')) {\r\n\t\t\t    \t\t$this->currentBinding = $this->getLocalPart($attrs['name']);\r\n\t\t\t\t\t} else {\r\n\t\t\t    \t\t$this->currentBinding = $attrs['name'];\r\n\t\t\t\t\t} \r\n\t\t\t\t\t$this->status = 'binding';\r\n\t\t\t\t\t$this->bindings[$this->currentBinding]['portType'] = $this->getLocalPart($attrs['type']);\r\n\t\t\t\t\t$this->debug(\"current binding: $this->currentBinding of portType: \" . $attrs['type']);\r\n\t\t\t\t} \r\n\t\t\t\tbreak;\r\n\t\t\tcase 'service':\r\n\t\t\t\t$this->serviceName = $attrs['name'];\r\n\t\t\t\t$this->status = 'service';\r\n\t\t\t\t$this->debug('current service: ' . $this->serviceName);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'definitions':\r\n\t\t\t\tforeach ($attrs as $name => $value) {\r\n\t\t\t\t\t$this->wsdl_info[$name] = $value;\r\n\t\t\t\t} \r\n\t\t\t\tbreak;\r\n\t\t\t} \r\n\t\t} \r\n\t} \r\n\r\n\t/**\r\n\t* end-element handler\r\n\t* \r\n\t* @param string $parser XML parser object\r\n\t* @param string $name element name\r\n\t* @access private \r\n\t*/\r\n\tfunction end_element($parser, $name){ \r\n\t\t// unset schema status\r\n\t\tif (/*ereg('types$', $name) ||*/ ereg('schema$', $name)) {\r\n\t\t\t$this->status = \"\";\r\n            $this->appendDebug($this->currentSchema->getDebug());\r\n            $this->currentSchema->clearDebug();\r\n\t\t\t$this->schemas[$this->currentSchema->schemaTargetNamespace][] = $this->currentSchema;\r\n        \t$this->debug('Parsing WSDL schema done');\r\n\t\t} \r\n\t\tif ($this->status == 'schema') {\r\n\t\t\t$this->currentSchema->schemaEndElement($parser, $name);\r\n\t\t} else {\r\n\t\t\t// bring depth down a notch\r\n\t\t\t$this->depth--;\r\n\t\t} \r\n\t\t// end documentation\r\n\t\tif ($this->documentation) {\r\n\t\t\t//TODO: track the node to which documentation should be assigned; it can be a part, message, etc.\r\n\t\t\t//$this->portTypes[$this->currentPortType][$this->currentPortOperation]['documentation'] = $this->documentation;\r\n\t\t\t$this->documentation = false;\r\n\t\t} \r\n\t} \r\n\r\n\t/**\r\n\t * element content handler\r\n\t * \r\n\t * @param string $parser XML parser object\r\n\t * @param string $data element content\r\n\t * @access private \r\n\t */\r\n\tfunction character_data($parser, $data)\r\n\t{\r\n\t\t$pos = isset($this->depth_array[$this->depth]) ? $this->depth_array[$this->depth] : 0;\r\n\t\tif (isset($this->message[$pos]['cdata'])) {\r\n\t\t\t$this->message[$pos]['cdata'] .= $data;\r\n\t\t} \r\n\t\tif ($this->documentation) {\r\n\t\t\t$this->documentation .= $data;\r\n\t\t} \r\n\t} \r\n\t\r\n\t/**\r\n\t* if authenticating, set user credentials here\r\n\t*\r\n\t* @param    string $username\r\n\t* @param    string $password\r\n\t* @param\tstring $authtype (basic|digest|certificate|ntlm)\r\n\t* @param\tarray $certRequest (keys must be cainfofile (optional), sslcertfile, sslkeyfile, passphrase, certpassword (optional), verifypeer (optional), verifyhost (optional): see corresponding options in cURL docs)\r\n\t* @access   public\r\n\t*/\r\n\tfunction setCredentials($username, $password, $authtype = 'basic', $certRequest = array()) {\r\n\t\t$this->debug(\"setCredentials username=$username authtype=$authtype certRequest=\");\r\n\t\t$this->appendDebug($this->varDump($certRequest));\r\n\t\t$this->username = $username;\r\n\t\t$this->password = $password;\r\n\t\t$this->authtype = $authtype;\r\n\t\t$this->certRequest = $certRequest;\r\n\t}\r\n\t\r\n\tfunction getBindingData($binding)\r\n\t{\r\n\t\tif (is_array($this->bindings[$binding])) {\r\n\t\t\treturn $this->bindings[$binding];\r\n\t\t} \r\n\t}\r\n\t\r\n\t/**\r\n\t * returns an assoc array of operation names => operation data\r\n\t * \r\n\t * @param string $bindingType eg: soap, smtp, dime (only soap and soap12 are currently supported)\r\n\t * @return array \r\n\t * @access public \r\n\t */\r\n\tfunction getOperations($bindingType = 'soap') {\r\n\t\t$ops = array();\r\n\t\tif ($bindingType == 'soap') {\r\n\t\t\t$bindingType = 'http://schemas.xmlsoap.org/wsdl/soap/';\r\n\t\t} elseif ($bindingType == 'soap12') {\r\n\t\t\t$bindingType = 'http://schemas.xmlsoap.org/wsdl/soap12/';\r\n\t\t}\r\n\t\t// loop thru ports\r\n\t\tforeach($this->ports as $port => $portData) {\r\n\t\t\t// binding type of port matches parameter\r\n\t\t\tif ($portData['bindingType'] == $bindingType) {\r\n\t\t\t\t//$this->debug(\"getOperations for port $port\");\r\n\t\t\t\t//$this->debug(\"port data: \" . $this->varDump($portData));\r\n\t\t\t\t//$this->debug(\"bindings: \" . $this->varDump($this->bindings[ $portData['binding'] ]));\r\n\t\t\t\t// merge bindings\r\n\t\t\t\tif (isset($this->bindings[ $portData['binding'] ]['operations'])) {\r\n\t\t\t\t\t$ops = array_merge ($ops, $this->bindings[ $portData['binding'] ]['operations']);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} \r\n\t\treturn $ops;\r\n\t} \r\n\t\r\n\t/**\r\n\t * returns an associative array of data necessary for calling an operation\r\n\t * \r\n\t * @param string $operation name of operation\r\n\t * @param string $bindingType type of binding eg: soap, soap12\r\n\t * @return array \r\n\t * @access public \r\n\t */\r\n\tfunction getOperationData($operation, $bindingType = 'soap')\r\n\t{\r\n\t\tif ($bindingType == 'soap') {\r\n\t\t\t$bindingType = 'http://schemas.xmlsoap.org/wsdl/soap/';\r\n\t\t} elseif ($bindingType == 'soap12') {\r\n\t\t\t$bindingType = 'http://schemas.xmlsoap.org/wsdl/soap12/';\r\n\t\t}\r\n\t\t// loop thru ports\r\n\t\tforeach($this->ports as $port => $portData) {\r\n\t\t\t// binding type of port matches parameter\r\n\t\t\tif ($portData['bindingType'] == $bindingType) {\r\n\t\t\t\t// get binding\r\n\t\t\t\t//foreach($this->bindings[ $portData['binding'] ]['operations'] as $bOperation => $opData) {\r\n\t\t\t\tforeach(array_keys($this->bindings[ $portData['binding'] ]['operations']) as $bOperation) {\r\n\t\t\t\t\t// note that we could/should also check the namespace here\r\n\t\t\t\t\tif ($operation == $bOperation) {\r\n\t\t\t\t\t\t$opData = $this->bindings[ $portData['binding'] ]['operations'][$operation];\r\n\t\t\t\t\t    return $opData;\r\n\t\t\t\t\t} \r\n\t\t\t\t} \r\n\t\t\t}\r\n\t\t} \r\n\t}\r\n\t\r\n\t/**\r\n\t * returns an associative array of data necessary for calling an operation\r\n\t * \r\n\t * @param string $soapAction soapAction for operation\r\n\t * @param string $bindingType type of binding eg: soap, soap12\r\n\t * @return array \r\n\t * @access public \r\n\t */\r\n\tfunction getOperationDataForSoapAction($soapAction, $bindingType = 'soap') {\r\n\t\tif ($bindingType == 'soap') {\r\n\t\t\t$bindingType = 'http://schemas.xmlsoap.org/wsdl/soap/';\r\n\t\t} elseif ($bindingType == 'soap12') {\r\n\t\t\t$bindingType = 'http://schemas.xmlsoap.org/wsdl/soap12/';\r\n\t\t}\r\n\t\t// loop thru ports\r\n\t\tforeach($this->ports as $port => $portData) {\r\n\t\t\t// binding type of port matches parameter\r\n\t\t\tif ($portData['bindingType'] == $bindingType) {\r\n\t\t\t\t// loop through operations for the binding\r\n\t\t\t\tforeach ($this->bindings[ $portData['binding'] ]['operations'] as $bOperation => $opData) {\r\n\t\t\t\t\tif ($opData['soapAction'] == $soapAction) {\r\n\t\t\t\t\t    return $opData;\r\n\t\t\t\t\t} \r\n\t\t\t\t} \r\n\t\t\t}\r\n\t\t} \r\n\t}\r\n\t\r\n\t/**\r\n    * returns an array of information about a given type\r\n    * returns false if no type exists by the given name\r\n    *\r\n\t*\t typeDef = array(\r\n\t*\t 'elements' => array(), // refs to elements array\r\n\t*\t'restrictionBase' => '',\r\n\t*\t'phpType' => '',\r\n\t*\t'order' => '(sequence|all)',\r\n\t*\t'attrs' => array() // refs to attributes array\r\n\t*\t)\r\n    *\r\n    * @param string $type the type\r\n    * @param string $ns namespace (not prefix) of the type\r\n    * @return mixed\r\n    * @access public\r\n    * @see nusoap_xmlschema\r\n    */\r\n\tfunction getTypeDef($type, $ns) {\r\n\t\t$this->debug(\"in getTypeDef: type=$type, ns=$ns\");\r\n\t\tif ((! $ns) && isset($this->namespaces['tns'])) {\r\n\t\t\t$ns = $this->namespaces['tns'];\r\n\t\t\t$this->debug(\"in getTypeDef: type namespace forced to $ns\");\r\n\t\t}\r\n\t\tif (!isset($this->schemas[$ns])) {\r\n\t\t\tforeach ($this->schemas as $ns0 => $schema0) {\r\n\t\t\t\tif (strcasecmp($ns, $ns0) == 0) {\r\n\t\t\t\t\t$this->debug(\"in getTypeDef: replacing schema namespace $ns with $ns0\");\r\n\t\t\t\t\t$ns = $ns0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (isset($this->schemas[$ns])) {\r\n\t\t\t$this->debug(\"in getTypeDef: have schema for namespace $ns\");\r\n\t\t\tfor ($i = 0; $i < count($this->schemas[$ns]); $i++) {\r\n\t\t\t\t$xs = &$this->schemas[$ns][$i];\r\n\t\t\t\t$t = $xs->getTypeDef($type);\r\n\t\t\t\t//$this->appendDebug($xs->getDebug());\r\n\t\t\t\t//$xs->clearDebug();\r\n\t\t\t\tif ($t) {\r\n\t\t\t\t\tif (!isset($t['phpType'])) {\r\n\t\t\t\t\t\t// get info for type to tack onto the element\r\n\t\t\t\t\t\t$uqType = substr($t['type'], strrpos($t['type'], ':') + 1);\r\n\t\t\t\t\t\t$ns = substr($t['type'], 0, strrpos($t['type'], ':'));\r\n\t\t\t\t\t\t$etype = $this->getTypeDef($uqType, $ns);\r\n\t\t\t\t\t\tif ($etype) {\r\n\t\t\t\t\t\t\t$this->debug(\"found type for [element] $type:\");\r\n\t\t\t\t\t\t\t$this->debug($this->varDump($etype));\r\n\t\t\t\t\t\t\tif (isset($etype['phpType'])) {\r\n\t\t\t\t\t\t\t\t$t['phpType'] = $etype['phpType'];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (isset($etype['elements'])) {\r\n\t\t\t\t\t\t\t\t$t['elements'] = $etype['elements'];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (isset($etype['attrs'])) {\r\n\t\t\t\t\t\t\t\t$t['attrs'] = $etype['attrs'];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn $t;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t$this->debug(\"in getTypeDef: do not have schema for namespace $ns\");\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n    /**\r\n    * prints html description of services\r\n    *\r\n    * @access private\r\n    */\r\n    function webDescription(){\r\n    \tglobal $HTTP_SERVER_VARS;\r\n\r\n\t\tif (isset($_SERVER)) {\r\n\t\t\t$PHP_SELF = $_SERVER['PHP_SELF'];\r\n\t\t} elseif (isset($HTTP_SERVER_VARS)) {\r\n\t\t\t$PHP_SELF = $HTTP_SERVER_VARS['PHP_SELF'];\r\n\t\t} else {\r\n\t\t\t$this->setError(\"Neither _SERVER nor HTTP_SERVER_VARS is available\");\r\n\t\t}\r\n\r\n\t\t$b = '\r\n\t\t<html><head><title>NuSOAP: '.$this->serviceName.'</title>\r\n\t\t<style type=\"text/css\">\r\n\t\t    body    { font-family: arial; color: #000000; background-color: #ffffff; margin: 0px 0px 0px 0px; }\r\n\t\t    p       { font-family: arial; color: #000000; margin-top: 0px; margin-bottom: 12px; }\r\n\t\t    pre { background-color: silver; padding: 5px; font-family: Courier New; font-size: x-small; color: #000000;}\r\n\t\t    ul      { margin-top: 10px; margin-left: 20px; }\r\n\t\t    li      { list-style-type: none; margin-top: 10px; color: #000000; }\r\n\t\t    .content{\r\n\t\t\tmargin-left: 0px; padding-bottom: 2em; }\r\n\t\t    .nav {\r\n\t\t\tpadding-top: 10px; padding-bottom: 10px; padding-left: 15px; font-size: .70em;\r\n\t\t\tmargin-top: 10px; margin-left: 0px; color: #000000;\r\n\t\t\tbackground-color: #ccccff; width: 20%; margin-left: 20px; margin-top: 20px; }\r\n\t\t    .title {\r\n\t\t\tfont-family: arial; font-size: 26px; color: #ffffff;\r\n\t\t\tbackground-color: #999999; width: 105%; margin-left: 0px;\r\n\t\t\tpadding-top: 10px; padding-bottom: 10px; padding-left: 15px;}\r\n\t\t    .hidden {\r\n\t\t\tposition: absolute; visibility: hidden; z-index: 200; left: 250px; top: 100px;\r\n\t\t\tfont-family: arial; overflow: hidden; width: 600;\r\n\t\t\tpadding: 20px; font-size: 10px; background-color: #999999;\r\n\t\t\tlayer-background-color:#FFFFFF; }\r\n\t\t    a,a:active  { color: charcoal; font-weight: bold; }\r\n\t\t    a:visited   { color: #666666; font-weight: bold; }\r\n\t\t    a:hover     { color: cc3300; font-weight: bold; }\r\n\t\t</style>\r\n\t\t<script language=\"JavaScript\" type=\"text/javascript\">\r\n\t\t<!--\r\n\t\t// POP-UP CAPTIONS...\r\n\t\tfunction lib_bwcheck(){ //Browsercheck (needed)\r\n\t\t    this.ver=navigator.appVersion\r\n\t\t    this.agent=navigator.userAgent\r\n\t\t    this.dom=document.getElementById?1:0\r\n\t\t    this.opera5=this.agent.indexOf(\"Opera 5\")>-1\r\n\t\t    this.ie5=(this.ver.indexOf(\"MSIE 5\")>-1 && this.dom && !this.opera5)?1:0;\r\n\t\t    this.ie6=(this.ver.indexOf(\"MSIE 6\")>-1 && this.dom && !this.opera5)?1:0;\r\n\t\t    this.ie4=(document.all && !this.dom && !this.opera5)?1:0;\r\n\t\t    this.ie=this.ie4||this.ie5||this.ie6\r\n\t\t    this.mac=this.agent.indexOf(\"Mac\")>-1\r\n\t\t    this.ns6=(this.dom && parseInt(this.ver) >= 5) ?1:0;\r\n\t\t    this.ns4=(document.layers && !this.dom)?1:0;\r\n\t\t    this.bw=(this.ie6 || this.ie5 || this.ie4 || this.ns4 || this.ns6 || this.opera5)\r\n\t\t    return this\r\n\t\t}\r\n\t\tvar bw = new lib_bwcheck()\r\n\t\t//Makes crossbrowser object.\r\n\t\tfunction makeObj(obj){\r\n\t\t    this.evnt=bw.dom? document.getElementById(obj):bw.ie4?document.all[obj]:bw.ns4?document.layers[obj]:0;\r\n\t\t    if(!this.evnt) return false\r\n\t\t    this.css=bw.dom||bw.ie4?this.evnt.style:bw.ns4?this.evnt:0;\r\n\t\t    this.wref=bw.dom||bw.ie4?this.evnt:bw.ns4?this.css.document:0;\r\n\t\t    this.writeIt=b_writeIt;\r\n\t\t    return this\r\n\t\t}\r\n\t\t// A unit of measure that will be added when setting the position of a layer.\r\n\t\t//var px = bw.ns4||window.opera?\"\":\"px\";\r\n\t\tfunction b_writeIt(text){\r\n\t\t    if (bw.ns4){this.wref.write(text);this.wref.close()}\r\n\t\t    else this.wref.innerHTML = text\r\n\t\t}\r\n\t\t//Shows the messages\r\n\t\tvar oDesc;\r\n\t\tfunction popup(divid){\r\n\t\t    if(oDesc = new makeObj(divid)){\r\n\t\t\toDesc.css.visibility = \"visible\"\r\n\t\t    }\r\n\t\t}\r\n\t\tfunction popout(){ // Hides message\r\n\t\t    if(oDesc) oDesc.css.visibility = \"hidden\"\r\n\t\t}\r\n\t\t//-->\r\n\t\t</script>\r\n\t\t</head>\r\n\t\t<body>\r\n\t\t<div class=content>\r\n\t\t\t<br><br>\r\n\t\t\t<div class=title>'.$this->serviceName.'</div>\r\n\t\t\t<div class=nav>\r\n\t\t\t\t<p>View the <a href=\"'.$PHP_SELF.'?wsdl\">WSDL</a> for the service.\r\n\t\t\t\tClick on an operation name to view it&apos;s details.</p>\r\n\t\t\t\t<ul>';\r\n\t\t\t\tforeach($this->getOperations() as $op => $data){\r\n\t\t\t\t    $b .= \"<li><a href='#' onclick=\\\"popout();popup('$op')\\\">$op</a></li>\";\r\n\t\t\t\t    // create hidden div\r\n\t\t\t\t    $b .= \"<div id='$op' class='hidden'>\r\n\t\t\t\t    <a href='#' onclick='popout()'><font color='#ffffff'>Close</font></a><br><br>\";\r\n\t\t\t\t    foreach($data as $donnie => $marie){ // loop through opdata\r\n\t\t\t\t\t\tif($donnie == 'input' || $donnie == 'output'){ // show input/output data\r\n\t\t\t\t\t\t    $b .= \"<font color='white'>\".ucfirst($donnie).':</font><br>';\r\n\t\t\t\t\t\t    foreach($marie as $captain => $tenille){ // loop through data\r\n\t\t\t\t\t\t\t\tif($captain == 'parts'){ // loop thru parts\r\n\t\t\t\t\t\t\t\t    $b .= \"&nbsp;&nbsp;$captain:<br>\";\r\n\t\t\t\t\t                //if(is_array($tenille)){\r\n\t\t\t\t\t\t\t\t    \tforeach($tenille as $joanie => $chachi){\r\n\t\t\t\t\t\t\t\t\t\t\t$b .= \"&nbsp;&nbsp;&nbsp;&nbsp;$joanie: $chachi<br>\";\r\n\t\t\t\t\t\t\t\t    \t}\r\n\t\t\t\t\t        \t\t//}\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t    $b .= \"&nbsp;&nbsp;$captain: $tenille<br>\";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t    }\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t    $b .= \"<font color='white'>\".ucfirst($donnie).\":</font> $marie<br>\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t    }\r\n\t\t\t\t\t$b .= '</div>';\r\n\t\t\t\t}\r\n\t\t\t\t$b .= '\r\n\t\t\t\t<ul>\r\n\t\t\t</div>\r\n\t\t</div></body></html>';\r\n\t\treturn $b;\r\n    }\r\n\r\n\t/**\r\n\t* serialize the parsed wsdl\r\n\t*\r\n\t* @param mixed $debug whether to put debug=1 in endpoint URL\r\n\t* @return string serialization of WSDL\r\n\t* @access public \r\n\t*/\r\n\tfunction serialize($debug = 0)\r\n\t{\r\n\t\t$xml = '<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>';\r\n\t\t$xml .= \"\\n<definitions\";\r\n\t\tforeach($this->namespaces as $k => $v) {\r\n\t\t\t$xml .= \" xmlns:$k=\\\"$v\\\"\";\r\n\t\t} \r\n\t\t// 10.9.02 - add poulter fix for wsdl and tns declarations\r\n\t\tif (isset($this->namespaces['wsdl'])) {\r\n\t\t\t$xml .= \" xmlns=\\\"\" . $this->namespaces['wsdl'] . \"\\\"\";\r\n\t\t} \r\n\t\tif (isset($this->namespaces['tns'])) {\r\n\t\t\t$xml .= \" targetNamespace=\\\"\" . $this->namespaces['tns'] . \"\\\"\";\r\n\t\t} \r\n\t\t$xml .= '>'; \r\n\t\t// imports\r\n\t\tif (sizeof($this->import) > 0) {\r\n\t\t\tforeach($this->import as $ns => $list) {\r\n\t\t\t\tforeach ($list as $ii) {\r\n\t\t\t\t\tif ($ii['location'] != '') {\r\n\t\t\t\t\t\t$xml .= '<import location=\"' . $ii['location'] . '\" namespace=\"' . $ns . '\" />';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$xml .= '<import namespace=\"' . $ns . '\" />';\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} \r\n\t\t} \r\n\t\t// types\r\n\t\tif (count($this->schemas)>=1) {\r\n\t\t\t$xml .= \"\\n<types>\\n\";\r\n\t\t\tforeach ($this->schemas as $ns => $list) {\r\n\t\t\t\tforeach ($list as $xs) {\r\n\t\t\t\t\t$xml .= $xs->serializeSchema();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t$xml .= '</types>';\r\n\t\t} \r\n\t\t// messages\r\n\t\tif (count($this->messages) >= 1) {\r\n\t\t\tforeach($this->messages as $msgName => $msgParts) {\r\n\t\t\t\t$xml .= \"\\n<message name=\\\"\" . $msgName . '\">';\r\n\t\t\t\tif(is_array($msgParts)){\r\n\t\t\t\t\tforeach($msgParts as $partName => $partType) {\r\n\t\t\t\t\t\t// print 'serializing '.$partType.', sv: '.$this->XMLSchemaVersion.'<br>';\r\n\t\t\t\t\t\tif (strpos($partType, ':')) {\r\n\t\t\t\t\t\t    $typePrefix = $this->getPrefixFromNamespace($this->getPrefix($partType));\r\n\t\t\t\t\t\t} elseif (isset($this->typemap[$this->namespaces['xsd']][$partType])) {\r\n\t\t\t\t\t\t    // print 'checking typemap: '.$this->XMLSchemaVersion.'<br>';\r\n\t\t\t\t\t\t    $typePrefix = 'xsd';\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t    foreach($this->typemap as $ns => $types) {\r\n\t\t\t\t\t\t        if (isset($types[$partType])) {\r\n\t\t\t\t\t\t            $typePrefix = $this->getPrefixFromNamespace($ns);\r\n\t\t\t\t\t\t        } \r\n\t\t\t\t\t\t    } \r\n\t\t\t\t\t\t    if (!isset($typePrefix)) {\r\n\t\t\t\t\t\t        die(\"$partType has no namespace!\");\r\n\t\t\t\t\t\t    } \r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t$ns = $this->getNamespaceFromPrefix($typePrefix);\r\n\t\t\t\t\t\t$localPart = $this->getLocalPart($partType);\r\n\t\t\t\t\t\t$typeDef = $this->getTypeDef($localPart, $ns);\r\n\t\t\t\t\t\tif ($typeDef['typeClass'] == 'element') {\r\n\t\t\t\t\t\t\t$elementortype = 'element';\r\n\t\t\t\t\t\t\tif (substr($localPart, -1) == '^') {\r\n\t\t\t\t\t\t\t\t$localPart = substr($localPart, 0, -1);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t$elementortype = 'type';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t$xml .= \"\\n\" . '  <part name=\"' . $partName . '\" ' . $elementortype . '=\"' . $typePrefix . ':' . $localPart . '\" />';\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t$xml .= '</message>';\r\n\t\t\t} \r\n\t\t} \r\n\t\t// bindings & porttypes\r\n\t\tif (count($this->bindings) >= 1) {\r\n\t\t\t$binding_xml = '';\r\n\t\t\t$portType_xml = '';\r\n\t\t\tforeach($this->bindings as $bindingName => $attrs) {\r\n\t\t\t\t$binding_xml .= \"\\n<binding name=\\\"\" . $bindingName . '\" type=\"tns:' . $attrs['portType'] . '\">';\r\n\t\t\t\t$binding_xml .= \"\\n\" . '  <soap:binding style=\"' . $attrs['style'] . '\" transport=\"' . $attrs['transport'] . '\"/>';\r\n\t\t\t\t$portType_xml .= \"\\n<portType name=\\\"\" . $attrs['portType'] . '\">';\r\n\t\t\t\tforeach($attrs['operations'] as $opName => $opParts) {\r\n\t\t\t\t\t$binding_xml .= \"\\n\" . '  <operation name=\"' . $opName . '\">';\r\n\t\t\t\t\t$binding_xml .= \"\\n\" . '    <soap:operation soapAction=\"' . $opParts['soapAction'] . '\" style=\"'. $opParts['style'] . '\"/>';\r\n\t\t\t\t\tif (isset($opParts['input']['encodingStyle']) && $opParts['input']['encodingStyle'] != '') {\r\n\t\t\t\t\t\t$enc_style = ' encodingStyle=\"' . $opParts['input']['encodingStyle'] . '\"';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$enc_style = '';\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$binding_xml .= \"\\n\" . '    <input><soap:body use=\"' . $opParts['input']['use'] . '\" namespace=\"' . $opParts['input']['namespace'] . '\"' . $enc_style . '/></input>';\r\n\t\t\t\t\tif (isset($opParts['output']['encodingStyle']) && $opParts['output']['encodingStyle'] != '') {\r\n\t\t\t\t\t\t$enc_style = ' encodingStyle=\"' . $opParts['output']['encodingStyle'] . '\"';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$enc_style = '';\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$binding_xml .= \"\\n\" . '    <output><soap:body use=\"' . $opParts['output']['use'] . '\" namespace=\"' . $opParts['output']['namespace'] . '\"' . $enc_style . '/></output>';\r\n\t\t\t\t\t$binding_xml .= \"\\n\" . '  </operation>';\r\n\t\t\t\t\t$portType_xml .= \"\\n\" . '  <operation name=\"' . $opParts['name'] . '\"';\r\n\t\t\t\t\tif (isset($opParts['parameterOrder'])) {\r\n\t\t\t\t\t    $portType_xml .= ' parameterOrder=\"' . $opParts['parameterOrder'] . '\"';\r\n\t\t\t\t\t} \r\n\t\t\t\t\t$portType_xml .= '>';\r\n\t\t\t\t\tif(isset($opParts['documentation']) && $opParts['documentation'] != '') {\r\n\t\t\t\t\t\t$portType_xml .= \"\\n\" . '    <documentation>' . htmlspecialchars($opParts['documentation']) . '</documentation>';\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$portType_xml .= \"\\n\" . '    <input message=\"tns:' . $opParts['input']['message'] . '\"/>';\r\n\t\t\t\t\t$portType_xml .= \"\\n\" . '    <output message=\"tns:' . $opParts['output']['message'] . '\"/>';\r\n\t\t\t\t\t$portType_xml .= \"\\n\" . '  </operation>';\r\n\t\t\t\t} \r\n\t\t\t\t$portType_xml .= \"\\n\" . '</portType>';\r\n\t\t\t\t$binding_xml .= \"\\n\" . '</binding>';\r\n\t\t\t} \r\n\t\t\t$xml .= $portType_xml . $binding_xml;\r\n\t\t} \r\n\t\t// services\r\n\t\t$xml .= \"\\n<service name=\\\"\" . $this->serviceName . '\">';\r\n\t\tif (count($this->ports) >= 1) {\r\n\t\t\tforeach($this->ports as $pName => $attrs) {\r\n\t\t\t\t$xml .= \"\\n\" . '  <port name=\"' . $pName . '\" binding=\"tns:' . $attrs['binding'] . '\">';\r\n\t\t\t\t$xml .= \"\\n\" . '    <soap:address location=\"' . $attrs['location'] . ($debug ? '?debug=1' : '') . '\"/>';\r\n\t\t\t\t$xml .= \"\\n\" . '  </port>';\r\n\t\t\t} \r\n\t\t} \r\n\t\t$xml .= \"\\n\" . '</service>';\r\n\t\treturn $xml . \"\\n</definitions>\";\r\n\t} \r\n\r\n\t/**\r\n\t * determine whether a set of parameters are unwrapped\r\n\t * when they are expect to be wrapped, Microsoft-style.\r\n\t *\r\n\t * @param string $type the type (element name) of the wrapper\r\n\t * @param array $parameters the parameter values for the SOAP call\r\n\t * @return boolean whether they parameters are unwrapped (and should be wrapped)\r\n\t * @access private\r\n\t */\r\n\tfunction parametersMatchWrapped($type, &$parameters) {\r\n\t\t$this->debug(\"in parametersMatchWrapped type=$type, parameters=\");\r\n\t\t$this->appendDebug($this->varDump($parameters));\r\n\r\n\t\t// split type into namespace:unqualified-type\r\n\t\tif (strpos($type, ':')) {\r\n\t\t\t$uqType = substr($type, strrpos($type, ':') + 1);\r\n\t\t\t$ns = substr($type, 0, strrpos($type, ':'));\r\n\t\t\t$this->debug(\"in parametersMatchWrapped: got a prefixed type: $uqType, $ns\");\r\n\t\t\tif ($this->getNamespaceFromPrefix($ns)) {\r\n\t\t\t\t$ns = $this->getNamespaceFromPrefix($ns);\r\n\t\t\t\t$this->debug(\"in parametersMatchWrapped: expanded prefixed type: $uqType, $ns\");\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// TODO: should the type be compared to types in XSD, and the namespace\r\n\t\t\t// set to XSD if the type matches?\r\n\t\t\t$this->debug(\"in parametersMatchWrapped: No namespace for type $type\");\r\n\t\t\t$ns = '';\r\n\t\t\t$uqType = $type;\r\n\t\t}\r\n\r\n\t\t// get the type information\r\n\t\tif (!$typeDef = $this->getTypeDef($uqType, $ns)) {\r\n\t\t\t$this->debug(\"in parametersMatchWrapped: $type ($uqType) is not a supported type.\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t$this->debug(\"in parametersMatchWrapped: found typeDef=\");\r\n\t\t$this->appendDebug($this->varDump($typeDef));\r\n\t\tif (substr($uqType, -1) == '^') {\r\n\t\t\t$uqType = substr($uqType, 0, -1);\r\n\t\t}\r\n\t\t$phpType = $typeDef['phpType'];\r\n\t\t$arrayType = (isset($typeDef['arrayType']) ? $typeDef['arrayType'] : '');\r\n\t\t$this->debug(\"in parametersMatchWrapped: uqType: $uqType, ns: $ns, phptype: $phpType, arrayType: $arrayType\");\r\n\t\t\r\n\t\t// we expect a complexType or element of complexType\r\n\t\tif ($phpType != 'struct') {\r\n\t\t\t$this->debug(\"in parametersMatchWrapped: not a struct\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// see whether the parameter names match the elements\r\n\t\tif (isset($typeDef['elements']) && is_array($typeDef['elements'])) {\r\n\t\t\t$elements = 0;\r\n\t\t\t$matches = 0;\r\n\t\t\t$change = false;\r\n\t\t\tif ($this->isArraySimpleOrStruct($parameters) == 'arraySimple' && count($parameters) == count($typeDef['elements'])) {\r\n\t\t\t\t$this->debug(\"in parametersMatchWrapped: (wrapped return value kludge) correct number of elements in simple array, so change array and wrap\");\r\n\t\t\t\t$change = true;\r\n\t\t\t}\r\n\t\t\tforeach ($typeDef['elements'] as $name => $attrs) {\r\n\t\t\t\tif ($change) {\r\n\t\t\t\t\t$this->debug(\"in parametersMatchWrapped: change parameter $element to name $name\");\r\n\t\t\t\t\t$parameters[$name] = $parameters[$elements];\r\n\t\t\t\t\tunset($parameters[$elements]);\r\n\t\t\t\t\t$matches++;\r\n\t\t\t\t} elseif (isset($parameters[$name])) {\r\n\t\t\t\t\t$this->debug(\"in parametersMatchWrapped: have parameter named $name\");\r\n\t\t\t\t\t$matches++;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$this->debug(\"in parametersMatchWrapped: do not have parameter named $name\");\r\n\t\t\t\t}\r\n\t\t\t\t$elements++;\r\n\t\t\t}\r\n\r\n\t\t\t$this->debug(\"in parametersMatchWrapped: $matches parameter names match $elements wrapped parameter names\");\r\n\t\t\tif ($matches == 0) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// since there are no elements for the type, if the user passed no\r\n\t\t// parameters, the parameters match wrapped.\r\n\t\t$this->debug(\"in parametersMatchWrapped: no elements type $ns:$uqType\");\r\n\t\treturn count($parameters) == 0;\r\n\t}\r\n\r\n\t/**\r\n\t * serialize PHP values according to a WSDL message definition\r\n\t * contrary to the method name, this is not limited to RPC\r\n\t *\r\n\t * TODO\r\n\t * - multi-ref serialization\r\n\t * - validate PHP values against type definitions, return errors if invalid\r\n\t * \r\n\t * @param string $operation operation name\r\n\t * @param string $direction (input|output)\r\n\t * @param mixed $parameters parameter value(s)\r\n\t * @param string $bindingType (soap|soap12)\r\n\t * @return mixed parameters serialized as XML or false on error (e.g. operation not found)\r\n\t * @access public\r\n\t */\r\n\tfunction serializeRPCParameters($operation, $direction, $parameters, $bindingType = 'soap') {\r\n\t\t$this->debug(\"in serializeRPCParameters: operation=$operation, direction=$direction, XMLSchemaVersion=$this->XMLSchemaVersion, bindingType=$bindingType\");\r\n\t\t$this->appendDebug('parameters=' . $this->varDump($parameters));\r\n\t\t\r\n\t\tif ($direction != 'input' && $direction != 'output') {\r\n\t\t\t$this->debug('The value of the \\$direction argument needs to be either \"input\" or \"output\"');\r\n\t\t\t$this->setError('The value of the \\$direction argument needs to be either \"input\" or \"output\"');\r\n\t\t\treturn false;\r\n\t\t} \r\n\t\tif (!$opData = $this->getOperationData($operation, $bindingType)) {\r\n\t\t\t$this->debug('Unable to retrieve WSDL data for operation: ' . $operation . ' bindingType: ' . $bindingType);\r\n\t\t\t$this->setError('Unable to retrieve WSDL data for operation: ' . $operation . ' bindingType: ' . $bindingType);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t$this->debug('in serializeRPCParameters: opData:');\r\n\t\t$this->appendDebug($this->varDump($opData));\r\n\r\n\t\t// Get encoding style for output and set to current\r\n\t\t$encodingStyle = 'http://schemas.xmlsoap.org/soap/encoding/';\r\n\t\tif(($direction == 'input') && isset($opData['output']['encodingStyle']) && ($opData['output']['encodingStyle'] != $encodingStyle)) {\r\n\t\t\t$encodingStyle = $opData['output']['encodingStyle'];\r\n\t\t\t$enc_style = $encodingStyle;\r\n\t\t}\r\n\r\n\t\t// set input params\r\n\t\t$xml = '';\r\n\t\tif (isset($opData[$direction]['parts']) && sizeof($opData[$direction]['parts']) > 0) {\r\n\t\t\t$parts = &$opData[$direction]['parts'];\r\n\t\t\t$part_count = sizeof($parts);\r\n\t\t\t$style = $opData['style'];\r\n\t\t\t$use = $opData[$direction]['use'];\r\n\t\t\t$this->debug(\"have $part_count part(s) to serialize using $style/$use\");\r\n\t\t\tif (is_array($parameters)) {\r\n\t\t\t\t$parametersArrayType = $this->isArraySimpleOrStruct($parameters);\r\n\t\t\t\t$parameter_count = count($parameters);\r\n\t\t\t\t$this->debug(\"have $parameter_count parameter(s) provided as $parametersArrayType to serialize\");\r\n\t\t\t\t// check for Microsoft-style wrapped parameters\r\n\t\t\t\tif ($style == 'document' && $use == 'literal' && $part_count == 1 && isset($parts['parameters'])) {\r\n\t\t\t\t\t$this->debug('check whether the caller has wrapped the parameters');\r\n\t\t\t\t\tif ((($parametersArrayType == 'arrayStruct' || $parameter_count == 0) && !isset($parameters['parameters'])) || ($direction == 'output' && $parametersArrayType == 'arraySimple' && $parameter_count == 1)) {\r\n\t\t\t\t\t\t$this->debug('check whether caller\\'s parameters match the wrapped ones');\r\n\t\t\t\t\t\tif ($this->parametersMatchWrapped($parts['parameters'], $parameters)) {\r\n\t\t\t\t\t\t\t$this->debug('wrap the parameters for the caller');\r\n\t\t\t\t\t\t\t$parameters = array('parameters' => $parameters);\r\n\t\t\t\t\t\t\t$parameter_count = 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tforeach ($parts as $name => $type) {\r\n\t\t\t\t\t$this->debug(\"serializing part $name of type $type\");\r\n\t\t\t\t\t// Track encoding style\r\n\t\t\t\t\tif (isset($opData[$direction]['encodingStyle']) && $encodingStyle != $opData[$direction]['encodingStyle']) {\r\n\t\t\t\t\t\t$encodingStyle = $opData[$direction]['encodingStyle'];\t\t\t\r\n\t\t\t\t\t\t$enc_style = $encodingStyle;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$enc_style = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// NOTE: add error handling here\r\n\t\t\t\t\t// if serializeType returns false, then catch global error and fault\r\n\t\t\t\t\tif ($parametersArrayType == 'arraySimple') {\r\n\t\t\t\t\t\t$p = array_shift($parameters);\r\n\t\t\t\t\t\t$this->debug('calling serializeType w/indexed param');\r\n\t\t\t\t\t\t$xml .= $this->serializeType($name, $type, $p, $use, $enc_style);\r\n\t\t\t\t\t} elseif (isset($parameters[$name])) {\r\n\t\t\t\t\t\t$this->debug('calling serializeType w/named param');\r\n\t\t\t\t\t\t$xml .= $this->serializeType($name, $type, $parameters[$name], $use, $enc_style);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// TODO: only send nillable\r\n\t\t\t\t\t\t$this->debug('calling serializeType w/null param');\r\n\t\t\t\t\t\t$xml .= $this->serializeType($name, $type, null, $use, $enc_style);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t$this->debug('no parameters passed.');\r\n\t\t\t}\r\n\t\t}\r\n\t\t$this->debug(\"serializeRPCParameters returning: $xml\");\r\n\t\treturn $xml;\r\n\t} \r\n\t\r\n\t/**\r\n\t * serialize a PHP value according to a WSDL message definition\r\n\t * \r\n\t * TODO\r\n\t * - multi-ref serialization\r\n\t * - validate PHP values against type definitions, return errors if invalid\r\n\t * \r\n\t * @param string $operation operation name\r\n\t * @param string $direction (input|output)\r\n\t * @param mixed $parameters parameter value(s)\r\n\t * @return mixed parameters serialized as XML or false on error (e.g. operation not found)\r\n\t * @access public\r\n\t * @deprecated\r\n\t */\r\n\tfunction serializeParameters($operation, $direction, $parameters)\r\n\t{\r\n\t\t$this->debug(\"in serializeParameters: operation=$operation, direction=$direction, XMLSchemaVersion=$this->XMLSchemaVersion\"); \r\n\t\t$this->appendDebug('parameters=' . $this->varDump($parameters));\r\n\t\t\r\n\t\tif ($direction != 'input' && $direction != 'output') {\r\n\t\t\t$this->debug('The value of the \\$direction argument needs to be either \"input\" or \"output\"');\r\n\t\t\t$this->setError('The value of the \\$direction argument needs to be either \"input\" or \"output\"');\r\n\t\t\treturn false;\r\n\t\t} \r\n\t\tif (!$opData = $this->getOperationData($operation)) {\r\n\t\t\t$this->debug('Unable to retrieve WSDL data for operation: ' . $operation);\r\n\t\t\t$this->setError('Unable to retrieve WSDL data for operation: ' . $operation);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t$this->debug('opData:');\r\n\t\t$this->appendDebug($this->varDump($opData));\r\n\t\t\r\n\t\t// Get encoding style for output and set to current\r\n\t\t$encodingStyle = 'http://schemas.xmlsoap.org/soap/encoding/';\r\n\t\tif(($direction == 'input') && isset($opData['output']['encodingStyle']) && ($opData['output']['encodingStyle'] != $encodingStyle)) {\r\n\t\t\t$encodingStyle = $opData['output']['encodingStyle'];\r\n\t\t\t$enc_style = $encodingStyle;\r\n\t\t}\r\n\t\t\r\n\t\t// set input params\r\n\t\t$xml = '';\r\n\t\tif (isset($opData[$direction]['parts']) && sizeof($opData[$direction]['parts']) > 0) {\r\n\t\t\t\r\n\t\t\t$use = $opData[$direction]['use'];\r\n\t\t\t$this->debug(\"use=$use\");\r\n\t\t\t$this->debug('got ' . count($opData[$direction]['parts']) . ' part(s)');\r\n\t\t\tif (is_array($parameters)) {\r\n\t\t\t\t$parametersArrayType = $this->isArraySimpleOrStruct($parameters);\r\n\t\t\t\t$this->debug('have ' . $parametersArrayType . ' parameters');\r\n\t\t\t\tforeach($opData[$direction]['parts'] as $name => $type) {\r\n\t\t\t\t\t$this->debug('serializing part \"'.$name.'\" of type \"'.$type.'\"');\r\n\t\t\t\t\t// Track encoding style\r\n\t\t\t\t\tif(isset($opData[$direction]['encodingStyle']) && $encodingStyle != $opData[$direction]['encodingStyle']) {\r\n\t\t\t\t\t\t$encodingStyle = $opData[$direction]['encodingStyle'];\t\t\t\r\n\t\t\t\t\t\t$enc_style = $encodingStyle;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$enc_style = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// NOTE: add error handling here\r\n\t\t\t\t\t// if serializeType returns false, then catch global error and fault\r\n\t\t\t\t\tif ($parametersArrayType == 'arraySimple') {\r\n\t\t\t\t\t\t$p = array_shift($parameters);\r\n\t\t\t\t\t\t$this->debug('calling serializeType w/indexed param');\r\n\t\t\t\t\t\t$xml .= $this->serializeType($name, $type, $p, $use, $enc_style);\r\n\t\t\t\t\t} elseif (isset($parameters[$name])) {\r\n\t\t\t\t\t\t$this->debug('calling serializeType w/named param');\r\n\t\t\t\t\t\t$xml .= $this->serializeType($name, $type, $parameters[$name], $use, $enc_style);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// TODO: only send nillable\r\n\t\t\t\t\t\t$this->debug('calling serializeType w/null param');\r\n\t\t\t\t\t\t$xml .= $this->serializeType($name, $type, null, $use, $enc_style);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t$this->debug('no parameters passed.');\r\n\t\t\t}\r\n\t\t}\r\n\t\t$this->debug(\"serializeParameters returning: $xml\");\r\n\t\treturn $xml;\r\n\t} \r\n\t\r\n\t/**\r\n\t * serializes a PHP value according a given type definition\r\n\t * \r\n\t * @param string $name name of value (part or element)\r\n\t * @param string $type XML schema type of value (type or element)\r\n\t * @param mixed $value a native PHP value (parameter value)\r\n\t * @param string $use use for part (encoded|literal)\r\n\t * @param string $encodingStyle SOAP encoding style for the value (if different than the enclosing style)\r\n\t * @param boolean $unqualified a kludge for what should be XML namespace form handling\r\n\t * @return string value serialized as an XML string\r\n\t * @access private\r\n\t */\r\n\tfunction serializeType($name, $type, $value, $use='encoded', $encodingStyle=false, $unqualified=false)\r\n\t{\r\n\t\t$this->debug(\"in serializeType: name=$name, type=$type, use=$use, encodingStyle=$encodingStyle, unqualified=\" . ($unqualified ? \"unqualified\" : \"qualified\"));\r\n\t\t$this->appendDebug(\"value=\" . $this->varDump($value));\r\n\t\tif($use == 'encoded' && $encodingStyle) {\r\n\t\t\t$encodingStyle = ' SOAP-ENV:encodingStyle=\"' . $encodingStyle . '\"';\r\n\t\t}\r\n\r\n\t\t// if a soapval has been supplied, let its type override the WSDL\r\n    \tif (is_object($value) && get_class($value) == 'soapval') {\r\n    \t\tif ($value->type_ns) {\r\n    \t\t\t$type = $value->type_ns . ':' . $value->type;\r\n\t\t    \t$forceType = true;\r\n\t\t    \t$this->debug(\"in serializeType: soapval overrides type to $type\");\r\n    \t\t} elseif ($value->type) {\r\n\t    \t\t$type = $value->type;\r\n\t\t    \t$forceType = true;\r\n\t\t    \t$this->debug(\"in serializeType: soapval overrides type to $type\");\r\n\t    \t} else {\r\n\t    \t\t$forceType = false;\r\n\t\t    \t$this->debug(\"in serializeType: soapval does not override type\");\r\n\t    \t}\r\n\t    \t$attrs = $value->attributes;\r\n\t    \t$value = $value->value;\r\n\t    \t$this->debug(\"in serializeType: soapval overrides value to $value\");\r\n\t    \tif ($attrs) {\r\n\t    \t\tif (!is_array($value)) {\r\n\t    \t\t\t$value['!'] = $value;\r\n\t    \t\t}\r\n\t    \t\tforeach ($attrs as $n => $v) {\r\n\t    \t\t\t$value['!' . $n] = $v;\r\n\t    \t\t}\r\n\t\t    \t$this->debug(\"in serializeType: soapval provides attributes\");\r\n\t\t    }\r\n        } else {\r\n        \t$forceType = false;\r\n        }\r\n\r\n\t\t$xml = '';\r\n\t\tif (strpos($type, ':')) {\r\n\t\t\t$uqType = substr($type, strrpos($type, ':') + 1);\r\n\t\t\t$ns = substr($type, 0, strrpos($type, ':'));\r\n\t\t\t$this->debug(\"in serializeType: got a prefixed type: $uqType, $ns\");\r\n\t\t\tif ($this->getNamespaceFromPrefix($ns)) {\r\n\t\t\t\t$ns = $this->getNamespaceFromPrefix($ns);\r\n\t\t\t\t$this->debug(\"in serializeType: expanded prefixed type: $uqType, $ns\");\r\n\t\t\t}\r\n\r\n\t\t\tif($ns == $this->XMLSchemaVersion || $ns == 'http://schemas.xmlsoap.org/soap/encoding/'){\r\n\t\t\t\t$this->debug('in serializeType: type namespace indicates XML Schema or SOAP Encoding type');\r\n\t\t\t\tif ($unqualified && $use == 'literal') {\r\n\t\t\t\t\t$elementNS = \" xmlns=\\\"\\\"\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$elementNS = '';\r\n\t\t\t\t}\r\n\t\t\t\tif (is_null($value)) {\r\n\t\t\t\t\tif ($use == 'literal') {\r\n\t\t\t\t\t\t// TODO: depends on minOccurs\r\n\t\t\t\t\t\t$xml = \"<$name$elementNS/>\";\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// TODO: depends on nillable, which should be checked before calling this method\r\n\t\t\t\t\t\t$xml = \"<$name$elementNS xsi:nil=\\\"true\\\" xsi:type=\\\"\" . $this->getPrefixFromNamespace($ns) . \":$uqType\\\"/>\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$this->debug(\"in serializeType: returning: $xml\");\r\n\t\t\t\t\treturn $xml;\r\n\t\t\t\t}\r\n\t\t\t\tif ($uqType == 'Array') {\r\n\t\t\t\t\t// JBoss/Axis does this sometimes\r\n\t\t\t\t\treturn $this->serialize_val($value, $name, false, false, false, false, $use);\r\n\t\t\t\t}\r\n\t\t    \tif ($uqType == 'boolean') {\r\n\t\t    \t\tif ((is_string($value) && $value == 'false') || (! $value)) {\r\n\t\t\t\t\t\t$value = 'false';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$value = 'true';\r\n\t\t\t\t\t}\r\n\t\t\t\t} \r\n\t\t\t\tif ($uqType == 'string' && gettype($value) == 'string') {\r\n\t\t\t\t\t$value = $this->expandEntities($value);\r\n\t\t\t\t}\r\n\t\t\t\tif (($uqType == 'long' || $uqType == 'unsignedLong') && gettype($value) == 'double') {\r\n\t\t\t\t\t$value = sprintf(\"%.0lf\", $value);\r\n\t\t\t\t}\r\n\t\t\t\t// it's a scalar\r\n\t\t\t\t// TODO: what about null/nil values?\r\n\t\t\t\t// check type isn't a custom type extending xmlschema namespace\r\n\t\t\t\tif (!$this->getTypeDef($uqType, $ns)) {\r\n\t\t\t\t\tif ($use == 'literal') {\r\n\t\t\t\t\t\tif ($forceType) {\r\n\t\t\t\t\t\t\t$xml = \"<$name$elementNS xsi:type=\\\"\" . $this->getPrefixFromNamespace($ns) . \":$uqType\\\">$value</$name>\";\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t$xml = \"<$name$elementNS>$value</$name>\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$xml = \"<$name$elementNS xsi:type=\\\"\" . $this->getPrefixFromNamespace($ns) . \":$uqType\\\"$encodingStyle>$value</$name>\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$this->debug(\"in serializeType: returning: $xml\");\r\n\t\t\t\t\treturn $xml;\r\n\t\t\t\t}\r\n\t\t\t\t$this->debug('custom type extends XML Schema or SOAP Encoding namespace (yuck)');\r\n\t\t\t} else if ($ns == 'http://xml.apache.org/xml-soap') {\r\n\t\t\t\t$this->debug('in serializeType: appears to be Apache SOAP type');\r\n\t\t\t\tif ($uqType == 'Map') {\r\n\t\t\t\t\t$tt_prefix = $this->getPrefixFromNamespace('http://xml.apache.org/xml-soap');\r\n\t\t\t\t\tif (! $tt_prefix) {\r\n\t\t\t\t\t\t$this->debug('in serializeType: Add namespace for Apache SOAP type');\r\n\t\t\t\t\t\t$tt_prefix = 'ns' . rand(1000, 9999);\r\n\t\t\t\t\t\t$this->namespaces[$tt_prefix] = 'http://xml.apache.org/xml-soap';\r\n\t\t\t\t\t\t// force this to be added to usedNamespaces\r\n\t\t\t\t\t\t$tt_prefix = $this->getPrefixFromNamespace('http://xml.apache.org/xml-soap');\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$contents = '';\r\n\t\t\t\t\tforeach($value as $k => $v) {\r\n\t\t\t\t\t\t$this->debug(\"serializing map element: key $k, value $v\");\r\n\t\t\t\t\t\t$contents .= '<item>';\r\n\t\t\t\t\t\t$contents .= $this->serialize_val($k,'key',false,false,false,false,$use);\r\n\t\t\t\t\t\t$contents .= $this->serialize_val($v,'value',false,false,false,false,$use);\r\n\t\t\t\t\t\t$contents .= '</item>';\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ($use == 'literal') {\r\n\t\t\t\t\t\tif ($forceType) {\r\n\t\t\t\t\t\t\t$xml = \"<$name xsi:type=\\\"\" . $tt_prefix . \":$uqType\\\">$contents</$name>\";\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t$xml = \"<$name>$contents</$name>\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$xml = \"<$name xsi:type=\\\"\" . $tt_prefix . \":$uqType\\\"$encodingStyle>$contents</$name>\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$this->debug(\"in serializeType: returning: $xml\");\r\n\t\t\t\t\treturn $xml;\r\n\t\t\t\t}\r\n\t\t\t\t$this->debug('in serializeType: Apache SOAP type, but only support Map');\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// TODO: should the type be compared to types in XSD, and the namespace\r\n\t\t\t// set to XSD if the type matches?\r\n\t\t\t$this->debug(\"in serializeType: No namespace for type $type\");\r\n\t\t\t$ns = '';\r\n\t\t\t$uqType = $type;\r\n\t\t}\r\n\t\tif(!$typeDef = $this->getTypeDef($uqType, $ns)){\r\n\t\t\t$this->setError(\"$type ($uqType) is not a supported type.\");\r\n\t\t\t$this->debug(\"in serializeType: $type ($uqType) is not a supported type.\");\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\t$this->debug(\"in serializeType: found typeDef\");\r\n\t\t\t$this->appendDebug('typeDef=' . $this->varDump($typeDef));\r\n\t\t\tif (substr($uqType, -1) == '^') {\r\n\t\t\t\t$uqType = substr($uqType, 0, -1);\r\n\t\t\t}\r\n\t\t}\r\n\t\t$phpType = $typeDef['phpType'];\r\n\t\t$this->debug(\"in serializeType: uqType: $uqType, ns: $ns, phptype: $phpType, arrayType: \" . (isset($typeDef['arrayType']) ? $typeDef['arrayType'] : '') ); \r\n\t\t// if php type == struct, map value to the <all> element names\r\n\t\tif ($phpType == 'struct') {\r\n\t\t\tif (isset($typeDef['typeClass']) && $typeDef['typeClass'] == 'element') {\r\n\t\t\t\t$elementName = $uqType;\r\n\t\t\t\tif (isset($typeDef['form']) && ($typeDef['form'] == 'qualified')) {\r\n\t\t\t\t\t$elementNS = \" xmlns=\\\"$ns\\\"\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$elementNS = \" xmlns=\\\"\\\"\";\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t$elementName = $name;\r\n\t\t\t\tif ($unqualified) {\r\n\t\t\t\t\t$elementNS = \" xmlns=\\\"\\\"\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$elementNS = '';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (is_null($value)) {\r\n\t\t\t\tif ($use == 'literal') {\r\n\t\t\t\t\t// TODO: depends on minOccurs\r\n\t\t\t\t\t$xml = \"<$elementName$elementNS/>\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$xml = \"<$elementName$elementNS xsi:nil=\\\"true\\\" xsi:type=\\\"\" . $this->getPrefixFromNamespace($ns) . \":$uqType\\\"/>\";\r\n\t\t\t\t}\r\n\t\t\t\t$this->debug(\"in serializeType: returning: $xml\");\r\n\t\t\t\treturn $xml;\r\n\t\t\t}\r\n\t\t\tif (is_object($value)) {\r\n\t\t\t\t$value = get_object_vars($value);\r\n\t\t\t}\r\n\t\t\tif (is_array($value)) {\r\n\t\t\t\t$elementAttrs = $this->serializeComplexTypeAttributes($typeDef, $value, $ns, $uqType);\r\n\t\t\t\tif ($use == 'literal') {\r\n\t\t\t\t\tif ($forceType) {\r\n\t\t\t\t\t\t$xml = \"<$elementName$elementNS$elementAttrs xsi:type=\\\"\" . $this->getPrefixFromNamespace($ns) . \":$uqType\\\">\";\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$xml = \"<$elementName$elementNS$elementAttrs>\";\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$xml = \"<$elementName$elementNS$elementAttrs xsi:type=\\\"\" . $this->getPrefixFromNamespace($ns) . \":$uqType\\\"$encodingStyle>\";\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t$xml .= $this->serializeComplexTypeElements($typeDef, $value, $ns, $uqType, $use, $encodingStyle);\r\n\t\t\t\t$xml .= \"</$elementName>\";\r\n\t\t\t} else {\r\n\t\t\t\t$this->debug(\"in serializeType: phpType is struct, but value is not an array\");\r\n\t\t\t\t$this->setError(\"phpType is struct, but value is not an array: see debug output for details\");\r\n\t\t\t\t$xml = '';\r\n\t\t\t}\r\n\t\t} elseif ($phpType == 'array') {\r\n\t\t\tif (isset($typeDef['form']) && ($typeDef['form'] == 'qualified')) {\r\n\t\t\t\t$elementNS = \" xmlns=\\\"$ns\\\"\";\r\n\t\t\t} else {\r\n\t\t\t\tif ($unqualified) {\r\n\t\t\t\t\t$elementNS = \" xmlns=\\\"\\\"\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$elementNS = '';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (is_null($value)) {\r\n\t\t\t\tif ($use == 'literal') {\r\n\t\t\t\t\t// TODO: depends on minOccurs\r\n\t\t\t\t\t$xml = \"<$name$elementNS/>\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$xml = \"<$name$elementNS xsi:nil=\\\"true\\\" xsi:type=\\\"\" .\r\n\t\t\t\t\t\t$this->getPrefixFromNamespace('http://schemas.xmlsoap.org/soap/encoding/') .\r\n\t\t\t\t\t\t\":Array\\\" \" .\r\n\t\t\t\t\t\t$this->getPrefixFromNamespace('http://schemas.xmlsoap.org/soap/encoding/') .\r\n\t\t\t\t\t\t':arrayType=\"' .\r\n\t\t\t\t\t\t$this->getPrefixFromNamespace($this->getPrefix($typeDef['arrayType'])) .\r\n\t\t\t\t\t\t':' .\r\n\t\t\t\t\t\t$this->getLocalPart($typeDef['arrayType']).\"[0]\\\"/>\";\r\n\t\t\t\t}\r\n\t\t\t\t$this->debug(\"in serializeType: returning: $xml\");\r\n\t\t\t\treturn $xml;\r\n\t\t\t}\r\n\t\t\tif (isset($typeDef['multidimensional'])) {\r\n\t\t\t\t$nv = array();\r\n\t\t\t\tforeach($value as $v) {\r\n\t\t\t\t\t$cols = ',' . sizeof($v);\r\n\t\t\t\t\t$nv = array_merge($nv, $v);\r\n\t\t\t\t} \r\n\t\t\t\t$value = $nv;\r\n\t\t\t} else {\r\n\t\t\t\t$cols = '';\r\n\t\t\t} \r\n\t\t\tif (is_array($value) && sizeof($value) >= 1) {\r\n\t\t\t\t$rows = sizeof($value);\r\n\t\t\t\t$contents = '';\r\n\t\t\t\tforeach($value as $k => $v) {\r\n\t\t\t\t\t$this->debug(\"serializing array element: $k, $v of type: $typeDef[arrayType]\");\r\n\t\t\t\t\t//if (strpos($typeDef['arrayType'], ':') ) {\r\n\t\t\t\t\tif (!in_array($typeDef['arrayType'],$this->typemap['http://www.w3.org/2001/XMLSchema'])) {\r\n\t\t\t\t\t    $contents .= $this->serializeType('item', $typeDef['arrayType'], $v, $use);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t    $contents .= $this->serialize_val($v, 'item', $typeDef['arrayType'], null, $this->XMLSchemaVersion, false, $use);\r\n\t\t\t\t\t} \r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t$rows = 0;\r\n\t\t\t\t$contents = null;\r\n\t\t\t}\r\n\t\t\t// TODO: for now, an empty value will be serialized as a zero element\r\n\t\t\t// array.  Revisit this when coding the handling of null/nil values.\r\n\t\t\tif ($use == 'literal') {\r\n\t\t\t\t$xml = \"<$name$elementNS>\"\r\n\t\t\t\t\t.$contents\r\n\t\t\t\t\t.\"</$name>\";\r\n\t\t\t} else {\r\n\t\t\t\t$xml = \"<$name$elementNS xsi:type=\\\"\".$this->getPrefixFromNamespace('http://schemas.xmlsoap.org/soap/encoding/').':Array\" '.\r\n\t\t\t\t\t$this->getPrefixFromNamespace('http://schemas.xmlsoap.org/soap/encoding/')\r\n\t\t\t\t\t.':arrayType=\"'\r\n\t\t\t\t\t.$this->getPrefixFromNamespace($this->getPrefix($typeDef['arrayType']))\r\n\t\t\t\t\t.\":\".$this->getLocalPart($typeDef['arrayType']).\"[$rows$cols]\\\">\"\r\n\t\t\t\t\t.$contents\r\n\t\t\t\t\t.\"</$name>\";\r\n\t\t\t}\r\n\t\t} elseif ($phpType == 'scalar') {\r\n\t\t\tif (isset($typeDef['form']) && ($typeDef['form'] == 'qualified')) {\r\n\t\t\t\t$elementNS = \" xmlns=\\\"$ns\\\"\";\r\n\t\t\t} else {\r\n\t\t\t\tif ($unqualified) {\r\n\t\t\t\t\t$elementNS = \" xmlns=\\\"\\\"\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$elementNS = '';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif ($use == 'literal') {\r\n\t\t\t\tif ($forceType) {\r\n\t\t\t\t\t$xml = \"<$name$elementNS xsi:type=\\\"\" . $this->getPrefixFromNamespace($ns) . \":$uqType\\\">$value</$name>\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$xml = \"<$name$elementNS>$value</$name>\";\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t$xml = \"<$name$elementNS xsi:type=\\\"\" . $this->getPrefixFromNamespace($ns) . \":$uqType\\\"$encodingStyle>$value</$name>\";\r\n\t\t\t}\r\n\t\t}\r\n\t\t$this->debug(\"in serializeType: returning: $xml\");\r\n\t\treturn $xml;\r\n\t}\r\n\t\r\n\t/**\r\n\t * serializes the attributes for a complexType\r\n\t *\r\n\t * @param array $typeDef our internal representation of an XML schema type (or element)\r\n\t * @param mixed $value a native PHP value (parameter value)\r\n\t * @param string $ns the namespace of the type\r\n\t * @param string $uqType the local part of the type\r\n\t * @return string value serialized as an XML string\r\n\t * @access private\r\n\t */\r\n\tfunction serializeComplexTypeAttributes($typeDef, $value, $ns, $uqType) {\r\n\t\t$xml = '';\r\n\t\tif (isset($typeDef['attrs']) && is_array($typeDef['attrs'])) {\r\n\t\t\t$this->debug(\"serialize attributes for XML Schema type $ns:$uqType\");\r\n\t\t\tif (is_array($value)) {\r\n\t\t\t\t$xvalue = $value;\r\n\t\t\t} elseif (is_object($value)) {\r\n\t\t\t\t$xvalue = get_object_vars($value);\r\n\t\t\t} else {\r\n\t\t\t\t$this->debug(\"value is neither an array nor an object for XML Schema type $ns:$uqType\");\r\n\t\t\t\t$xvalue = array();\r\n\t\t\t}\r\n\t\t\tforeach ($typeDef['attrs'] as $aName => $attrs) {\r\n\t\t\t\tif (isset($xvalue['!' . $aName])) {\r\n\t\t\t\t\t$xname = '!' . $aName;\r\n\t\t\t\t\t$this->debug(\"value provided for attribute $aName with key $xname\");\r\n\t\t\t\t} elseif (isset($xvalue[$aName])) {\r\n\t\t\t\t\t$xname = $aName;\r\n\t\t\t\t\t$this->debug(\"value provided for attribute $aName with key $xname\");\r\n\t\t\t\t} elseif (isset($attrs['default'])) {\r\n\t\t\t\t\t$xname = '!' . $aName;\r\n\t\t\t\t\t$xvalue[$xname] = $attrs['default'];\r\n\t\t\t\t\t$this->debug('use default value of ' . $xvalue[$aName] . ' for attribute ' . $aName);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$xname = '';\r\n\t\t\t\t\t$this->debug(\"no value provided for attribute $aName\");\r\n\t\t\t\t}\r\n\t\t\t\tif ($xname) {\r\n\t\t\t\t\t$xml .=  \" $aName=\\\"\" . $this->expandEntities($xvalue[$xname]) . \"\\\"\";\r\n\t\t\t\t}\r\n\t\t\t} \r\n\t\t} else {\r\n\t\t\t$this->debug(\"no attributes to serialize for XML Schema type $ns:$uqType\");\r\n\t\t}\r\n\t\tif (isset($typeDef['extensionBase'])) {\r\n\t\t\t$ns = $this->getPrefix($typeDef['extensionBase']);\r\n\t\t\t$uqType = $this->getLocalPart($typeDef['extensionBase']);\r\n\t\t\tif ($this->getNamespaceFromPrefix($ns)) {\r\n\t\t\t\t$ns = $this->getNamespaceFromPrefix($ns);\r\n\t\t\t}\r\n\t\t\tif ($typeDef = $this->getTypeDef($uqType, $ns)) {\r\n\t\t\t\t$this->debug(\"serialize attributes for extension base $ns:$uqType\");\r\n\t\t\t\t$xml .= $this->serializeComplexTypeAttributes($typeDef, $value, $ns, $uqType);\r\n\t\t\t} else {\r\n\t\t\t\t$this->debug(\"extension base $ns:$uqType is not a supported type\");\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn $xml;\r\n\t}\r\n\r\n\t/**\r\n\t * serializes the elements for a complexType\r\n\t *\r\n\t * @param array $typeDef our internal representation of an XML schema type (or element)\r\n\t * @param mixed $value a native PHP value (parameter value)\r\n\t * @param string $ns the namespace of the type\r\n\t * @param string $uqType the local part of the type\r\n\t * @param string $use use for part (encoded|literal)\r\n\t * @param string $encodingStyle SOAP encoding style for the value (if different than the enclosing style)\r\n\t * @return string value serialized as an XML string\r\n\t * @access private\r\n\t */\r\n\tfunction serializeComplexTypeElements($typeDef, $value, $ns, $uqType, $use='encoded', $encodingStyle=false) {\r\n\t\t$xml = '';\r\n\t\tif (isset($typeDef['elements']) && is_array($typeDef['elements'])) {\r\n\t\t\t$this->debug(\"in serializeComplexTypeElements, serialize elements for XML Schema type $ns:$uqType\");\r\n\t\t\tif (is_array($value)) {\r\n\t\t\t\t$xvalue = $value;\r\n\t\t\t} elseif (is_object($value)) {\r\n\t\t\t\t$xvalue = get_object_vars($value);\r\n\t\t\t} else {\r\n\t\t\t\t$this->debug(\"value is neither an array nor an object for XML Schema type $ns:$uqType\");\r\n\t\t\t\t$xvalue = array();\r\n\t\t\t}\r\n\t\t\t// toggle whether all elements are present - ideally should validate against schema\r\n\t\t\tif (count($typeDef['elements']) != count($xvalue)){\r\n\t\t\t\t$optionals = true;\r\n\t\t\t}\r\n\t\t\tforeach ($typeDef['elements'] as $eName => $attrs) {\r\n\t\t\t\tif (!isset($xvalue[$eName])) {\r\n\t\t\t\t\tif (isset($attrs['default'])) {\r\n\t\t\t\t\t\t$xvalue[$eName] = $attrs['default'];\r\n\t\t\t\t\t\t$this->debug('use default value of ' . $xvalue[$eName] . ' for element ' . $eName);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// if user took advantage of a minOccurs=0, then only serialize named parameters\r\n\t\t\t\tif (isset($optionals)\r\n\t\t\t\t    && (!isset($xvalue[$eName])) \r\n\t\t\t\t\t&& ( (!isset($attrs['nillable'])) || $attrs['nillable'] != 'true')\r\n\t\t\t\t\t){\r\n\t\t\t\t\tif (isset($attrs['minOccurs']) && $attrs['minOccurs'] <> '0') {\r\n\t\t\t\t\t\t$this->debug(\"apparent error: no value provided for element $eName with minOccurs=\" . $attrs['minOccurs']);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// do nothing\r\n\t\t\t\t\t$this->debug(\"no value provided for complexType element $eName and element is not nillable, so serialize nothing\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// get value\r\n\t\t\t\t\tif (isset($xvalue[$eName])) {\r\n\t\t\t\t\t    $v = $xvalue[$eName];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t    $v = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (isset($attrs['form'])) {\r\n\t\t\t\t\t\t$unqualified = ($attrs['form'] == 'unqualified');\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$unqualified = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (isset($attrs['maxOccurs']) && ($attrs['maxOccurs'] == 'unbounded' || $attrs['maxOccurs'] > 1) && isset($v) && is_array($v) && $this->isArraySimpleOrStruct($v) == 'arraySimple') {\r\n\t\t\t\t\t\t$vv = $v;\r\n\t\t\t\t\t\tforeach ($vv as $k => $v) {\r\n\t\t\t\t\t\t\tif (isset($attrs['type']) || isset($attrs['ref'])) {\r\n\t\t\t\t\t\t\t\t// serialize schema-defined type\r\n\t\t\t\t\t\t\t    $xml .= $this->serializeType($eName, isset($attrs['type']) ? $attrs['type'] : $attrs['ref'], $v, $use, $encodingStyle, $unqualified);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// serialize generic type (can this ever really happen?)\r\n\t\t\t\t\t\t\t    $this->debug(\"calling serialize_val() for $v, $eName, false, false, false, false, $use\");\r\n\t\t\t\t\t\t\t    $xml .= $this->serialize_val($v, $eName, false, false, false, false, $use);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (isset($attrs['type']) || isset($attrs['ref'])) {\r\n\t\t\t\t\t\t\t// serialize schema-defined type\r\n\t\t\t\t\t\t    $xml .= $this->serializeType($eName, isset($attrs['type']) ? $attrs['type'] : $attrs['ref'], $v, $use, $encodingStyle, $unqualified);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// serialize generic type (can this ever really happen?)\r\n\t\t\t\t\t\t    $this->debug(\"calling serialize_val() for $v, $eName, false, false, false, false, $use\");\r\n\t\t\t\t\t\t    $xml .= $this->serialize_val($v, $eName, false, false, false, false, $use);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} \r\n\t\t} else {\r\n\t\t\t$this->debug(\"no elements to serialize for XML Schema type $ns:$uqType\");\r\n\t\t}\r\n\t\tif (isset($typeDef['extensionBase'])) {\r\n\t\t\t$ns = $this->getPrefix($typeDef['extensionBase']);\r\n\t\t\t$uqType = $this->getLocalPart($typeDef['extensionBase']);\r\n\t\t\tif ($this->getNamespaceFromPrefix($ns)) {\r\n\t\t\t\t$ns = $this->getNamespaceFromPrefix($ns);\r\n\t\t\t}\r\n\t\t\tif ($typeDef = $this->getTypeDef($uqType, $ns)) {\r\n\t\t\t\t$this->debug(\"serialize elements for extension base $ns:$uqType\");\r\n\t\t\t\t$xml .= $this->serializeComplexTypeElements($typeDef, $value, $ns, $uqType, $use, $encodingStyle);\r\n\t\t\t} else {\r\n\t\t\t\t$this->debug(\"extension base $ns:$uqType is not a supported type\");\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn $xml;\r\n\t}\r\n\r\n\t/**\r\n\t* adds an XML Schema complex type to the WSDL types\r\n\t*\r\n\t* @param string\t$name\r\n\t* @param string $typeClass (complexType|simpleType|attribute)\r\n\t* @param string $phpType currently supported are array and struct (php assoc array)\r\n\t* @param string $compositor (all|sequence|choice)\r\n\t* @param string $restrictionBase namespace:name (http://schemas.xmlsoap.org/soap/encoding/:Array)\r\n\t* @param array $elements e.g. array ( name => array(name=>'',type=>'') )\r\n\t* @param array $attrs e.g. array(array('ref'=>'SOAP-ENC:arrayType','wsdl:arrayType'=>'xsd:string[]'))\r\n\t* @param string $arrayType as namespace:name (xsd:string)\r\n\t* @see nusoap_xmlschema\r\n\t* @access public\r\n\t*/\r\n\tfunction addComplexType($name,$typeClass='complexType',$phpType='array',$compositor='',$restrictionBase='',$elements=array(),$attrs=array(),$arrayType='') {\r\n\t\tif (count($elements) > 0) {\r\n\t\t\t$eElements = array();\r\n\t    \tforeach($elements as $n => $e){\r\n\t            // expand each element\r\n\t            $ee = array();\r\n\t            foreach ($e as $k => $v) {\r\n\t\t            $k = strpos($k,':') ? $this->expandQname($k) : $k;\r\n\t\t            $v = strpos($v,':') ? $this->expandQname($v) : $v;\r\n\t\t            $ee[$k] = $v;\r\n\t\t    \t}\r\n\t    \t\t$eElements[$n] = $ee;\r\n\t    \t}\r\n\t    \t$elements = $eElements;\r\n\t\t}\r\n\t\t\r\n\t\tif (count($attrs) > 0) {\r\n\t    \tforeach($attrs as $n => $a){\r\n\t            // expand each attribute\r\n\t            foreach ($a as $k => $v) {\r\n\t\t            $k = strpos($k,':') ? $this->expandQname($k) : $k;\r\n\t\t            $v = strpos($v,':') ? $this->expandQname($v) : $v;\r\n\t\t            $aa[$k] = $v;\r\n\t\t    \t}\r\n\t    \t\t$eAttrs[$n] = $aa;\r\n\t    \t}\r\n\t    \t$attrs = $eAttrs;\r\n\t\t}\r\n\r\n\t\t$restrictionBase = strpos($restrictionBase,':') ? $this->expandQname($restrictionBase) : $restrictionBase;\r\n\t\t$arrayType = strpos($arrayType,':') ? $this->expandQname($arrayType) : $arrayType;\r\n\r\n\t\t$typens = isset($this->namespaces['types']) ? $this->namespaces['types'] : $this->namespaces['tns'];\r\n\t\t$this->schemas[$typens][0]->addComplexType($name,$typeClass,$phpType,$compositor,$restrictionBase,$elements,$attrs,$arrayType);\r\n\t}\r\n\r\n\t/**\r\n\t* adds an XML Schema simple type to the WSDL types\r\n\t*\r\n\t* @param string $name\r\n\t* @param string $restrictionBase namespace:name (http://schemas.xmlsoap.org/soap/encoding/:Array)\r\n\t* @param string $typeClass (should always be simpleType)\r\n\t* @param string $phpType (should always be scalar)\r\n\t* @param array $enumeration array of values\r\n\t* @see nusoap_xmlschema\r\n\t* @access public\r\n\t*/\r\n\tfunction addSimpleType($name, $restrictionBase='', $typeClass='simpleType', $phpType='scalar', $enumeration=array()) {\r\n\t\t$restrictionBase = strpos($restrictionBase,':') ? $this->expandQname($restrictionBase) : $restrictionBase;\r\n\r\n\t\t$typens = isset($this->namespaces['types']) ? $this->namespaces['types'] : $this->namespaces['tns'];\r\n\t\t$this->schemas[$typens][0]->addSimpleType($name, $restrictionBase, $typeClass, $phpType, $enumeration);\r\n\t}\r\n\r\n\t/**\r\n\t* adds an element to the WSDL types\r\n\t*\r\n\t* @param array $attrs attributes that must include name and type\r\n\t* @see nusoap_xmlschema\r\n\t* @access public\r\n\t*/\r\n\tfunction addElement($attrs) {\r\n\t\t$typens = isset($this->namespaces['types']) ? $this->namespaces['types'] : $this->namespaces['tns'];\r\n\t\t$this->schemas[$typens][0]->addElement($attrs);\r\n\t}\r\n\r\n\t/**\r\n\t* register an operation with the server\r\n\t* \r\n\t* @param string $name operation (method) name\r\n\t* @param array $in assoc array of input values: key = param name, value = param type\r\n\t* @param array $out assoc array of output values: key = param name, value = param type\r\n\t* @param string $namespace optional The namespace for the operation\r\n\t* @param string $soapaction optional The soapaction for the operation\r\n\t* @param string $style (rpc|document) optional The style for the operation Note: when 'document' is specified, parameter and return wrappers are created for you automatically\r\n\t* @param string $use (encoded|literal) optional The use for the parameters (cannot mix right now)\r\n\t* @param string $documentation optional The description to include in the WSDL\r\n\t* @param string $encodingStyle optional (usually 'http://schemas.xmlsoap.org/soap/encoding/' for encoded)\r\n\t* @access public \r\n\t*/\r\n\tfunction addOperation($name, $in = false, $out = false, $namespace = false, $soapaction = false, $style = 'rpc', $use = 'encoded', $documentation = '', $encodingStyle = ''){\r\n\t\tif ($use == 'encoded' && $encodingStyle == '') {\r\n\t\t\t$encodingStyle = 'http://schemas.xmlsoap.org/soap/encoding/';\r\n\t\t}\r\n\r\n\t\tif ($style == 'document') {\r\n\t\t\t$elements = array();\r\n\t\t\tforeach ($in as $n => $t) {\r\n\t\t\t\t$elements[$n] = array('name' => $n, 'type' => $t);\r\n\t\t\t}\r\n\t\t\t$this->addComplexType($name . 'RequestType', 'complexType', 'struct', 'all', '', $elements);\r\n\t\t\t$this->addElement(array('name' => $name, 'type' => $name . 'RequestType'));\r\n\t\t\t$in = array('parameters' => 'tns:' . $name . '^');\r\n\r\n\t\t\t$elements = array();\r\n\t\t\tforeach ($out as $n => $t) {\r\n\t\t\t\t$elements[$n] = array('name' => $n, 'type' => $t);\r\n\t\t\t}\r\n\t\t\t$this->addComplexType($name . 'ResponseType', 'complexType', 'struct', 'all', '', $elements);\r\n\t\t\t$this->addElement(array('name' => $name . 'Response', 'type' => $name . 'ResponseType', 'form' => 'qualified'));\r\n\t\t\t$out = array('parameters' => 'tns:' . $name . 'Response' . '^');\r\n\t\t}\r\n\r\n\t\t// get binding\r\n\t\t$this->bindings[ $this->serviceName . 'Binding' ]['operations'][$name] =\r\n\t\tarray(\r\n\t\t'name' => $name,\r\n\t\t'binding' => $this->serviceName . 'Binding',\r\n\t\t'endpoint' => $this->endpoint,\r\n\t\t'soapAction' => $soapaction,\r\n\t\t'style' => $style,\r\n\t\t'input' => array(\r\n\t\t\t'use' => $use,\r\n\t\t\t'namespace' => $namespace,\r\n\t\t\t'encodingStyle' => $encodingStyle,\r\n\t\t\t'message' => $name . 'Request',\r\n\t\t\t'parts' => $in),\r\n\t\t'output' => array(\r\n\t\t\t'use' => $use,\r\n\t\t\t'namespace' => $namespace,\r\n\t\t\t'encodingStyle' => $encodingStyle,\r\n\t\t\t'message' => $name . 'Response',\r\n\t\t\t'parts' => $out),\r\n\t\t'namespace' => $namespace,\r\n\t\t'transport' => 'http://schemas.xmlsoap.org/soap/http',\r\n\t\t'documentation' => $documentation); \r\n\t\t// add portTypes\r\n\t\t// add messages\r\n\t\tif($in)\r\n\t\t{\r\n\t\t\tforeach($in as $pName => $pType)\r\n\t\t\t{\r\n\t\t\t\tif(strpos($pType,':')) {\r\n\t\t\t\t\t$pType = $this->getNamespaceFromPrefix($this->getPrefix($pType)).\":\".$this->getLocalPart($pType);\r\n\t\t\t\t}\r\n\t\t\t\t$this->messages[$name.'Request'][$pName] = $pType;\r\n\t\t\t}\r\n\t\t} else {\r\n            $this->messages[$name.'Request']= '0';\r\n        }\r\n\t\tif($out)\r\n\t\t{\r\n\t\t\tforeach($out as $pName => $pType)\r\n\t\t\t{\r\n\t\t\t\tif(strpos($pType,':')) {\r\n\t\t\t\t\t$pType = $this->getNamespaceFromPrefix($this->getPrefix($pType)).\":\".$this->getLocalPart($pType);\r\n\t\t\t\t}\r\n\t\t\t\t$this->messages[$name.'Response'][$pName] = $pType;\r\n\t\t\t}\r\n\t\t} else {\r\n            $this->messages[$name.'Response']= '0';\r\n        }\r\n\t\treturn true;\r\n\t} \r\n}\r\n?><?php\r\n\r\n\r\n\r\n/**\r\n*\r\n* nusoap_parser class parses SOAP XML messages into native PHP values\r\n*\r\n* @author   Dietrich Ayala <dietrich@ganx4.com>\r\n* @author   Scott Nichol <snichol@users.sourceforge.net>\r\n* @version  $Id: nusoap.php,v 1.114 2007/11/06 15:17:46 snichol Exp $\r\n* @access   public\r\n*/\r\nclass nusoap_parser extends nusoap_base {\r\n\r\n\tvar $xml = '';\r\n\tvar $xml_encoding = '';\r\n\tvar $method = '';\r\n\tvar $root_struct = '';\r\n\tvar $root_struct_name = '';\r\n\tvar $root_struct_namespace = '';\r\n\tvar $root_header = '';\r\n    var $document = '';\t\t\t// incoming SOAP body (text)\r\n\t// determines where in the message we are (envelope,header,body,method)\r\n\tvar $status = '';\r\n\tvar $position = 0;\r\n\tvar $depth = 0;\r\n\tvar $default_namespace = '';\r\n\tvar $namespaces = array();\r\n\tvar $message = array();\r\n    var $parent = '';\r\n\tvar $fault = false;\r\n\tvar $fault_code = '';\r\n\tvar $fault_str = '';\r\n\tvar $fault_detail = '';\r\n\tvar $depth_array = array();\r\n\tvar $debug_flag = true;\r\n\tvar $soapresponse = NULL;\t// parsed SOAP Body\r\n\tvar $soapheader = NULL;\t\t// parsed SOAP Header\r\n\tvar $responseHeaders = '';\t// incoming SOAP headers (text)\r\n\tvar $body_position = 0;\r\n\t// for multiref parsing:\r\n\t// array of id => pos\r\n\tvar $ids = array();\r\n\t// array of id => hrefs => pos\r\n\tvar $multirefs = array();\r\n\t// toggle for auto-decoding element content\r\n\tvar $decode_utf8 = true;\r\n\r\n\t/**\r\n\t* constructor that actually does the parsing\r\n\t*\r\n\t* @param    string $xml SOAP message\r\n\t* @param    string $encoding character encoding scheme of message\r\n\t* @param    string $method method for which XML is parsed (unused?)\r\n\t* @param    string $decode_utf8 whether to decode UTF-8 to ISO-8859-1\r\n\t* @access   public\r\n\t*/\r\n\tfunction nusoap_parser($xml,$encoding='UTF-8',$method='',$decode_utf8=true){\r\n\t\tparent::nusoap_base();\r\n\t\t$this->xml = $xml;\r\n\t\t$this->xml_encoding = $encoding;\r\n\t\t$this->method = $method;\r\n\t\t$this->decode_utf8 = $decode_utf8;\r\n\r\n\t\t// Check whether content has been read.\r\n\t\tif(!empty($xml)){\r\n\t\t\t// Check XML encoding\r\n\t\t\t$pos_xml = strpos($xml, '<?xml');\r\n\t\t\tif ($pos_xml !== FALSE) {\r\n\t\t\t\t$xml_decl = substr($xml, $pos_xml, strpos($xml, '?>', $pos_xml + 2) - $pos_xml + 1);\r\n\t\t\t\tif (preg_match(\"/encoding=[\\\"']([^\\\"']*)[\\\"']/\", $xml_decl, $res)) {\r\n\t\t\t\t\t$xml_encoding = $res[1];\r\n\t\t\t\t\tif (strtoupper($xml_encoding) != $encoding) {\r\n\t\t\t\t\t\t$err = \"Charset from HTTP Content-Type '\" . $encoding . \"' does not match encoding from XML declaration '\" . $xml_encoding . \"'\";\r\n\t\t\t\t\t\t$this->debug($err);\r\n\t\t\t\t\t\tif ($encoding != 'ISO-8859-1' || strtoupper($xml_encoding) != 'UTF-8') {\r\n\t\t\t\t\t\t\t$this->setError($err);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// when HTTP says ISO-8859-1 (the default) and XML says UTF-8 (the typical), assume the other endpoint is just sloppy and proceed\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$this->debug('Charset from HTTP Content-Type matches encoding from XML declaration');\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$this->debug('No encoding specified in XML declaration');\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t$this->debug('No XML declaration');\r\n\t\t\t}\r\n\t\t\t$this->debug('Entering nusoap_parser(), length='.strlen($xml).', encoding='.$encoding);\r\n\t\t\t// Create an XML parser - why not xml_parser_create_ns?\r\n\t\t\t$this->parser = xml_parser_create($this->xml_encoding);\r\n\t\t\t// Set the options for parsing the XML data.\r\n\t\t\t//xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 1);\r\n\t\t\txml_parser_set_option($this->parser, XML_OPTION_CASE_FOLDING, 0);\r\n\t\t\txml_parser_set_option($this->parser, XML_OPTION_TARGET_ENCODING, $this->xml_encoding);\r\n\t\t\t// Set the object for the parser.\r\n\t\t\txml_set_object($this->parser, $this);\r\n\t\t\t// Set the element handlers for the parser.\r\n\t\t\txml_set_element_handler($this->parser, 'start_element','end_element');\r\n\t\t\txml_set_character_data_handler($this->parser,'character_data');\r\n\r\n\t\t\t// Parse the XML file.\r\n\t\t\tif(!xml_parse($this->parser,$xml,true)){\r\n\t\t\t    // Display an error message.\r\n\t\t\t    $err = sprintf('XML error parsing SOAP payload on line %d: %s',\r\n\t\t\t    xml_get_current_line_number($this->parser),\r\n\t\t\t    xml_error_string(xml_get_error_code($this->parser)));\r\n\t\t\t\t$this->debug($err);\r\n\t\t\t\t$this->debug(\"XML payload:\\n\" . $xml);\r\n\t\t\t\t$this->setError($err);\r\n\t\t\t} else {\r\n\t\t\t\t$this->debug('parsed successfully, found root struct: '.$this->root_struct.' of name '.$this->root_struct_name);\r\n\t\t\t\t// get final value\r\n\t\t\t\t$this->soapresponse = $this->message[$this->root_struct]['result'];\r\n\t\t\t\t// get header value\r\n\t\t\t\tif($this->root_header != '' && isset($this->message[$this->root_header]['result'])){\r\n\t\t\t\t\t$this->soapheader = $this->message[$this->root_header]['result'];\r\n\t\t\t\t}\r\n\t\t\t\t// resolve hrefs/ids\r\n\t\t\t\tif(sizeof($this->multirefs) > 0){\r\n\t\t\t\t\tforeach($this->multirefs as $id => $hrefs){\r\n\t\t\t\t\t\t$this->debug('resolving multirefs for id: '.$id);\r\n\t\t\t\t\t\t$idVal = $this->buildVal($this->ids[$id]);\r\n\t\t\t\t\t\tif (is_array($idVal) && isset($idVal['!id'])) {\r\n\t\t\t\t\t\t\tunset($idVal['!id']);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tforeach($hrefs as $refPos => $ref){\r\n\t\t\t\t\t\t\t$this->debug('resolving href at pos '.$refPos);\r\n\t\t\t\t\t\t\t$this->multirefs[$id][$refPos] = $idVal;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\txml_parser_free($this->parser);\r\n\t\t} else {\r\n\t\t\t$this->debug('xml was empty, didn\\'t parse!');\r\n\t\t\t$this->setError('xml was empty, didn\\'t parse!');\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* start-element handler\r\n\t*\r\n\t* @param    resource $parser XML parser object\r\n\t* @param    string $name element name\r\n\t* @param    array $attrs associative array of attributes\r\n\t* @access   private\r\n\t*/\r\n\tfunction start_element($parser, $name, $attrs) {\r\n\t\t// position in a total number of elements, starting from 0\r\n\t\t// update class level pos\r\n\t\t$pos = $this->position++;\r\n\t\t// and set mine\r\n\t\t$this->message[$pos] = array('pos' => $pos,'children'=>'','cdata'=>'');\r\n\t\t// depth = how many levels removed from root?\r\n\t\t// set mine as current global depth and increment global depth value\r\n\t\t$this->message[$pos]['depth'] = $this->depth++;\r\n\r\n\t\t// else add self as child to whoever the current parent is\r\n\t\tif($pos != 0){\r\n\t\t\t$this->message[$this->parent]['children'] .= '|'.$pos;\r\n\t\t}\r\n\t\t// set my parent\r\n\t\t$this->message[$pos]['parent'] = $this->parent;\r\n\t\t// set self as current parent\r\n\t\t$this->parent = $pos;\r\n\t\t// set self as current value for this depth\r\n\t\t$this->depth_array[$this->depth] = $pos;\r\n\t\t// get element prefix\r\n\t\tif(strpos($name,':')){\r\n\t\t\t// get ns prefix\r\n\t\t\t$prefix = substr($name,0,strpos($name,':'));\r\n\t\t\t// get unqualified name\r\n\t\t\t$name = substr(strstr($name,':'),1);\r\n\t\t}\r\n\t\t// set status\r\n\t\tif($name == 'Envelope'){\r\n\t\t\t$this->status = 'envelope';\r\n\t\t} elseif($name == 'Header' && $this->status = 'envelope'){\r\n\t\t\t$this->root_header = $pos;\r\n\t\t\t$this->status = 'header';\r\n\t\t} elseif($name == 'Body' && $this->status = 'envelope'){\r\n\t\t\t$this->status = 'body';\r\n\t\t\t$this->body_position = $pos;\r\n\t\t// set method\r\n\t\t} elseif($this->status == 'body' && $pos == ($this->body_position+1)){\r\n\t\t\t$this->status = 'method';\r\n\t\t\t$this->root_struct_name = $name;\r\n\t\t\t$this->root_struct = $pos;\r\n\t\t\t$this->message[$pos]['type'] = 'struct';\r\n\t\t\t$this->debug(\"found root struct $this->root_struct_name, pos $this->root_struct\");\r\n\t\t}\r\n\t\t// set my status\r\n\t\t$this->message[$pos]['status'] = $this->status;\r\n\t\t// set name\r\n\t\t$this->message[$pos]['name'] = htmlspecialchars($name);\r\n\t\t// set attrs\r\n\t\t$this->message[$pos]['attrs'] = $attrs;\r\n\r\n\t\t// loop through atts, logging ns and type declarations\r\n        $attstr = '';\r\n\t\tforeach($attrs as $key => $value){\r\n        \t$key_prefix = $this->getPrefix($key);\r\n\t\t\t$key_localpart = $this->getLocalPart($key);\r\n\t\t\t// if ns declarations, add to class level array of valid namespaces\r\n            if($key_prefix == 'xmlns'){\r\n\t\t\t\tif(ereg('^http://www.w3.org/[0-9]{4}/XMLSchema$',$value)){\r\n\t\t\t\t\t$this->XMLSchemaVersion = $value;\r\n\t\t\t\t\t$this->namespaces['xsd'] = $this->XMLSchemaVersion;\r\n\t\t\t\t\t$this->namespaces['xsi'] = $this->XMLSchemaVersion.'-instance';\r\n\t\t\t\t}\r\n                $this->namespaces[$key_localpart] = $value;\r\n\t\t\t\t// set method namespace\r\n\t\t\t\tif($name == $this->root_struct_name){\r\n\t\t\t\t\t$this->methodNamespace = $value;\r\n\t\t\t\t}\r\n\t\t\t// if it's a type declaration, set type\r\n        } elseif($key_localpart == 'type'){\r\n        \t\tif (isset($this->message[$pos]['type']) && $this->message[$pos]['type'] == 'array') {\r\n        \t\t\t// do nothing: already processed arrayType\r\n        \t\t} else {\r\n\t            \t$value_prefix = $this->getPrefix($value);\r\n\t                $value_localpart = $this->getLocalPart($value);\r\n\t\t\t\t\t$this->message[$pos]['type'] = $value_localpart;\r\n\t\t\t\t\t$this->message[$pos]['typePrefix'] = $value_prefix;\r\n\t                if(isset($this->namespaces[$value_prefix])){\r\n\t                \t$this->message[$pos]['type_namespace'] = $this->namespaces[$value_prefix];\r\n\t                } else if(isset($attrs['xmlns:'.$value_prefix])) {\r\n\t\t\t\t\t\t$this->message[$pos]['type_namespace'] = $attrs['xmlns:'.$value_prefix];\r\n\t                }\r\n\t\t\t\t\t// should do something here with the namespace of specified type?\r\n\t\t\t\t}\r\n\t\t\t} elseif($key_localpart == 'arrayType'){\r\n\t\t\t\t$this->message[$pos]['type'] = 'array';\r\n\t\t\t\t/* do arrayType ereg here\r\n\t\t\t\t[1]    arrayTypeValue    ::=    atype asize\r\n\t\t\t\t[2]    atype    ::=    QName rank*\r\n\t\t\t\t[3]    rank    ::=    '[' (',')* ']'\r\n\t\t\t\t[4]    asize    ::=    '[' length~ ']'\r\n\t\t\t\t[5]    length    ::=    nextDimension* Digit+\r\n\t\t\t\t[6]    nextDimension    ::=    Digit+ ','\r\n\t\t\t\t*/\r\n\t\t\t\t$expr = '([A-Za-z0-9_]+):([A-Za-z]+[A-Za-z0-9_]+)\\[([0-9]+),?([0-9]*)\\]';\r\n\t\t\t\tif(ereg($expr,$value,$regs)){\r\n\t\t\t\t\t$this->message[$pos]['typePrefix'] = $regs[1];\r\n\t\t\t\t\t$this->message[$pos]['arrayTypePrefix'] = $regs[1];\r\n\t                if (isset($this->namespaces[$regs[1]])) {\r\n\t                \t$this->message[$pos]['arrayTypeNamespace'] = $this->namespaces[$regs[1]];\r\n\t                } else if (isset($attrs['xmlns:'.$regs[1]])) {\r\n\t\t\t\t\t\t$this->message[$pos]['arrayTypeNamespace'] = $attrs['xmlns:'.$regs[1]];\r\n\t                }\r\n\t\t\t\t\t$this->message[$pos]['arrayType'] = $regs[2];\r\n\t\t\t\t\t$this->message[$pos]['arraySize'] = $regs[3];\r\n\t\t\t\t\t$this->message[$pos]['arrayCols'] = $regs[4];\r\n\t\t\t\t}\r\n\t\t\t// specifies nil value (or not)\r\n\t\t\t} elseif ($key_localpart == 'nil'){\r\n\t\t\t\t$this->message[$pos]['nil'] = ($value == 'true' || $value == '1');\r\n\t\t\t// some other attribute\r\n\t\t\t} elseif ($key != 'href' && $key != 'xmlns' && $key_localpart != 'encodingStyle' && $key_localpart != 'root') {\r\n\t\t\t\t$this->message[$pos]['xattrs']['!' . $key] = $value;\r\n\t\t\t}\r\n\r\n\t\t\tif ($key == 'xmlns') {\r\n\t\t\t\t$this->default_namespace = $value;\r\n\t\t\t}\r\n\t\t\t// log id\r\n\t\t\tif($key == 'id'){\r\n\t\t\t\t$this->ids[$value] = $pos;\r\n\t\t\t}\r\n\t\t\t// root\r\n\t\t\tif($key_localpart == 'root' && $value == 1){\r\n\t\t\t\t$this->status = 'method';\r\n\t\t\t\t$this->root_struct_name = $name;\r\n\t\t\t\t$this->root_struct = $pos;\r\n\t\t\t\t$this->debug(\"found root struct $this->root_struct_name, pos $pos\");\r\n\t\t\t}\r\n            // for doclit\r\n            $attstr .= \" $key=\\\"$value\\\"\";\r\n\t\t}\r\n        // get namespace - must be done after namespace atts are processed\r\n\t\tif(isset($prefix)){\r\n\t\t\t$this->message[$pos]['namespace'] = $this->namespaces[$prefix];\r\n\t\t\t$this->default_namespace = $this->namespaces[$prefix];\r\n\t\t} else {\r\n\t\t\t$this->message[$pos]['namespace'] = $this->default_namespace;\r\n\t\t}\r\n        if($this->status == 'header'){\r\n        \tif ($this->root_header != $pos) {\r\n\t        \t$this->responseHeaders .= \"<\" . (isset($prefix) ? $prefix . ':' : '') . \"$name$attstr>\";\r\n\t        }\r\n        } elseif($this->root_struct_name != ''){\r\n        \t$this->document .= \"<\" . (isset($prefix) ? $prefix . ':' : '') . \"$name$attstr>\";\r\n        }\r\n\t}\r\n\r\n\t/**\r\n\t* end-element handler\r\n\t*\r\n\t* @param    resource $parser XML parser object\r\n\t* @param    string $name element name\r\n\t* @access   private\r\n\t*/\r\n\tfunction end_element($parser, $name) {\r\n\t\t// position of current element is equal to the last value left in depth_array for my depth\r\n\t\t$pos = $this->depth_array[$this->depth--];\r\n\r\n        // get element prefix\r\n\t\tif(strpos($name,':')){\r\n\t\t\t// get ns prefix\r\n\t\t\t$prefix = substr($name,0,strpos($name,':'));\r\n\t\t\t// get unqualified name\r\n\t\t\t$name = substr(strstr($name,':'),1);\r\n\t\t}\r\n\t\t\r\n\t\t// build to native type\r\n\t\tif(isset($this->body_position) && $pos > $this->body_position){\r\n\t\t\t// deal w/ multirefs\r\n\t\t\tif(isset($this->message[$pos]['attrs']['href'])){\r\n\t\t\t\t// get id\r\n\t\t\t\t$id = substr($this->message[$pos]['attrs']['href'],1);\r\n\t\t\t\t// add placeholder to href array\r\n\t\t\t\t$this->multirefs[$id][$pos] = 'placeholder';\r\n\t\t\t\t// add set a reference to it as the result value\r\n\t\t\t\t$this->message[$pos]['result'] =& $this->multirefs[$id][$pos];\r\n            // build complexType values\r\n\t\t\t} elseif($this->message[$pos]['children'] != ''){\r\n\t\t\t\t// if result has already been generated (struct/array)\r\n\t\t\t\tif(!isset($this->message[$pos]['result'])){\r\n\t\t\t\t\t$this->message[$pos]['result'] = $this->buildVal($pos);\r\n\t\t\t\t}\r\n\t\t\t// build complexType values of attributes and possibly simpleContent\r\n\t\t\t} elseif (isset($this->message[$pos]['xattrs'])) {\r\n\t\t\t\tif (isset($this->message[$pos]['nil']) && $this->message[$pos]['nil']) {\r\n\t\t\t\t\t$this->message[$pos]['xattrs']['!'] = null;\r\n\t\t\t\t} elseif (isset($this->message[$pos]['cdata']) && trim($this->message[$pos]['cdata']) != '') {\r\n\t            \tif (isset($this->message[$pos]['type'])) {\r\n\t\t\t\t\t\t$this->message[$pos]['xattrs']['!'] = $this->decodeSimple($this->message[$pos]['cdata'], $this->message[$pos]['type'], isset($this->message[$pos]['type_namespace']) ? $this->message[$pos]['type_namespace'] : '');\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$parent = $this->message[$pos]['parent'];\r\n\t\t\t\t\t\tif (isset($this->message[$parent]['type']) && ($this->message[$parent]['type'] == 'array') && isset($this->message[$parent]['arrayType'])) {\r\n\t\t\t\t\t\t\t$this->message[$pos]['xattrs']['!'] = $this->decodeSimple($this->message[$pos]['cdata'], $this->message[$parent]['arrayType'], isset($this->message[$parent]['arrayTypeNamespace']) ? $this->message[$parent]['arrayTypeNamespace'] : '');\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t$this->message[$pos]['xattrs']['!'] = $this->message[$pos]['cdata'];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t$this->message[$pos]['result'] = $this->message[$pos]['xattrs'];\r\n\t\t\t// set value of simpleType (or nil complexType)\r\n\t\t\t} else {\r\n            \t//$this->debug('adding data for scalar value '.$this->message[$pos]['name'].' of value '.$this->message[$pos]['cdata']);\r\n\t\t\t\tif (isset($this->message[$pos]['nil']) && $this->message[$pos]['nil']) {\r\n\t\t\t\t\t$this->message[$pos]['xattrs']['!'] = null;\r\n\t\t\t\t} elseif (isset($this->message[$pos]['type'])) {\r\n\t\t\t\t\t$this->message[$pos]['result'] = $this->decodeSimple($this->message[$pos]['cdata'], $this->message[$pos]['type'], isset($this->message[$pos]['type_namespace']) ? $this->message[$pos]['type_namespace'] : '');\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$parent = $this->message[$pos]['parent'];\r\n\t\t\t\t\tif (isset($this->message[$parent]['type']) && ($this->message[$parent]['type'] == 'array') && isset($this->message[$parent]['arrayType'])) {\r\n\t\t\t\t\t\t$this->message[$pos]['result'] = $this->decodeSimple($this->message[$pos]['cdata'], $this->message[$parent]['arrayType'], isset($this->message[$parent]['arrayTypeNamespace']) ? $this->message[$parent]['arrayTypeNamespace'] : '');\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$this->message[$pos]['result'] = $this->message[$pos]['cdata'];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* add value to parent's result, if parent is struct/array\r\n\t\t\t\t$parent = $this->message[$pos]['parent'];\r\n\t\t\t\tif($this->message[$parent]['type'] != 'map'){\r\n\t\t\t\t\tif(strtolower($this->message[$parent]['type']) == 'array'){\r\n\t\t\t\t\t\t$this->message[$parent]['result'][] = $this->message[$pos]['result'];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$this->message[$parent]['result'][$this->message[$pos]['name']] = $this->message[$pos]['result'];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t*/\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n        // for doclit\r\n        if($this->status == 'header'){\r\n        \tif ($this->root_header != $pos) {\r\n\t        \t$this->responseHeaders .= \"</\" . (isset($prefix) ? $prefix . ':' : '') . \"$name>\";\r\n\t        }\r\n        } elseif($pos >= $this->root_struct){\r\n        \t$this->document .= \"</\" . (isset($prefix) ? $prefix . ':' : '') . \"$name>\";\r\n        }\r\n\t\t// switch status\r\n\t\tif($pos == $this->root_struct){\r\n\t\t\t$this->status = 'body';\r\n\t\t\t$this->root_struct_namespace = $this->message[$pos]['namespace'];\r\n\t\t} elseif($name == 'Body'){\r\n\t\t\t$this->status = 'envelope';\r\n\t\t } elseif($name == 'Header'){\r\n\t\t\t$this->status = 'envelope';\r\n\t\t} elseif($name == 'Envelope'){\r\n\t\t\t//\r\n\t\t}\r\n\t\t// set parent back to my parent\r\n\t\t$this->parent = $this->message[$pos]['parent'];\r\n\t}\r\n\r\n\t/**\r\n\t* element content handler\r\n\t*\r\n\t* @param    resource $parser XML parser object\r\n\t* @param    string $data element content\r\n\t* @access   private\r\n\t*/\r\n\tfunction character_data($parser, $data){\r\n\t\t$pos = $this->depth_array[$this->depth];\r\n\t\tif ($this->xml_encoding=='UTF-8'){\r\n\t\t\t// TODO: add an option to disable this for folks who want\r\n\t\t\t// raw UTF-8 that, e.g., might not map to iso-8859-1\r\n\t\t\t// TODO: this can also be handled with xml_parser_set_option($this->parser, XML_OPTION_TARGET_ENCODING, \"ISO-8859-1\");\r\n\t\t\tif($this->decode_utf8){\r\n\t\t\t\t$data = utf8_decode($data);\r\n\t\t\t}\r\n\t\t}\r\n        $this->message[$pos]['cdata'] .= $data;\r\n        // for doclit\r\n        if($this->status == 'header'){\r\n        \t$this->responseHeaders .= $data;\r\n        } else {\r\n        \t$this->document .= $data;\r\n        }\r\n\t}\r\n\r\n\t/**\r\n\t* get the parsed message (SOAP Body)\r\n\t*\r\n\t* @return\tmixed\r\n\t* @access   public\r\n\t* @deprecated\tuse get_soapbody instead\r\n\t*/\r\n\tfunction get_response(){\r\n\t\treturn $this->soapresponse;\r\n\t}\r\n\r\n\t/**\r\n\t* get the parsed SOAP Body (NULL if there was none)\r\n\t*\r\n\t* @return\tmixed\r\n\t* @access   public\r\n\t*/\r\n\tfunction get_soapbody(){\r\n\t\treturn $this->soapresponse;\r\n\t}\r\n\r\n\t/**\r\n\t* get the parsed SOAP Header (NULL if there was none)\r\n\t*\r\n\t* @return\tmixed\r\n\t* @access   public\r\n\t*/\r\n\tfunction get_soapheader(){\r\n\t\treturn $this->soapheader;\r\n\t}\r\n\r\n\t/**\r\n\t* get the unparsed SOAP Header\r\n\t*\r\n\t* @return\tstring XML or empty if no Header\r\n\t* @access   public\r\n\t*/\r\n\tfunction getHeaders(){\r\n\t    return $this->responseHeaders;\r\n\t}\r\n\r\n\t/**\r\n\t* decodes simple types into PHP variables\r\n\t*\r\n\t* @param    string $value value to decode\r\n\t* @param    string $type XML type to decode\r\n\t* @param    string $typens XML type namespace to decode\r\n\t* @return\tmixed PHP value\r\n\t* @access   private\r\n\t*/\r\n\tfunction decodeSimple($value, $type, $typens) {\r\n\t\t// TODO: use the namespace!\r\n\t\tif ((!isset($type)) || $type == 'string' || $type == 'long' || $type == 'unsignedLong') {\r\n\t\t\treturn (string) $value;\r\n\t\t}\r\n\t\tif ($type == 'int' || $type == 'integer' || $type == 'short' || $type == 'byte') {\r\n\t\t\treturn (int) $value;\r\n\t\t}\r\n\t\tif ($type == 'float' || $type == 'double' || $type == 'decimal') {\r\n\t\t\treturn (double) $value;\r\n\t\t}\r\n\t\tif ($type == 'boolean') {\r\n\t\t\tif (strtolower($value) == 'false' || strtolower($value) == 'f') {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\treturn (boolean) $value;\r\n\t\t}\r\n\t\tif ($type == 'base64' || $type == 'base64Binary') {\r\n\t\t\t$this->debug('Decode base64 value');\r\n\t\t\treturn base64_decode($value);\r\n\t\t}\r\n\t\t// obscure numeric types\r\n\t\tif ($type == 'nonPositiveInteger' || $type == 'negativeInteger'\r\n\t\t\t|| $type == 'nonNegativeInteger' || $type == 'positiveInteger'\r\n\t\t\t|| $type == 'unsignedInt'\r\n\t\t\t|| $type == 'unsignedShort' || $type == 'unsignedByte') {\r\n\t\t\treturn (int) $value;\r\n\t\t}\r\n\t\t// bogus: parser treats array with no elements as a simple type\r\n\t\tif ($type == 'array') {\r\n\t\t\treturn array();\r\n\t\t}\r\n\t\t// everything else\r\n\t\treturn (string) $value;\r\n\t}\r\n\r\n\t/**\r\n\t* builds response structures for compound values (arrays/structs)\r\n\t* and scalars\r\n\t*\r\n\t* @param    integer $pos position in node tree\r\n\t* @return\tmixed\tPHP value\r\n\t* @access   private\r\n\t*/\r\n\tfunction buildVal($pos){\r\n\t\tif(!isset($this->message[$pos]['type'])){\r\n\t\t\t$this->message[$pos]['type'] = '';\r\n\t\t}\r\n\t\t$this->debug('in buildVal() for '.$this->message[$pos]['name'].\"(pos $pos) of type \".$this->message[$pos]['type']);\r\n\t\t// if there are children...\r\n\t\tif($this->message[$pos]['children'] != ''){\r\n\t\t\t$this->debug('in buildVal, there are children');\r\n\t\t\t$children = explode('|',$this->message[$pos]['children']);\r\n\t\t\tarray_shift($children); // knock off empty\r\n\t\t\t// md array\r\n\t\t\tif(isset($this->message[$pos]['arrayCols']) && $this->message[$pos]['arrayCols'] != ''){\r\n            \t$r=0; // rowcount\r\n            \t$c=0; // colcount\r\n            \tforeach($children as $child_pos){\r\n\t\t\t\t\t$this->debug(\"in buildVal, got an MD array element: $r, $c\");\r\n\t\t\t\t\t$params[$r][] = $this->message[$child_pos]['result'];\r\n\t\t\t\t    $c++;\r\n\t\t\t\t    if($c == $this->message[$pos]['arrayCols']){\r\n\t\t\t\t    \t$c = 0;\r\n\t\t\t\t\t\t$r++;\r\n\t\t\t\t    }\r\n                }\r\n            // array\r\n\t\t\t} elseif($this->message[$pos]['type'] == 'array' || $this->message[$pos]['type'] == 'Array'){\r\n                $this->debug('in buildVal, adding array '.$this->message[$pos]['name']);\r\n                foreach($children as $child_pos){\r\n                \t$params[] = &$this->message[$child_pos]['result'];\r\n                }\r\n            // apache Map type: java hashtable\r\n            } elseif($this->message[$pos]['type'] == 'Map' && $this->message[$pos]['type_namespace'] == 'http://xml.apache.org/xml-soap'){\r\n                $this->debug('in buildVal, Java Map '.$this->message[$pos]['name']);\r\n                foreach($children as $child_pos){\r\n                \t$kv = explode(\"|\",$this->message[$child_pos]['children']);\r\n                   \t$params[$this->message[$kv[1]]['result']] = &$this->message[$kv[2]]['result'];\r\n                }\r\n            // generic compound type\r\n            //} elseif($this->message[$pos]['type'] == 'SOAPStruct' || $this->message[$pos]['type'] == 'struct') {\r\n\t\t    } else {\r\n\t    \t\t// Apache Vector type: treat as an array\r\n                $this->debug('in buildVal, adding Java Vector or generic compound type '.$this->message[$pos]['name']);\r\n\t\t\t\tif ($this->message[$pos]['type'] == 'Vector' && $this->message[$pos]['type_namespace'] == 'http://xml.apache.org/xml-soap') {\r\n\t\t\t\t\t$notstruct = 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$notstruct = 0;\r\n\t            }\r\n            \t//\r\n            \tforeach($children as $child_pos){\r\n            \t\tif($notstruct){\r\n            \t\t\t$params[] = &$this->message[$child_pos]['result'];\r\n            \t\t} else {\r\n            \t\t\tif (isset($params[$this->message[$child_pos]['name']])) {\r\n            \t\t\t\t// de-serialize repeated element name into an array\r\n            \t\t\t\tif ((!is_array($params[$this->message[$child_pos]['name']])) || (!isset($params[$this->message[$child_pos]['name']][0]))) {\r\n            \t\t\t\t\t$params[$this->message[$child_pos]['name']] = array($params[$this->message[$child_pos]['name']]);\r\n            \t\t\t\t}\r\n            \t\t\t\t$params[$this->message[$child_pos]['name']][] = &$this->message[$child_pos]['result'];\r\n            \t\t\t} else {\r\n\t\t\t\t\t    \t$params[$this->message[$child_pos]['name']] = &$this->message[$child_pos]['result'];\r\n\t\t\t\t\t    }\r\n                \t}\r\n                }\r\n\t\t\t}\r\n\t\t\tif (isset($this->message[$pos]['xattrs'])) {\r\n                $this->debug('in buildVal, handling attributes');\r\n\t\t\t\tforeach ($this->message[$pos]['xattrs'] as $n => $v) {\r\n\t\t\t\t\t$params[$n] = $v;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// handle simpleContent\r\n\t\t\tif (isset($this->message[$pos]['cdata']) && trim($this->message[$pos]['cdata']) != '') {\r\n                $this->debug('in buildVal, handling simpleContent');\r\n            \tif (isset($this->message[$pos]['type'])) {\r\n\t\t\t\t\t$params['!'] = $this->decodeSimple($this->message[$pos]['cdata'], $this->message[$pos]['type'], isset($this->message[$pos]['type_namespace']) ? $this->message[$pos]['type_namespace'] : '');\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$parent = $this->message[$pos]['parent'];\r\n\t\t\t\t\tif (isset($this->message[$parent]['type']) && ($this->message[$parent]['type'] == 'array') && isset($this->message[$parent]['arrayType'])) {\r\n\t\t\t\t\t\t$params['!'] = $this->decodeSimple($this->message[$pos]['cdata'], $this->message[$parent]['arrayType'], isset($this->message[$parent]['arrayTypeNamespace']) ? $this->message[$parent]['arrayTypeNamespace'] : '');\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$params['!'] = $this->message[$pos]['cdata'];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t$ret = is_array($params) ? $params : array();\r\n\t\t\t$this->debug('in buildVal, return:');\r\n\t\t\t$this->appendDebug($this->varDump($ret));\r\n\t\t\treturn $ret;\r\n\t\t} else {\r\n        \t$this->debug('in buildVal, no children, building scalar');\r\n\t\t\t$cdata = isset($this->message[$pos]['cdata']) ? $this->message[$pos]['cdata'] : '';\r\n        \tif (isset($this->message[$pos]['type'])) {\r\n\t\t\t\t$ret = $this->decodeSimple($cdata, $this->message[$pos]['type'], isset($this->message[$pos]['type_namespace']) ? $this->message[$pos]['type_namespace'] : '');\r\n\t\t\t\t$this->debug(\"in buildVal, return: $ret\");\r\n\t\t\t\treturn $ret;\r\n\t\t\t}\r\n\t\t\t$parent = $this->message[$pos]['parent'];\r\n\t\t\tif (isset($this->message[$parent]['type']) && ($this->message[$parent]['type'] == 'array') && isset($this->message[$parent]['arrayType'])) {\r\n\t\t\t\t$ret = $this->decodeSimple($cdata, $this->message[$parent]['arrayType'], isset($this->message[$parent]['arrayTypeNamespace']) ? $this->message[$parent]['arrayTypeNamespace'] : '');\r\n\t\t\t\t$this->debug(\"in buildVal, return: $ret\");\r\n\t\t\t\treturn $ret;\r\n\t\t\t}\r\n           \t$ret = $this->message[$pos]['cdata'];\r\n\t\t\t$this->debug(\"in buildVal, return: $ret\");\r\n           \treturn $ret;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Backward compatibility\r\n */\r\nclass soap_parser extends nusoap_parser {\r\n}\r\n\r\n?><?php\r\n\r\n\r\n\r\n/**\r\n*\r\n* [nu]soapclient higher level class for easy usage.\r\n*\r\n* usage:\r\n*\r\n* // instantiate client with server info\r\n* $soapclient = new nusoap_client( string path [ ,mixed wsdl] );\r\n*\r\n* // call method, get results\r\n* echo $soapclient->call( string methodname [ ,array parameters] );\r\n*\r\n* // bye bye client\r\n* unset($soapclient);\r\n*\r\n* @author   Dietrich Ayala <dietrich@ganx4.com>\r\n* @author   Scott Nichol <snichol@users.sourceforge.net>\r\n* @version  $Id: nusoap.php,v 1.114 2007/11/06 15:17:46 snichol Exp $\r\n* @access   public\r\n*/\r\nclass nusoap_client extends nusoap_base  {\r\n\r\n\tvar $username = '';\t\t\t\t// Username for HTTP authentication\r\n\tvar $password = '';\t\t\t\t// Password for HTTP authentication\r\n\tvar $authtype = '';\t\t\t\t// Type of HTTP authentication\r\n\tvar $certRequest = array();\t\t// Certificate for HTTP SSL authentication\r\n\tvar $requestHeaders = false;\t// SOAP headers in request (text)\r\n\tvar $responseHeaders = '';\t\t// SOAP headers from response (incomplete namespace resolution) (text)\r\n\tvar $responseHeader = NULL;\t\t// SOAP Header from response (parsed)\r\n\tvar $document = '';\t\t\t\t// SOAP body response portion (incomplete namespace resolution) (text)\r\n\tvar $endpoint;\r\n\tvar $forceEndpoint = '';\t\t// overrides WSDL endpoint\r\n    var $proxyhost = '';\r\n    var $proxyport = '';\r\n\tvar $proxyusername = '';\r\n\tvar $proxypassword = '';\r\n    var $xml_encoding = '';\t\t\t// character set encoding of incoming (response) messages\r\n\tvar $http_encoding = false;\r\n\tvar $timeout = 0;\t\t\t\t// HTTP connection timeout\r\n\tvar $response_timeout = 30;\t\t// HTTP response timeout\r\n\tvar $endpointType = '';\t\t\t// soap|wsdl, empty for WSDL initialization error\r\n\tvar $persistentConnection = false;\r\n\tvar $defaultRpcParams = false;\t// This is no longer used\r\n\tvar $request = '';\t\t\t\t// HTTP request\r\n\tvar $response = '';\t\t\t\t// HTTP response\r\n\tvar $responseData = '';\t\t\t// SOAP payload of response\r\n\tvar $cookies = array();\t\t\t// Cookies from response or for request\r\n    var $decode_utf8 = true;\t\t// toggles whether the parser decodes element content w/ utf8_decode()\r\n\tvar $operations = array();\t\t// WSDL operations, empty for WSDL initialization error\r\n\tvar $curl_options = array();\t// User-specified cURL options\r\n\tvar $bindingType = '';\t\t\t// WSDL operation binding type\r\n\tvar $use_curl = false;\t\t\t// whether to always try to use cURL\r\n\r\n\t/*\r\n\t * fault related variables\r\n\t */\r\n\t/**\r\n\t * @var      fault\r\n\t * @access   public\r\n\t */\r\n\tvar $fault;\r\n\t/**\r\n\t * @var      faultcode\r\n\t * @access   public\r\n\t */\r\n\tvar $faultcode;\r\n\t/**\r\n\t * @var      faultstring\r\n\t * @access   public\r\n\t */\r\n\tvar $faultstring;\r\n\t/**\r\n\t * @var      faultdetail\r\n\t * @access   public\r\n\t */\r\n\tvar $faultdetail;\r\n\r\n\t/**\r\n\t* constructor\r\n\t*\r\n\t* @param    mixed $endpoint SOAP server or WSDL URL (string), or wsdl instance (object)\r\n\t* @param    bool $wsdl optional, set to true if using WSDL\r\n\t* @param\tint $portName optional portName in WSDL document\r\n\t* @param    string $proxyhost\r\n\t* @param    string $proxyport\r\n\t* @param\tstring $proxyusername\r\n\t* @param\tstring $proxypassword\r\n\t* @param\tinteger $timeout set the connection timeout\r\n\t* @param\tinteger $response_timeout set the response timeout\r\n\t* @access   public\r\n\t*/\r\n\tfunction nusoap_client($endpoint,$wsdl = false,$proxyhost = false,$proxyport = false,$proxyusername = false, $proxypassword = false, $timeout = 0, $response_timeout = 30){\r\n\t\tparent::nusoap_base();\r\n\t\t$this->endpoint = $endpoint;\r\n\t\t$this->proxyhost = $proxyhost;\r\n\t\t$this->proxyport = $proxyport;\r\n\t\t$this->proxyusername = $proxyusername;\r\n\t\t$this->proxypassword = $proxypassword;\r\n\t\t$this->timeout = $timeout;\r\n\t\t$this->response_timeout = $response_timeout;\r\n\r\n\t\t$this->debug(\"ctor wsdl=$wsdl timeout=$timeout response_timeout=$response_timeout\");\r\n\t\t$this->appendDebug('endpoint=' . $this->varDump($endpoint));\r\n\r\n\t\t// make values\r\n\t\tif($wsdl){\r\n\t\t\tif (is_object($endpoint) && (get_class($endpoint) == 'wsdl')) {\r\n\t\t\t\t$this->wsdl = $endpoint;\r\n\t\t\t\t$this->endpoint = $this->wsdl->wsdl;\r\n\t\t\t\t$this->wsdlFile = $this->endpoint;\r\n\t\t\t\t$this->debug('existing wsdl instance created from ' . $this->endpoint);\r\n\t\t\t\t$this->checkWSDL();\r\n\t\t\t} else {\r\n\t\t\t\t$this->wsdlFile = $this->endpoint;\r\n\t\t\t\t$this->wsdl = null;\r\n\t\t\t\t$this->debug('will use lazy evaluation of wsdl from ' . $this->endpoint);\r\n\t\t\t}\r\n\t\t\t$this->endpointType = 'wsdl';\r\n\t\t} else {\r\n\t\t\t$this->debug(\"instantiate SOAP with endpoint at $endpoint\");\r\n\t\t\t$this->endpointType = 'soap';\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* calls method, returns PHP native type\r\n\t*\r\n\t* @param    string $operation SOAP server URL or path\r\n\t* @param    mixed $params An array, associative or simple, of the parameters\r\n\t*\t\t\t              for the method call, or a string that is the XML\r\n\t*\t\t\t              for the call.  For rpc style, this call will\r\n\t*\t\t\t              wrap the XML in a tag named after the method, as\r\n\t*\t\t\t              well as the SOAP Envelope and Body.  For document\r\n\t*\t\t\t              style, this will only wrap with the Envelope and Body.\r\n\t*\t\t\t              IMPORTANT: when using an array with document style,\r\n\t*\t\t\t              in which case there\r\n\t*                         is really one parameter, the root of the fragment\r\n\t*                         used in the call, which encloses what programmers\r\n\t*                         normally think of parameters.  A parameter array\r\n\t*                         *must* include the wrapper.\r\n\t* @param\tstring $namespace optional method namespace (WSDL can override)\r\n\t* @param\tstring $soapAction optional SOAPAction value (WSDL can override)\r\n\t* @param\tmixed $headers optional string of XML with SOAP header content, or array of soapval objects for SOAP headers, or associative array\r\n\t* @param\tboolean $rpcParams optional (no longer used)\r\n\t* @param\tstring\t$style optional (rpc|document) the style to use when serializing parameters (WSDL can override)\r\n\t* @param\tstring\t$use optional (encoded|literal) the use when serializing parameters (WSDL can override)\r\n\t* @return\tmixed\tresponse from SOAP call\r\n\t* @access   public\r\n\t*/\r\n\tfunction call($operation,$params=array(),$namespace='http://tempuri.org',$soapAction='',$headers=false,$rpcParams=null,$style='rpc',$use='encoded'){\r\n\t\t$this->operation = $operation;\r\n\t\t$this->fault = false;\r\n\t\t$this->setError('');\r\n\t\t$this->request = '';\r\n\t\t$this->response = '';\r\n\t\t$this->responseData = '';\r\n\t\t$this->faultstring = '';\r\n\t\t$this->faultcode = '';\r\n\t\t$this->opData = array();\r\n\t\t\r\n\t\t$this->debug(\"call: operation=$operation, namespace=$namespace, soapAction=$soapAction, rpcParams=$rpcParams, style=$style, use=$use, endpointType=$this->endpointType\");\r\n\t\t$this->appendDebug('params=' . $this->varDump($params));\r\n\t\t$this->appendDebug('headers=' . $this->varDump($headers));\r\n\t\tif ($headers) {\r\n\t\t\t$this->requestHeaders = $headers;\r\n\t\t}\r\n\t\tif ($this->endpointType == 'wsdl' && is_null($this->wsdl)) {\r\n\t\t\t$this->loadWSDL();\r\n\t\t\tif ($this->getError())\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t\t// serialize parameters\r\n\t\tif($this->endpointType == 'wsdl' && $opData = $this->getOperationData($operation)){\r\n\t\t\t// use WSDL for operation\r\n\t\t\t$this->opData = $opData;\r\n\t\t\t$this->debug(\"found operation\");\r\n\t\t\t$this->appendDebug('opData=' . $this->varDump($opData));\r\n\t\t\tif (isset($opData['soapAction'])) {\r\n\t\t\t\t$soapAction = $opData['soapAction'];\r\n\t\t\t}\r\n\t\t\tif (! $this->forceEndpoint) {\r\n\t\t\t\t$this->endpoint = $opData['endpoint'];\r\n\t\t\t} else {\r\n\t\t\t\t$this->endpoint = $this->forceEndpoint;\r\n\t\t\t}\r\n\t\t\t$namespace = isset($opData['input']['namespace']) ? $opData['input']['namespace'] :\t$namespace;\r\n\t\t\t$style = $opData['style'];\r\n\t\t\t$use = $opData['input']['use'];\r\n\t\t\t// add ns to ns array\r\n\t\t\tif($namespace != '' && !isset($this->wsdl->namespaces[$namespace])){\r\n\t\t\t\t$nsPrefix = 'ns' . rand(1000, 9999);\r\n\t\t\t\t$this->wsdl->namespaces[$nsPrefix] = $namespace;\r\n\t\t\t}\r\n            $nsPrefix = $this->wsdl->getPrefixFromNamespace($namespace);\r\n\t\t\t// serialize payload\r\n\t\t\tif (is_string($params)) {\r\n\t\t\t\t$this->debug(\"serializing param string for WSDL operation $operation\");\r\n\t\t\t\t$payload = $params;\r\n\t\t\t} elseif (is_array($params)) {\r\n\t\t\t\t$this->debug(\"serializing param array for WSDL operation $operation\");\r\n\t\t\t\t$payload = $this->wsdl->serializeRPCParameters($operation,'input',$params,$this->bindingType);\r\n\t\t\t} else {\r\n\t\t\t\t$this->debug('params must be array or string');\r\n\t\t\t\t$this->setError('params must be array or string');\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n            $usedNamespaces = $this->wsdl->usedNamespaces;\r\n\t\t\tif (isset($opData['input']['encodingStyle'])) {\r\n\t\t\t\t$encodingStyle = $opData['input']['encodingStyle'];\r\n\t\t\t} else {\r\n\t\t\t\t$encodingStyle = '';\r\n\t\t\t}\r\n\t\t\t$this->appendDebug($this->wsdl->getDebug());\r\n\t\t\t$this->wsdl->clearDebug();\r\n\t\t\tif ($errstr = $this->wsdl->getError()) {\r\n\t\t\t\t$this->debug('got wsdl error: '.$errstr);\r\n\t\t\t\t$this->setError('wsdl error: '.$errstr);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t} elseif($this->endpointType == 'wsdl') {\r\n\t\t\t// operation not in WSDL\r\n\t\t\t$this->appendDebug($this->wsdl->getDebug());\r\n\t\t\t$this->wsdl->clearDebug();\r\n\t\t\t$this->setError( 'operation '.$operation.' not present.');\r\n\t\t\t$this->debug(\"operation '$operation' not present.\");\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\t// no WSDL\r\n\t\t\t//$this->namespaces['ns1'] = $namespace;\r\n\t\t\t$nsPrefix = 'ns' . rand(1000, 9999);\r\n\t\t\t// serialize \r\n\t\t\t$payload = '';\r\n\t\t\tif (is_string($params)) {\r\n\t\t\t\t$this->debug(\"serializing param string for operation $operation\");\r\n\t\t\t\t$payload = $params;\r\n\t\t\t} elseif (is_array($params)) {\r\n\t\t\t\t$this->debug(\"serializing param array for operation $operation\");\r\n\t\t\t\tforeach($params as $k => $v){\r\n\t\t\t\t\t$payload .= $this->serialize_val($v,$k,false,false,false,false,$use);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t$this->debug('params must be array or string');\r\n\t\t\t\t$this->setError('params must be array or string');\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t$usedNamespaces = array();\r\n\t\t\tif ($use == 'encoded') {\r\n\t\t\t\t$encodingStyle = 'http://schemas.xmlsoap.org/soap/encoding/';\r\n\t\t\t} else {\r\n\t\t\t\t$encodingStyle = '';\r\n\t\t\t}\r\n\t\t}\r\n\t\t// wrap RPC calls with method element\r\n\t\tif ($style == 'rpc') {\r\n\t\t\tif ($use == 'literal') {\r\n\t\t\t\t$this->debug(\"wrapping RPC request with literal method element\");\r\n\t\t\t\tif ($namespace) {\r\n\t\t\t\t\t// http://www.ws-i.org/Profiles/BasicProfile-1.1-2004-08-24.html R2735 says rpc/literal accessor elements should not be in a namespace\r\n\t\t\t\t\t$payload = \"<$nsPrefix:$operation xmlns:$nsPrefix=\\\"$namespace\\\">\" .\r\n\t\t\t\t\t\t\t\t$payload .\r\n\t\t\t\t\t\t\t\t\"</$nsPrefix:$operation>\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$payload = \"<$operation>\" . $payload . \"</$operation>\";\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t$this->debug(\"wrapping RPC request with encoded method element\");\r\n\t\t\t\tif ($namespace) {\r\n\t\t\t\t\t$payload = \"<$nsPrefix:$operation xmlns:$nsPrefix=\\\"$namespace\\\">\" .\r\n\t\t\t\t\t\t\t\t$payload .\r\n\t\t\t\t\t\t\t\t\"</$nsPrefix:$operation>\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$payload = \"<$operation>\" .\r\n\t\t\t\t\t\t\t\t$payload .\r\n\t\t\t\t\t\t\t\t\"</$operation>\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// serialize envelope\r\n\t\t$soapmsg = $this->serializeEnvelope($payload,$this->requestHeaders,$usedNamespaces,$style,$use,$encodingStyle);\r\n\t\t$this->debug(\"endpoint=$this->endpoint, soapAction=$soapAction, namespace=$namespace, style=$style, use=$use, encodingStyle=$encodingStyle\");\r\n\t\t$this->debug('SOAP message length=' . strlen($soapmsg) . ' contents (max 1000 bytes)=' . substr($soapmsg, 0, 1000));\r\n\t\t// send\r\n\t\t$return = $this->send($this->getHTTPBody($soapmsg),$soapAction,$this->timeout,$this->response_timeout);\r\n\t\tif($errstr = $this->getError()){\r\n\t\t\t$this->debug('Error: '.$errstr);\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\t$this->return = $return;\r\n\t\t\t$this->debug('sent message successfully and got a(n) '.gettype($return));\r\n           \t$this->appendDebug('return=' . $this->varDump($return));\r\n\t\t\t\r\n\t\t\t// fault?\r\n\t\t\tif(is_array($return) && isset($return['faultcode'])){\r\n\t\t\t\t$this->debug('got fault');\r\n\t\t\t\t$this->setError($return['faultcode'].': '.$return['faultstring']);\r\n\t\t\t\t$this->fault = true;\r\n\t\t\t\tforeach($return as $k => $v){\r\n\t\t\t\t\t$this->$k = $v;\r\n\t\t\t\t\t$this->debug(\"$k = $v<br>\");\r\n\t\t\t\t}\r\n\t\t\t\treturn $return;\r\n\t\t\t} elseif ($style == 'document') {\r\n\t\t\t\t// NOTE: if the response is defined to have multiple parts (i.e. unwrapped),\r\n\t\t\t\t// we are only going to return the first part here...sorry about that\r\n\t\t\t\treturn $return;\r\n\t\t\t} else {\r\n\t\t\t\t// array of return values\r\n\t\t\t\tif(is_array($return)){\r\n\t\t\t\t\t// multiple 'out' parameters, which we return wrapped up\r\n\t\t\t\t\t// in the array\r\n\t\t\t\t\tif(sizeof($return) > 1){\r\n\t\t\t\t\t\treturn $return;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// single 'out' parameter (normally the return value)\r\n\t\t\t\t\t$return = array_shift($return);\r\n\t\t\t\t\t$this->debug('return shifted value: ');\r\n\t\t\t\t\t$this->appendDebug($this->varDump($return));\r\n           \t\t\treturn $return;\r\n\t\t\t\t// nothing returned (ie, echoVoid)\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn \"\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* check WSDL passed as an instance or pulled from an endpoint\r\n\t*\r\n\t* @access   private\r\n\t*/\r\n\tfunction checkWSDL() {\r\n\t\t$this->appendDebug($this->wsdl->getDebug());\r\n\t\t$this->wsdl->clearDebug();\r\n\t\t$this->debug('checkWSDL');\r\n\t\t// catch errors\r\n\t\tif ($errstr = $this->wsdl->getError()) {\r\n\t\t\t$this->debug('got wsdl error: '.$errstr);\r\n\t\t\t$this->setError('wsdl error: '.$errstr);\r\n\t\t} elseif ($this->operations = $this->wsdl->getOperations('soap')) {\r\n\t\t\t$this->bindingType = 'soap';\r\n\t\t\t$this->debug('got '.count($this->operations).' operations from wsdl '.$this->wsdlFile.' for binding type '.$this->bindingType);\r\n\t\t} elseif ($this->operations = $this->wsdl->getOperations('soap12')) {\r\n\t\t\t$this->bindingType = 'soap12';\r\n\t\t\t$this->debug('got '.count($this->operations).' operations from wsdl '.$this->wsdlFile.' for binding type '.$this->bindingType);\r\n\t\t\t$this->debug('**************** WARNING: SOAP 1.2 BINDING *****************');\r\n\t\t} else {\r\n\t\t\t$this->debug('getOperations returned false');\r\n\t\t\t$this->setError('no operations defined in the WSDL document!');\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * instantiate wsdl object and parse wsdl file\r\n\t *\r\n\t * @access\tpublic\r\n\t */\r\n\tfunction loadWSDL() {\r\n\t\t$this->debug('instantiating wsdl class with doc: '.$this->wsdlFile);\r\n\t\t$this->wsdl =& new wsdl('',$this->proxyhost,$this->proxyport,$this->proxyusername,$this->proxypassword,$this->timeout,$this->response_timeout,$this->curl_options,$this->use_curl);\r\n\t\t$this->wsdl->setCredentials($this->username, $this->password, $this->authtype, $this->certRequest);\r\n\t\t$this->wsdl->fetchWSDL($this->wsdlFile);\r\n\t\t$this->checkWSDL();\r\n\t}\r\n\r\n\t/**\r\n\t* get available data pertaining to an operation\r\n\t*\r\n\t* @param    string $operation operation name\r\n\t* @return\tarray array of data pertaining to the operation\r\n\t* @access   public\r\n\t*/\r\n\tfunction getOperationData($operation){\r\n\t\tif ($this->endpointType == 'wsdl' && is_null($this->wsdl)) {\r\n\t\t\t$this->loadWSDL();\r\n\t\t\tif ($this->getError())\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t\tif(isset($this->operations[$operation])){\r\n\t\t\treturn $this->operations[$operation];\r\n\t\t}\r\n\t\t$this->debug(\"No data for operation: $operation\");\r\n\t}\r\n\r\n    /**\r\n    * send the SOAP message\r\n    *\r\n    * Note: if the operation has multiple return values\r\n    * the return value of this method will be an array\r\n    * of those values.\r\n    *\r\n\t* @param    string $msg a SOAPx4 soapmsg object\r\n\t* @param    string $soapaction SOAPAction value\r\n\t* @param    integer $timeout set connection timeout in seconds\r\n\t* @param\tinteger $response_timeout set response timeout in seconds\r\n\t* @return\tmixed native PHP types.\r\n\t* @access   private\r\n\t*/\r\n\tfunction send($msg, $soapaction = '', $timeout=0, $response_timeout=30) {\r\n\t\t$this->checkCookies();\r\n\t\t// detect transport\r\n\t\tswitch(true){\r\n\t\t\t// http(s)\r\n\t\t\tcase ereg('^http',$this->endpoint):\r\n\t\t\t\t$this->debug('transporting via HTTP');\r\n\t\t\t\tif($this->persistentConnection == true && is_object($this->persistentConnection)){\r\n\t\t\t\t\t$http =& $this->persistentConnection;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$http = new soap_transport_http($this->endpoint, $this->curl_options, $this->use_curl);\r\n\t\t\t\t\tif ($this->persistentConnection) {\r\n\t\t\t\t\t\t$http->usePersistentConnection();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t$http->setContentType($this->getHTTPContentType(), $this->getHTTPContentTypeCharset());\r\n\t\t\t\t$http->setSOAPAction($soapaction);\r\n\t\t\t\tif($this->proxyhost && $this->proxyport){\r\n\t\t\t\t\t$http->setProxy($this->proxyhost,$this->proxyport,$this->proxyusername,$this->proxypassword);\r\n\t\t\t\t}\r\n                if($this->authtype != '') {\r\n\t\t\t\t\t$http->setCredentials($this->username, $this->password, $this->authtype, array(), $this->certRequest);\r\n\t\t\t\t}\r\n\t\t\t\tif($this->http_encoding != ''){\r\n\t\t\t\t\t$http->setEncoding($this->http_encoding);\r\n\t\t\t\t}\r\n\t\t\t\t$this->debug('sending message, length='.strlen($msg));\r\n\t\t\t\tif(ereg('^http:',$this->endpoint)){\r\n\t\t\t\t//if(strpos($this->endpoint,'http:')){\r\n\t\t\t\t\t$this->responseData = $http->send($msg,$timeout,$response_timeout,$this->cookies);\r\n\t\t\t\t} elseif(ereg('^https',$this->endpoint)){\r\n\t\t\t\t//} elseif(strpos($this->endpoint,'https:')){\r\n\t\t\t\t\t//if(phpversion() == '4.3.0-dev'){\r\n\t\t\t\t\t\t//$response = $http->send($msg,$timeout,$response_timeout);\r\n                   \t\t//$this->request = $http->outgoing_payload;\r\n\t\t\t\t\t\t//$this->response = $http->incoming_payload;\r\n\t\t\t\t\t//} else\r\n\t\t\t\t\t$this->responseData = $http->sendHTTPS($msg,$timeout,$response_timeout,$this->cookies);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$this->setError('no http/s in endpoint url');\r\n\t\t\t\t}\r\n\t\t\t\t$this->request = $http->outgoing_payload;\r\n\t\t\t\t$this->response = $http->incoming_payload;\r\n\t\t\t\t$this->appendDebug($http->getDebug());\r\n\t\t\t\t$this->UpdateCookies($http->incoming_cookies);\r\n\r\n\t\t\t\t// save transport object if using persistent connections\r\n\t\t\t\tif ($this->persistentConnection) {\r\n\t\t\t\t\t$http->clearDebug();\r\n\t\t\t\t\tif (!is_object($this->persistentConnection)) {\r\n\t\t\t\t\t\t$this->persistentConnection = $http;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif($err = $http->getError()){\r\n\t\t\t\t\t$this->setError('HTTP Error: '.$err);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t} elseif($this->getError()){\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$this->debug('got response, length='. strlen($this->responseData).' type='.$http->incoming_headers['content-type']);\r\n\t\t\t\t\treturn $this->parseResponse($http->incoming_headers, $this->responseData);\r\n\t\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\t$this->setError('no transport found, or selected transport is not yet supported!');\r\n\t\t\treturn false;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* processes SOAP message returned from server\r\n\t*\r\n\t* @param\tarray\t$headers\tThe HTTP headers\r\n\t* @param\tstring\t$data\t\tunprocessed response data from server\r\n\t* @return\tmixed\tvalue of the message, decoded into a PHP type\r\n\t* @access   private\r\n\t*/\r\n    function parseResponse($headers, $data) {\r\n\t\t$this->debug('Entering parseResponse() for data of length ' . strlen($data) . ' headers:');\r\n\t\t$this->appendDebug($this->varDump($headers));\r\n\t\tif (!strstr($headers['content-type'], 'text/xml')) {\r\n\t\t\t$this->setError('Response not of type text/xml: ' . $headers['content-type']);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (strpos($headers['content-type'], '=')) {\r\n\t\t\t$enc = str_replace('\"', '', substr(strstr($headers[\"content-type\"], '='), 1));\r\n\t\t\t$this->debug('Got response encoding: ' . $enc);\r\n\t\t\tif(eregi('^(ISO-8859-1|US-ASCII|UTF-8)$',$enc)){\r\n\t\t\t\t$this->xml_encoding = strtoupper($enc);\r\n\t\t\t} else {\r\n\t\t\t\t$this->xml_encoding = 'US-ASCII';\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1\r\n\t\t\t$this->xml_encoding = 'ISO-8859-1';\r\n\t\t}\r\n\t\t$this->debug('Use encoding: ' . $this->xml_encoding . ' when creating nusoap_parser');\r\n\t\t$parser = new nusoap_parser($data,$this->xml_encoding,$this->operation,$this->decode_utf8);\r\n\t\t// add parser debug data to our debug\r\n\t\t$this->appendDebug($parser->getDebug());\r\n\t\t// if parse errors\r\n\t\tif($errstr = $parser->getError()){\r\n\t\t\t$this->setError( $errstr);\r\n\t\t\t// destroy the parser object\r\n\t\t\tunset($parser);\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\t// get SOAP headers\r\n\t\t\t$this->responseHeaders = $parser->getHeaders();\r\n\t\t\t// get SOAP headers\r\n\t\t\t$this->responseHeader = $parser->get_soapheader();\r\n\t\t\t// get decoded message\r\n\t\t\t$return = $parser->get_soapbody();\r\n            // add document for doclit support\r\n            $this->document = $parser->document;\r\n\t\t\t// destroy the parser object\r\n\t\t\tunset($parser);\r\n\t\t\t// return decode message\r\n\t\t\treturn $return;\r\n\t\t}\r\n\t }\r\n\r\n\t/**\r\n\t* sets user-specified cURL options\r\n\t*\r\n\t* @param\tmixed $option The cURL option (always integer?)\r\n\t* @param\tmixed $value The cURL option value\r\n\t* @access   public\r\n\t*/\r\n\tfunction setCurlOption($option, $value) {\r\n\t\t$this->debug(\"setCurlOption option=$option, value=\");\r\n\t\t$this->appendDebug($this->varDump($value));\r\n\t\t$this->curl_options[$option] = $value;\r\n\t}\r\n\r\n\t/**\r\n\t* sets the SOAP endpoint, which can override WSDL\r\n\t*\r\n\t* @param\tstring $endpoint The endpoint URL to use, or empty string or false to prevent override\r\n\t* @access   public\r\n\t*/\r\n\tfunction setEndpoint($endpoint) {\r\n\t\t$this->debug(\"setEndpoint(\\\"$endpoint\\\")\");\r\n\t\t$this->forceEndpoint = $endpoint;\r\n\t}\r\n\r\n\t/**\r\n\t* set the SOAP headers\r\n\t*\r\n\t* @param\tmixed $headers String of XML with SOAP header content, or array of soapval objects for SOAP headers\r\n\t* @access   public\r\n\t*/\r\n\tfunction setHeaders($headers){\r\n\t\t$this->debug(\"setHeaders headers=\");\r\n\t\t$this->appendDebug($this->varDump($headers));\r\n\t\t$this->requestHeaders = $headers;\r\n\t}\r\n\r\n\t/**\r\n\t* get the SOAP response headers (namespace resolution incomplete)\r\n\t*\r\n\t* @return\tstring\r\n\t* @access   public\r\n\t*/\r\n\tfunction getHeaders(){\r\n\t\treturn $this->responseHeaders;\r\n\t}\r\n\r\n\t/**\r\n\t* get the SOAP response Header (parsed)\r\n\t*\r\n\t* @return\tmixed\r\n\t* @access   public\r\n\t*/\r\n\tfunction getHeader(){\r\n\t\treturn $this->responseHeader;\r\n\t}\r\n\r\n\t/**\r\n\t* set proxy info here\r\n\t*\r\n\t* @param    string $proxyhost\r\n\t* @param    string $proxyport\r\n\t* @param\tstring $proxyusername\r\n\t* @param\tstring $proxypassword\r\n\t* @access   public\r\n\t*/\r\n\tfunction setHTTPProxy($proxyhost, $proxyport, $proxyusername = '', $proxypassword = '') {\r\n\t\t$this->proxyhost = $proxyhost;\r\n\t\t$this->proxyport = $proxyport;\r\n\t\t$this->proxyusername = $proxyusername;\r\n\t\t$this->proxypassword = $proxypassword;\r\n\t}\r\n\r\n\t/**\r\n\t* if authenticating, set user credentials here\r\n\t*\r\n\t* @param    string $username\r\n\t* @param    string $password\r\n\t* @param\tstring $authtype (basic|digest|certificate|ntlm)\r\n\t* @param\tarray $certRequest (keys must be cainfofile (optional), sslcertfile, sslkeyfile, passphrase, verifypeer (optional), verifyhost (optional): see corresponding options in cURL docs)\r\n\t* @access   public\r\n\t*/\r\n\tfunction setCredentials($username, $password, $authtype = 'basic', $certRequest = array()) {\r\n\t\t$this->debug(\"setCredentials username=$username authtype=$authtype certRequest=\");\r\n\t\t$this->appendDebug($this->varDump($certRequest));\r\n\t\t$this->username = $username;\r\n\t\t$this->password = $password;\r\n\t\t$this->authtype = $authtype;\r\n\t\t$this->certRequest = $certRequest;\r\n\t}\r\n\t\r\n\t/**\r\n\t* use HTTP encoding\r\n\t*\r\n\t* @param    string $enc HTTP encoding\r\n\t* @access   public\r\n\t*/\r\n\tfunction setHTTPEncoding($enc='gzip, deflate'){\r\n\t\t$this->debug(\"setHTTPEncoding(\\\"$enc\\\")\");\r\n\t\t$this->http_encoding = $enc;\r\n\t}\r\n\t\r\n\t/**\r\n\t* Set whether to try to use cURL connections if possible\r\n\t*\r\n\t* @param\tboolean $use Whether to try to use cURL\r\n\t* @access   public\r\n\t*/\r\n\tfunction setUseCURL($use) {\r\n\t\t$this->debug(\"setUseCURL($use)\");\r\n\t\t$this->use_curl = $use;\r\n\t}\r\n\r\n\t/**\r\n\t* use HTTP persistent connections if possible\r\n\t*\r\n\t* @access   public\r\n\t*/\r\n\tfunction useHTTPPersistentConnection(){\r\n\t\t$this->debug(\"useHTTPPersistentConnection\");\r\n\t\t$this->persistentConnection = true;\r\n\t}\r\n\t\r\n\t/**\r\n\t* gets the default RPC parameter setting.\r\n\t* If true, default is that call params are like RPC even for document style.\r\n\t* Each call() can override this value.\r\n\t*\r\n\t* This is no longer used.\r\n\t*\r\n\t* @return boolean\r\n\t* @access public\r\n\t* @deprecated\r\n\t*/\r\n\tfunction getDefaultRpcParams() {\r\n\t\treturn $this->defaultRpcParams;\r\n\t}\r\n\r\n\t/**\r\n\t* sets the default RPC parameter setting.\r\n\t* If true, default is that call params are like RPC even for document style\r\n\t* Each call() can override this value.\r\n\t*\r\n\t* This is no longer used.\r\n\t*\r\n\t* @param    boolean $rpcParams\r\n\t* @access public\r\n\t* @deprecated\r\n\t*/\r\n\tfunction setDefaultRpcParams($rpcParams) {\r\n\t\t$this->defaultRpcParams = $rpcParams;\r\n\t}\r\n\t\r\n\t/**\r\n\t* dynamically creates an instance of a proxy class,\r\n\t* allowing user to directly call methods from wsdl\r\n\t*\r\n\t* @return   object soap_proxy object\r\n\t* @access   public\r\n\t*/\r\n\tfunction getProxy() {\r\n\t\t$r = rand();\r\n\t\t$evalStr = $this->_getProxyClassCode($r);\r\n\t\t//$this->debug(\"proxy class: $evalStr\");\r\n\t\tif ($this->getError()) {\r\n\t\t\t$this->debug(\"Error from _getProxyClassCode, so return NULL\");\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t// eval the class\r\n\t\teval($evalStr);\r\n\t\t// instantiate proxy object\r\n\t\teval(\"\\$proxy = new nusoap_proxy_$r('');\");\r\n\t\t// transfer current wsdl data to the proxy thereby avoiding parsing the wsdl twice\r\n\t\t$proxy->endpointType = 'wsdl';\r\n\t\t$proxy->wsdlFile = $this->wsdlFile;\r\n\t\t$proxy->wsdl = $this->wsdl;\r\n\t\t$proxy->operations = $this->operations;\r\n\t\t$proxy->defaultRpcParams = $this->defaultRpcParams;\r\n\t\t// transfer other state\r\n\t\t$proxy->soap_defencoding = $this->soap_defencoding;\r\n\t\t$proxy->username = $this->username;\r\n\t\t$proxy->password = $this->password;\r\n\t\t$proxy->authtype = $this->authtype;\r\n\t\t$proxy->certRequest = $this->certRequest;\r\n\t\t$proxy->requestHeaders = $this->requestHeaders;\r\n\t\t$proxy->endpoint = $this->endpoint;\r\n\t\t$proxy->forceEndpoint = $this->forceEndpoint;\r\n\t\t$proxy->proxyhost = $this->proxyhost;\r\n\t\t$proxy->proxyport = $this->proxyport;\r\n\t\t$proxy->proxyusername = $this->proxyusername;\r\n\t\t$proxy->proxypassword = $this->proxypassword;\r\n\t\t$proxy->http_encoding = $this->http_encoding;\r\n\t\t$proxy->timeout = $this->timeout;\r\n\t\t$proxy->response_timeout = $this->response_timeout;\r\n\t\t$proxy->persistentConnection = &$this->persistentConnection;\r\n\t\t$proxy->decode_utf8 = $this->decode_utf8;\r\n\t\t$proxy->curl_options = $this->curl_options;\r\n\t\t$proxy->bindingType = $this->bindingType;\r\n\t\t$proxy->use_curl = $this->use_curl;\r\n\t\treturn $proxy;\r\n\t}\r\n\r\n\t/**\r\n\t* dynamically creates proxy class code\r\n\t*\r\n\t* @return   string PHP/NuSOAP code for the proxy class\r\n\t* @access   private\r\n\t*/\r\n\tfunction _getProxyClassCode($r) {\r\n\t\t$this->debug(\"in getProxy endpointType=$this->endpointType\");\r\n\t\t$this->appendDebug(\"wsdl=\" . $this->varDump($this->wsdl));\r\n\t\tif ($this->endpointType != 'wsdl') {\r\n\t\t\t$evalStr = 'A proxy can only be created for a WSDL client';\r\n\t\t\t$this->setError($evalStr);\r\n\t\t\t$evalStr = \"echo \\\"$evalStr\\\";\";\r\n\t\t\treturn $evalStr;\r\n\t\t}\r\n\t\tif ($this->endpointType == 'wsdl' && is_null($this->wsdl)) {\r\n\t\t\t$this->loadWSDL();\r\n\t\t\tif ($this->getError()) {\r\n\t\t\t\treturn \"echo \\\"\" . $this->getError() . \"\\\";\";\r\n\t\t\t}\r\n\t\t}\r\n\t\t$evalStr = '';\r\n\t\tforeach ($this->operations as $operation => $opData) {\r\n\t\t\tif ($operation != '') {\r\n\t\t\t\t// create param string and param comment string\r\n\t\t\t\tif (sizeof($opData['input']['parts']) > 0) {\r\n\t\t\t\t\t$paramStr = '';\r\n\t\t\t\t\t$paramArrayStr = '';\r\n\t\t\t\t\t$paramCommentStr = '';\r\n\t\t\t\t\tforeach ($opData['input']['parts'] as $name => $type) {\r\n\t\t\t\t\t\t$paramStr .= \"\\$$name, \";\r\n\t\t\t\t\t\t$paramArrayStr .= \"'$name' => \\$$name, \";\r\n\t\t\t\t\t\t$paramCommentStr .= \"$type \\$$name, \";\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$paramStr = substr($paramStr, 0, strlen($paramStr)-2);\r\n\t\t\t\t\t$paramArrayStr = substr($paramArrayStr, 0, strlen($paramArrayStr)-2);\r\n\t\t\t\t\t$paramCommentStr = substr($paramCommentStr, 0, strlen($paramCommentStr)-2);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$paramStr = '';\r\n\t\t\t\t\t$paramArrayStr = '';\r\n\t\t\t\t\t$paramCommentStr = 'void';\r\n\t\t\t\t}\r\n\t\t\t\t$opData['namespace'] = !isset($opData['namespace']) ? 'http://testuri.com' : $opData['namespace'];\r\n\t\t\t\t$evalStr .= \"// $paramCommentStr\r\n\tfunction \" . str_replace('.', '__', $operation) . \"($paramStr) {\r\n\t\t\\$params = array($paramArrayStr);\r\n\t\treturn \\$this->call('$operation', \\$params, '\".$opData['namespace'].\"', '\".(isset($opData['soapAction']) ? $opData['soapAction'] : '').\"');\r\n\t}\r\n\t\";\r\n\t\t\t\tunset($paramStr);\r\n\t\t\t\tunset($paramCommentStr);\r\n\t\t\t}\r\n\t\t}\r\n\t\t$evalStr = 'class nusoap_proxy_'.$r.' extends nusoap_client {\r\n\t'.$evalStr.'\r\n}';\r\n\t\treturn $evalStr;\r\n\t}\r\n\r\n\t/**\r\n\t* dynamically creates proxy class code\r\n\t*\r\n\t* @return   string PHP/NuSOAP code for the proxy class\r\n\t* @access   public\r\n\t*/\r\n\tfunction getProxyClassCode() {\r\n\t\t$r = rand();\r\n\t\treturn $this->_getProxyClassCode($r);\r\n\t}\r\n\r\n\t/**\r\n\t* gets the HTTP body for the current request.\r\n\t*\r\n\t* @param string $soapmsg The SOAP payload\r\n\t* @return string The HTTP body, which includes the SOAP payload\r\n\t* @access private\r\n\t*/\r\n\tfunction getHTTPBody($soapmsg) {\r\n\t\treturn $soapmsg;\r\n\t}\r\n\t\r\n\t/**\r\n\t* gets the HTTP content type for the current request.\r\n\t*\r\n\t* Note: getHTTPBody must be called before this.\r\n\t*\r\n\t* @return string the HTTP content type for the current request.\r\n\t* @access private\r\n\t*/\r\n\tfunction getHTTPContentType() {\r\n\t\treturn 'text/xml';\r\n\t}\r\n\t\r\n\t/**\r\n\t* gets the HTTP content type charset for the current request.\r\n\t* returns false for non-text content types.\r\n\t*\r\n\t* Note: getHTTPBody must be called before this.\r\n\t*\r\n\t* @return string the HTTP content type charset for the current request.\r\n\t* @access private\r\n\t*/\r\n\tfunction getHTTPContentTypeCharset() {\r\n\t\treturn $this->soap_defencoding;\r\n\t}\r\n\r\n\t/*\r\n\t* whether or not parser should decode utf8 element content\r\n    *\r\n    * @return   always returns true\r\n    * @access   public\r\n    */\r\n    function decodeUTF8($bool){\r\n\t\t$this->decode_utf8 = $bool;\r\n\t\treturn true;\r\n    }\r\n\r\n\t/**\r\n\t * adds a new Cookie into $this->cookies array\r\n\t *\r\n\t * @param\tstring $name Cookie Name\r\n\t * @param\tstring $value Cookie Value\r\n\t * @return\tboolean if cookie-set was successful returns true, else false\r\n\t * @access\tpublic\r\n\t */\r\n\tfunction setCookie($name, $value) {\r\n\t\tif (strlen($name) == 0) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t$this->cookies[] = array('name' => $name, 'value' => $value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * gets all Cookies\r\n\t *\r\n\t * @return   array with all internal cookies\r\n\t * @access   public\r\n\t */\r\n\tfunction getCookies() {\r\n\t\treturn $this->cookies;\r\n\t}\r\n\r\n\t/**\r\n\t * checks all Cookies and delete those which are expired\r\n\t *\r\n\t * @return   boolean always return true\r\n\t * @access   private\r\n\t */\r\n\tfunction checkCookies() {\r\n\t\tif (sizeof($this->cookies) == 0) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t$this->debug('checkCookie: check ' . sizeof($this->cookies) . ' cookies');\r\n\t\t$curr_cookies = $this->cookies;\r\n\t\t$this->cookies = array();\r\n\t\tforeach ($curr_cookies as $cookie) {\r\n\t\t\tif (! is_array($cookie)) {\r\n\t\t\t\t$this->debug('Remove cookie that is not an array');\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif ((isset($cookie['expires'])) && (! empty($cookie['expires']))) {\r\n\t\t\t\tif (strtotime($cookie['expires']) > time()) {\r\n\t\t\t\t\t$this->cookies[] = $cookie;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$this->debug('Remove expired cookie ' . $cookie['name']);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t$this->cookies[] = $cookie;\r\n\t\t\t}\r\n\t\t}\r\n\t\t$this->debug('checkCookie: '.sizeof($this->cookies).' cookies left in array');\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * updates the current cookies with a new set\r\n\t *\r\n\t * @param\tarray $cookies new cookies with which to update current ones\r\n\t * @return\tboolean always return true\r\n\t * @access\tprivate\r\n\t */\r\n\tfunction UpdateCookies($cookies) {\r\n\t\tif (sizeof($this->cookies) == 0) {\r\n\t\t\t// no existing cookies: take whatever is new\r\n\t\t\tif (sizeof($cookies) > 0) {\r\n\t\t\t\t$this->debug('Setting new cookie(s)');\r\n\t\t\t\t$this->cookies = $cookies;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (sizeof($cookies) == 0) {\r\n\t\t\t// no new cookies: keep what we've got\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t// merge\r\n\t\tforeach ($cookies as $newCookie) {\r\n\t\t\tif (!is_array($newCookie)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif ((!isset($newCookie['name'])) || (!isset($newCookie['value']))) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t$newName = $newCookie['name'];\r\n\r\n\t\t\t$found = false;\r\n\t\t\tfor ($i = 0; $i < count($this->cookies); $i++) {\r\n\t\t\t\t$cookie = $this->cookies[$i];\r\n\t\t\t\tif (!is_array($cookie)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (!isset($cookie['name'])) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif ($newName != $cookie['name']) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t$newDomain = isset($newCookie['domain']) ? $newCookie['domain'] : 'NODOMAIN';\r\n\t\t\t\t$domain = isset($cookie['domain']) ? $cookie['domain'] : 'NODOMAIN';\r\n\t\t\t\tif ($newDomain != $domain) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t$newPath = isset($newCookie['path']) ? $newCookie['path'] : 'NOPATH';\r\n\t\t\t\t$path = isset($cookie['path']) ? $cookie['path'] : 'NOPATH';\r\n\t\t\t\tif ($newPath != $path) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t$this->cookies[$i] = $newCookie;\r\n\t\t\t\t$found = true;\r\n\t\t\t\t$this->debug('Update cookie ' . $newName . '=' . $newCookie['value']);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif (! $found) {\r\n\t\t\t\t$this->debug('Add cookie ' . $newName . '=' . $newCookie['value']);\r\n\t\t\t\t$this->cookies[] = $newCookie;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\nif (!extension_loaded('soap')) {\r\n\t/**\r\n\t *\tFor backwards compatiblity, define soapclient unless the PHP SOAP extension is loaded.\r\n\t */\r\n\tclass soapclient extends nusoap_client {\r\n\t}\r\n}\r\n?>\r\n"]],"start1":0,"start2":0,"length1":0,"length2":289758}]],"length":289758}
